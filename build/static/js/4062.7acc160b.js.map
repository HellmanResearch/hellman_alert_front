{"version":3,"file":"static/js/4062.7acc160b.js","mappings":"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","sources":["../node_modules/echarts/lib/util/log.js","../node_modules/echarts/lib/util/model.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { map, isString, isFunction, eqNaN, isRegExp } from 'zrender/lib/core/util.js';\nvar ECHARTS_PREFIX = '[ECharts] ';\nvar storedLogs = {};\nvar hasConsole = typeof console !== 'undefined' // eslint-disable-next-line\n&& console.warn && console.log;\n\nfunction outputLog(type, str, onlyOnce) {\n  if (hasConsole) {\n    if (onlyOnce) {\n      if (storedLogs[str]) {\n        return;\n      }\n\n      storedLogs[str] = true;\n    } // eslint-disable-next-line\n\n\n    console[type](ECHARTS_PREFIX + str);\n  }\n}\n\nexport function log(str, onlyOnce) {\n  outputLog('log', str, onlyOnce);\n}\nexport function warn(str, onlyOnce) {\n  outputLog('warn', str, onlyOnce);\n}\nexport function error(str, onlyOnce) {\n  outputLog('error', str, onlyOnce);\n}\nexport function deprecateLog(str) {\n  if (process.env.NODE_ENV !== 'production') {\n    // Not display duplicate message.\n    outputLog('warn', 'DEPRECATED: ' + str, true);\n  }\n}\nexport function deprecateReplaceLog(oldOpt, newOpt, scope) {\n  if (process.env.NODE_ENV !== 'production') {\n    deprecateLog((scope ? \"[\" + scope + \"]\" : '') + (oldOpt + \" is deprecated, use \" + newOpt + \" instead.\"));\n  }\n}\n/**\n * If in __DEV__ environment, get console printable message for users hint.\n * Parameters are separated by ' '.\n * @usage\n * makePrintable('This is an error on', someVar, someObj);\n *\n * @param hintInfo anything about the current execution context to hint users.\n * @throws Error\n */\n\nexport function makePrintable() {\n  var hintInfo = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    hintInfo[_i] = arguments[_i];\n  }\n\n  var msg = '';\n\n  if (process.env.NODE_ENV !== 'production') {\n    // Fuzzy stringify for print.\n    // This code only exist in dev environment.\n    var makePrintableStringIfPossible_1 = function (val) {\n      return val === void 0 ? 'undefined' : val === Infinity ? 'Infinity' : val === -Infinity ? '-Infinity' : eqNaN(val) ? 'NaN' : val instanceof Date ? 'Date(' + val.toISOString() + ')' : isFunction(val) ? 'function () { ... }' : isRegExp(val) ? val + '' : null;\n    };\n\n    msg = map(hintInfo, function (arg) {\n      if (isString(arg)) {\n        // Print without quotation mark for some statement.\n        return arg;\n      } else {\n        var printableStr = makePrintableStringIfPossible_1(arg);\n\n        if (printableStr != null) {\n          return printableStr;\n        } else if (typeof JSON !== 'undefined' && JSON.stringify) {\n          try {\n            return JSON.stringify(arg, function (n, val) {\n              var printableStr = makePrintableStringIfPossible_1(val);\n              return printableStr == null ? val : printableStr;\n            }); // In most cases the info object is small, so do not line break.\n          } catch (err) {\n            return '?';\n          }\n        } else {\n          return '?';\n        }\n      }\n    }).join(' ');\n  }\n\n  return msg;\n}\n/**\n * @throws Error\n */\n\nexport function throwError(msg) {\n  throw new Error(msg);\n}","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { each, isObject, isArray, createHashMap, map, assert, isString, indexOf, isStringSafe, isNumber } from 'zrender/lib/core/util.js';\nimport env from 'zrender/lib/core/env.js';\nimport { isNumeric, getRandomIdBase, getPrecision, round } from './number.js';\nimport { warn } from './log.js';\n\nfunction interpolateNumber(p0, p1, percent) {\n  return (p1 - p0) * percent + p0;\n}\n/**\n * Make the name displayable. But we should\n * make sure it is not duplicated with user\n * specified name, so use '\\0';\n */\n\n\nvar DUMMY_COMPONENT_NAME_PREFIX = 'series\\0';\nvar INTERNAL_COMPONENT_ID_PREFIX = '\\0_ec_\\0';\n/**\n * If value is not array, then translate it to array.\n * @param  {*} value\n * @return {Array} [value] or value\n */\n\nexport function normalizeToArray(value) {\n  return value instanceof Array ? value : value == null ? [] : [value];\n}\n/**\n * Sync default option between normal and emphasis like `position` and `show`\n * In case some one will write code like\n *     label: {\n *          show: false,\n *          position: 'outside',\n *          fontSize: 18\n *     },\n *     emphasis: {\n *          label: { show: true }\n *     }\n */\n\nexport function defaultEmphasis(opt, key, subOpts) {\n  // Caution: performance sensitive.\n  if (opt) {\n    opt[key] = opt[key] || {};\n    opt.emphasis = opt.emphasis || {};\n    opt.emphasis[key] = opt.emphasis[key] || {}; // Default emphasis option from normal\n\n    for (var i = 0, len = subOpts.length; i < len; i++) {\n      var subOptName = subOpts[i];\n\n      if (!opt.emphasis[key].hasOwnProperty(subOptName) && opt[key].hasOwnProperty(subOptName)) {\n        opt.emphasis[key][subOptName] = opt[key][subOptName];\n      }\n    }\n  }\n}\nexport var TEXT_STYLE_OPTIONS = ['fontStyle', 'fontWeight', 'fontSize', 'fontFamily', 'rich', 'tag', 'color', 'textBorderColor', 'textBorderWidth', 'width', 'height', 'lineHeight', 'align', 'verticalAlign', 'baseline', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY', 'textShadowColor', 'textShadowBlur', 'textShadowOffsetX', 'textShadowOffsetY', 'backgroundColor', 'borderColor', 'borderWidth', 'borderRadius', 'padding']; // modelUtil.LABEL_OPTIONS = modelUtil.TEXT_STYLE_OPTIONS.concat([\n//     'position', 'offset', 'rotate', 'origin', 'show', 'distance', 'formatter',\n//     'fontStyle', 'fontWeight', 'fontSize', 'fontFamily',\n//     // FIXME: deprecated, check and remove it.\n//     'textStyle'\n// ]);\n\n/**\n * The method do not ensure performance.\n * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n * This helper method retieves value from data.\n */\n\nexport function getDataItemValue(dataItem) {\n  return isObject(dataItem) && !isArray(dataItem) && !(dataItem instanceof Date) ? dataItem.value : dataItem;\n}\n/**\n * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n * This helper method determine if dataItem has extra option besides value\n */\n\nexport function isDataItemOption(dataItem) {\n  return isObject(dataItem) && !(dataItem instanceof Array); // // markLine data can be array\n  // && !(dataItem[0] && isObject(dataItem[0]) && !(dataItem[0] instanceof Array));\n}\n;\n/**\n * Mapping to existings for merge.\n *\n * Mode \"normalMege\":\n *     The mapping result (merge result) will keep the order of the existing\n *     component, rather than the order of new option. Because we should ensure\n *     some specified index reference (like xAxisIndex) keep work.\n *     And in most cases, \"merge option\" is used to update partial option but not\n *     be expected to change the order.\n *\n * Mode \"replaceMege\":\n *     (1) Only the id mapped components will be merged.\n *     (2) Other existing components (except internal compoonets) will be removed.\n *     (3) Other new options will be used to create new component.\n *     (4) The index of the existing compoents will not be modified.\n *     That means their might be \"hole\" after the removal.\n *     The new components are created first at those available index.\n *\n * Mode \"replaceAll\":\n *     This mode try to support that reproduce an echarts instance from another\n *     echarts instance (via `getOption`) in some simple cases.\n *     In this senario, the `result` index are exactly the consistent with the `newCmptOptions`,\n *     which ensures the compoennt index referring (like `xAxisIndex: ?`) corrent. That is,\n *     the \"hole\" in `newCmptOptions` will also be kept.\n *     On the contrary, other modes try best to eliminate holes.\n *     PENDING: This is an experimental mode yet.\n *\n * @return See the comment of <MappingResult>.\n */\n\nexport function mappingToExists(existings, newCmptOptions, mode) {\n  var isNormalMergeMode = mode === 'normalMerge';\n  var isReplaceMergeMode = mode === 'replaceMerge';\n  var isReplaceAllMode = mode === 'replaceAll';\n  existings = existings || [];\n  newCmptOptions = (newCmptOptions || []).slice();\n  var existingIdIdxMap = createHashMap(); // Validate id and name on user input option.\n\n  each(newCmptOptions, function (cmptOption, index) {\n    if (!isObject(cmptOption)) {\n      newCmptOptions[index] = null;\n      return;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      // There is some legacy case that name is set as `false`.\n      // But should work normally rather than throw error.\n      if (cmptOption.id != null && !isValidIdOrName(cmptOption.id)) {\n        warnInvalidateIdOrName(cmptOption.id);\n      }\n\n      if (cmptOption.name != null && !isValidIdOrName(cmptOption.name)) {\n        warnInvalidateIdOrName(cmptOption.name);\n      }\n    }\n  });\n  var result = prepareResult(existings, existingIdIdxMap, mode);\n\n  if (isNormalMergeMode || isReplaceMergeMode) {\n    mappingById(result, existings, existingIdIdxMap, newCmptOptions);\n  }\n\n  if (isNormalMergeMode) {\n    mappingByName(result, newCmptOptions);\n  }\n\n  if (isNormalMergeMode || isReplaceMergeMode) {\n    mappingByIndex(result, newCmptOptions, isReplaceMergeMode);\n  } else if (isReplaceAllMode) {\n    mappingInReplaceAllMode(result, newCmptOptions);\n  }\n\n  makeIdAndName(result); // The array `result` MUST NOT contain elided items, otherwise the\n  // forEach will ommit those items and result in incorrect result.\n\n  return result;\n}\n\nfunction prepareResult(existings, existingIdIdxMap, mode) {\n  var result = [];\n\n  if (mode === 'replaceAll') {\n    return result;\n  } // Do not use native `map` to in case that the array `existings`\n  // contains elided items, which will be ommited.\n\n\n  for (var index = 0; index < existings.length; index++) {\n    var existing = existings[index]; // Because of replaceMerge, `existing` may be null/undefined.\n\n    if (existing && existing.id != null) {\n      existingIdIdxMap.set(existing.id, index);\n    } // For non-internal-componnets:\n    //     Mode \"normalMerge\": all existings kept.\n    //     Mode \"replaceMerge\": all existing removed unless mapped by id.\n    // For internal-components:\n    //     go with \"replaceMerge\" approach in both mode.\n\n\n    result.push({\n      existing: mode === 'replaceMerge' || isComponentIdInternal(existing) ? null : existing,\n      newOption: null,\n      keyInfo: null,\n      brandNew: null\n    });\n  }\n\n  return result;\n}\n\nfunction mappingById(result, existings, existingIdIdxMap, newCmptOptions) {\n  // Mapping by id if specified.\n  each(newCmptOptions, function (cmptOption, index) {\n    if (!cmptOption || cmptOption.id == null) {\n      return;\n    }\n\n    var optionId = makeComparableKey(cmptOption.id);\n    var existingIdx = existingIdIdxMap.get(optionId);\n\n    if (existingIdx != null) {\n      var resultItem = result[existingIdx];\n      assert(!resultItem.newOption, 'Duplicated option on id \"' + optionId + '\".');\n      resultItem.newOption = cmptOption; // In both mode, if id matched, new option will be merged to\n      // the existings rather than creating new component model.\n\n      resultItem.existing = existings[existingIdx];\n      newCmptOptions[index] = null;\n    }\n  });\n}\n\nfunction mappingByName(result, newCmptOptions) {\n  // Mapping by name if specified.\n  each(newCmptOptions, function (cmptOption, index) {\n    if (!cmptOption || cmptOption.name == null) {\n      return;\n    }\n\n    for (var i = 0; i < result.length; i++) {\n      var existing = result[i].existing;\n\n      if (!result[i].newOption // Consider name: two map to one.\n      // Can not match when both ids existing but different.\n      && existing && (existing.id == null || cmptOption.id == null) && !isComponentIdInternal(cmptOption) && !isComponentIdInternal(existing) && keyExistAndEqual('name', existing, cmptOption)) {\n        result[i].newOption = cmptOption;\n        newCmptOptions[index] = null;\n        return;\n      }\n    }\n  });\n}\n\nfunction mappingByIndex(result, newCmptOptions, brandNew) {\n  each(newCmptOptions, function (cmptOption) {\n    if (!cmptOption) {\n      return;\n    } // Find the first place that not mapped by id and not internal component (consider the \"hole\").\n\n\n    var resultItem;\n    var nextIdx = 0;\n\n    while ( // Be `!resultItem` only when `nextIdx >= result.length`.\n    (resultItem = result[nextIdx]) && ( // (1) Existing models that already have id should be able to mapped to. Because\n    // after mapping performed, model will always be assigned with an id if user not given.\n    // After that all models have id.\n    // (2) If new option has id, it can only set to a hole or append to the last. It should\n    // not be merged to the existings with different id. Because id should not be overwritten.\n    // (3) Name can be overwritten, because axis use name as 'show label text'.\n    resultItem.newOption || isComponentIdInternal(resultItem.existing) || // In mode \"replaceMerge\", here no not-mapped-non-internal-existing.\n    resultItem.existing && cmptOption.id != null && !keyExistAndEqual('id', cmptOption, resultItem.existing))) {\n      nextIdx++;\n    }\n\n    if (resultItem) {\n      resultItem.newOption = cmptOption;\n      resultItem.brandNew = brandNew;\n    } else {\n      result.push({\n        newOption: cmptOption,\n        brandNew: brandNew,\n        existing: null,\n        keyInfo: null\n      });\n    }\n\n    nextIdx++;\n  });\n}\n\nfunction mappingInReplaceAllMode(result, newCmptOptions) {\n  each(newCmptOptions, function (cmptOption) {\n    // The feature \"reproduce\" requires \"hole\" will also reproduced\n    // in case that compoennt index referring are broken.\n    result.push({\n      newOption: cmptOption,\n      brandNew: true,\n      existing: null,\n      keyInfo: null\n    });\n  });\n}\n/**\n * Make id and name for mapping result (result of mappingToExists)\n * into `keyInfo` field.\n */\n\n\nfunction makeIdAndName(mapResult) {\n  // We use this id to hash component models and view instances\n  // in echarts. id can be specified by user, or auto generated.\n  // The id generation rule ensures new view instance are able\n  // to mapped to old instance when setOption are called in\n  // no-merge mode. So we generate model id by name and plus\n  // type in view id.\n  // name can be duplicated among components, which is convenient\n  // to specify multi components (like series) by one name.\n  // Ensure that each id is distinct.\n  var idMap = createHashMap();\n  each(mapResult, function (item) {\n    var existing = item.existing;\n    existing && idMap.set(existing.id, item);\n  });\n  each(mapResult, function (item) {\n    var opt = item.newOption; // Force ensure id not duplicated.\n\n    assert(!opt || opt.id == null || !idMap.get(opt.id) || idMap.get(opt.id) === item, 'id duplicates: ' + (opt && opt.id));\n    opt && opt.id != null && idMap.set(opt.id, item);\n    !item.keyInfo && (item.keyInfo = {});\n  }); // Make name and id.\n\n  each(mapResult, function (item, index) {\n    var existing = item.existing;\n    var opt = item.newOption;\n    var keyInfo = item.keyInfo;\n\n    if (!isObject(opt)) {\n      return;\n    } // name can be overwitten. Consider case: axis.name = '20km'.\n    // But id generated by name will not be changed, which affect\n    // only in that case: setOption with 'not merge mode' and view\n    // instance will be recreated, which can be accepted.\n\n\n    keyInfo.name = opt.name != null ? makeComparableKey(opt.name) : existing ? existing.name // Avoid diffferent series has the same name,\n    // because name may be used like in color pallet.\n    : DUMMY_COMPONENT_NAME_PREFIX + index;\n\n    if (existing) {\n      keyInfo.id = makeComparableKey(existing.id);\n    } else if (opt.id != null) {\n      keyInfo.id = makeComparableKey(opt.id);\n    } else {\n      // Consider this situatoin:\n      //  optionA: [{name: 'a'}, {name: 'a'}, {..}]\n      //  optionB [{..}, {name: 'a'}, {name: 'a'}]\n      // Series with the same name between optionA and optionB\n      // should be mapped.\n      var idNum = 0;\n\n      do {\n        keyInfo.id = '\\0' + keyInfo.name + '\\0' + idNum++;\n      } while (idMap.get(keyInfo.id));\n    }\n\n    idMap.set(keyInfo.id, item);\n  });\n}\n\nfunction keyExistAndEqual(attr, obj1, obj2) {\n  var key1 = convertOptionIdName(obj1[attr], null);\n  var key2 = convertOptionIdName(obj2[attr], null); // See `MappingExistingItem`. `id` and `name` trade string equals to number.\n\n  return key1 != null && key2 != null && key1 === key2;\n}\n/**\n * @return return null if not exist.\n */\n\n\nfunction makeComparableKey(val) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (val == null) {\n      throw new Error();\n    }\n  }\n\n  return convertOptionIdName(val, '');\n}\n\nexport function convertOptionIdName(idOrName, defaultValue) {\n  if (idOrName == null) {\n    return defaultValue;\n  }\n\n  return isString(idOrName) ? idOrName : isNumber(idOrName) || isStringSafe(idOrName) ? idOrName + '' : defaultValue;\n}\n\nfunction warnInvalidateIdOrName(idOrName) {\n  if (process.env.NODE_ENV !== 'production') {\n    warn('`' + idOrName + '` is invalid id or name. Must be a string or number.');\n  }\n}\n\nfunction isValidIdOrName(idOrName) {\n  return isStringSafe(idOrName) || isNumeric(idOrName);\n}\n\nexport function isNameSpecified(componentModel) {\n  var name = componentModel.name; // Is specified when `indexOf` get -1 or > 0.\n\n  return !!(name && name.indexOf(DUMMY_COMPONENT_NAME_PREFIX));\n}\n/**\n * @public\n * @param {Object} cmptOption\n * @return {boolean}\n */\n\nexport function isComponentIdInternal(cmptOption) {\n  return cmptOption && cmptOption.id != null && makeComparableKey(cmptOption.id).indexOf(INTERNAL_COMPONENT_ID_PREFIX) === 0;\n}\nexport function makeInternalComponentId(idSuffix) {\n  return INTERNAL_COMPONENT_ID_PREFIX + idSuffix;\n}\nexport function setComponentTypeToKeyInfo(mappingResult, mainType, componentModelCtor) {\n  // Set mainType and complete subType.\n  each(mappingResult, function (item) {\n    var newOption = item.newOption;\n\n    if (isObject(newOption)) {\n      item.keyInfo.mainType = mainType;\n      item.keyInfo.subType = determineSubType(mainType, newOption, item.existing, componentModelCtor);\n    }\n  });\n}\n\nfunction determineSubType(mainType, newCmptOption, existComponent, componentModelCtor) {\n  var subType = newCmptOption.type ? newCmptOption.type : existComponent ? existComponent.subType // Use determineSubType only when there is no existComponent.\n  : componentModelCtor.determineSubType(mainType, newCmptOption); // tooltip, markline, markpoint may always has no subType\n\n  return subType;\n}\n/**\n * A helper for removing duplicate items between batchA and batchB,\n * and in themselves, and categorize by series.\n *\n * @param batchA Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n * @param batchB Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n * @return result: [resultBatchA, resultBatchB]\n */\n\n\nexport function compressBatches(batchA, batchB) {\n  var mapA = {};\n  var mapB = {};\n  makeMap(batchA || [], mapA);\n  makeMap(batchB || [], mapB, mapA);\n  return [mapToArray(mapA), mapToArray(mapB)];\n\n  function makeMap(sourceBatch, map, otherMap) {\n    for (var i = 0, len = sourceBatch.length; i < len; i++) {\n      var seriesId = convertOptionIdName(sourceBatch[i].seriesId, null);\n\n      if (seriesId == null) {\n        return;\n      }\n\n      var dataIndices = normalizeToArray(sourceBatch[i].dataIndex);\n      var otherDataIndices = otherMap && otherMap[seriesId];\n\n      for (var j = 0, lenj = dataIndices.length; j < lenj; j++) {\n        var dataIndex = dataIndices[j];\n\n        if (otherDataIndices && otherDataIndices[dataIndex]) {\n          otherDataIndices[dataIndex] = null;\n        } else {\n          (map[seriesId] || (map[seriesId] = {}))[dataIndex] = 1;\n        }\n      }\n    }\n  }\n\n  function mapToArray(map, isData) {\n    var result = [];\n\n    for (var i in map) {\n      if (map.hasOwnProperty(i) && map[i] != null) {\n        if (isData) {\n          result.push(+i);\n        } else {\n          var dataIndices = mapToArray(map[i], true);\n          dataIndices.length && result.push({\n            seriesId: i,\n            dataIndex: dataIndices\n          });\n        }\n      }\n    }\n\n    return result;\n  }\n}\n/**\n * @param payload Contains dataIndex (means rawIndex) / dataIndexInside / name\n *                         each of which can be Array or primary type.\n * @return dataIndex If not found, return undefined/null.\n */\n\nexport function queryDataIndex(data, payload) {\n  if (payload.dataIndexInside != null) {\n    return payload.dataIndexInside;\n  } else if (payload.dataIndex != null) {\n    return isArray(payload.dataIndex) ? map(payload.dataIndex, function (value) {\n      return data.indexOfRawIndex(value);\n    }) : data.indexOfRawIndex(payload.dataIndex);\n  } else if (payload.name != null) {\n    return isArray(payload.name) ? map(payload.name, function (value) {\n      return data.indexOfName(value);\n    }) : data.indexOfName(payload.name);\n  }\n}\n/**\n * Enable property storage to any host object.\n * Notice: Serialization is not supported.\n *\n * For example:\n * let inner = zrUitl.makeInner();\n *\n * function some1(hostObj) {\n *      inner(hostObj).someProperty = 1212;\n *      ...\n * }\n * function some2() {\n *      let fields = inner(this);\n *      fields.someProperty1 = 1212;\n *      fields.someProperty2 = 'xx';\n *      ...\n * }\n *\n * @return {Function}\n */\n\nexport function makeInner() {\n  var key = '__ec_inner_' + innerUniqueIndex++;\n  return function (hostObj) {\n    return hostObj[key] || (hostObj[key] = {});\n  };\n}\nvar innerUniqueIndex = getRandomIdBase();\n/**\n * The same behavior as `component.getReferringComponents`.\n */\n\nexport function parseFinder(ecModel, finderInput, opt) {\n  var _a = preParseFinder(finderInput, opt),\n      mainTypeSpecified = _a.mainTypeSpecified,\n      queryOptionMap = _a.queryOptionMap,\n      others = _a.others;\n\n  var result = others;\n  var defaultMainType = opt ? opt.defaultMainType : null;\n\n  if (!mainTypeSpecified && defaultMainType) {\n    queryOptionMap.set(defaultMainType, {});\n  }\n\n  queryOptionMap.each(function (queryOption, mainType) {\n    var queryResult = queryReferringComponents(ecModel, mainType, queryOption, {\n      useDefault: defaultMainType === mainType,\n      enableAll: opt && opt.enableAll != null ? opt.enableAll : true,\n      enableNone: opt && opt.enableNone != null ? opt.enableNone : true\n    });\n    result[mainType + 'Models'] = queryResult.models;\n    result[mainType + 'Model'] = queryResult.models[0];\n  });\n  return result;\n}\nexport function preParseFinder(finderInput, opt) {\n  var finder;\n\n  if (isString(finderInput)) {\n    var obj = {};\n    obj[finderInput + 'Index'] = 0;\n    finder = obj;\n  } else {\n    finder = finderInput;\n  }\n\n  var queryOptionMap = createHashMap();\n  var others = {};\n  var mainTypeSpecified = false;\n  each(finder, function (value, key) {\n    // Exclude 'dataIndex' and other illgal keys.\n    if (key === 'dataIndex' || key === 'dataIndexInside') {\n      others[key] = value;\n      return;\n    }\n\n    var parsedKey = key.match(/^(\\w+)(Index|Id|Name)$/) || [];\n    var mainType = parsedKey[1];\n    var queryType = (parsedKey[2] || '').toLowerCase();\n\n    if (!mainType || !queryType || opt && opt.includeMainTypes && indexOf(opt.includeMainTypes, mainType) < 0) {\n      return;\n    }\n\n    mainTypeSpecified = mainTypeSpecified || !!mainType;\n    var queryOption = queryOptionMap.get(mainType) || queryOptionMap.set(mainType, {});\n    queryOption[queryType] = value;\n  });\n  return {\n    mainTypeSpecified: mainTypeSpecified,\n    queryOptionMap: queryOptionMap,\n    others: others\n  };\n}\nexport var SINGLE_REFERRING = {\n  useDefault: true,\n  enableAll: false,\n  enableNone: false\n};\nexport var MULTIPLE_REFERRING = {\n  useDefault: false,\n  enableAll: true,\n  enableNone: true\n};\nexport function queryReferringComponents(ecModel, mainType, userOption, opt) {\n  opt = opt || SINGLE_REFERRING;\n  var indexOption = userOption.index;\n  var idOption = userOption.id;\n  var nameOption = userOption.name;\n  var result = {\n    models: null,\n    specified: indexOption != null || idOption != null || nameOption != null\n  };\n\n  if (!result.specified) {\n    // Use the first as default if `useDefault`.\n    var firstCmpt = void 0;\n    result.models = opt.useDefault && (firstCmpt = ecModel.getComponent(mainType)) ? [firstCmpt] : [];\n    return result;\n  }\n\n  if (indexOption === 'none' || indexOption === false) {\n    assert(opt.enableNone, '`\"none\"` or `false` is not a valid value on index option.');\n    result.models = [];\n    return result;\n  } // `queryComponents` will return all components if\n  // both all of index/id/name are null/undefined.\n\n\n  if (indexOption === 'all') {\n    assert(opt.enableAll, '`\"all\"` is not a valid value on index option.');\n    indexOption = idOption = nameOption = null;\n  }\n\n  result.models = ecModel.queryComponents({\n    mainType: mainType,\n    index: indexOption,\n    id: idOption,\n    name: nameOption\n  });\n  return result;\n}\nexport function setAttribute(dom, key, value) {\n  dom.setAttribute ? dom.setAttribute(key, value) : dom[key] = value;\n}\nexport function getAttribute(dom, key) {\n  return dom.getAttribute ? dom.getAttribute(key) : dom[key];\n}\nexport function getTooltipRenderMode(renderModeOption) {\n  if (renderModeOption === 'auto') {\n    // Using html when `document` exists, use richText otherwise\n    return env.domSupported ? 'html' : 'richText';\n  } else {\n    return renderModeOption || 'html';\n  }\n}\n/**\n * Group a list by key.\n */\n\nexport function groupData(array, getKey // return key\n) {\n  var buckets = createHashMap();\n  var keys = [];\n  each(array, function (item) {\n    var key = getKey(item);\n    (buckets.get(key) || (keys.push(key), buckets.set(key, []))).push(item);\n  });\n  return {\n    keys: keys,\n    buckets: buckets\n  };\n}\n/**\n * Interpolate raw values of a series with percent\n *\n * @param data         data\n * @param labelModel   label model of the text element\n * @param sourceValue  start value. May be null/undefined when init.\n * @param targetValue  end value\n * @param percent      0~1 percentage; 0 uses start value while 1 uses end value\n * @return             interpolated values\n *                     If `sourceValue` and `targetValue` are `number`, return `number`.\n *                     If `sourceValue` and `targetValue` are `string`, return `string`.\n *                     If `sourceValue` and `targetValue` are `(string | number)[]`, return `(string | number)[]`.\n *                     Other cases do not supported.\n */\n\nexport function interpolateRawValues(data, precision, sourceValue, targetValue, percent) {\n  var isAutoPrecision = precision == null || precision === 'auto';\n\n  if (targetValue == null) {\n    return targetValue;\n  }\n\n  if (isNumber(targetValue)) {\n    var value = interpolateNumber(sourceValue || 0, targetValue, percent);\n    return round(value, isAutoPrecision ? Math.max(getPrecision(sourceValue || 0), getPrecision(targetValue)) : precision);\n  } else if (isString(targetValue)) {\n    return percent < 1 ? sourceValue : targetValue;\n  } else {\n    var interpolated = [];\n    var leftArr = sourceValue;\n    var rightArr = targetValue;\n    var length_1 = Math.max(leftArr ? leftArr.length : 0, rightArr.length);\n\n    for (var i = 0; i < length_1; ++i) {\n      var info = data.getDimensionInfo(i); // Don't interpolate ordinal dims\n\n      if (info && info.type === 'ordinal') {\n        // In init, there is no `sourceValue`, but should better not to get undefined result.\n        interpolated[i] = (percent < 1 && leftArr ? leftArr : rightArr)[i];\n      } else {\n        var leftVal = leftArr && leftArr[i] ? leftArr[i] : 0;\n        var rightVal = rightArr[i];\n        var value = interpolateNumber(leftVal, rightVal, percent);\n        interpolated[i] = round(value, isAutoPrecision ? Math.max(getPrecision(leftVal), getPrecision(rightVal)) : precision);\n      }\n    }\n\n    return interpolated;\n  }\n}"],"names":["storedLogs","hasConsole","console","warn","log","outputLog","type","str","onlyOnce","deprecateLog","process","throwError","msg","Error","interpolateNumber","p0","p1","percent","DUMMY_COMPONENT_NAME_PREFIX","INTERNAL_COMPONENT_ID_PREFIX","normalizeToArray","value","Array","defaultEmphasis","opt","key","subOpts","emphasis","i","len","length","subOptName","hasOwnProperty","TEXT_STYLE_OPTIONS","getDataItemValue","dataItem","isObject","isArray","Date","isDataItemOption","mappingToExists","existings","newCmptOptions","mode","isNormalMergeMode","isReplaceMergeMode","isReplaceAllMode","slice","existingIdIdxMap","createHashMap","each","cmptOption","index","result","existing","id","set","push","isComponentIdInternal","newOption","keyInfo","brandNew","prepareResult","optionId","makeComparableKey","existingIdx","get","resultItem","assert","mappingById","name","keyExistAndEqual","mappingByName","nextIdx","mappingByIndex","mappingInReplaceAllMode","mapResult","idMap","item","idNum","makeIdAndName","attr","obj1","obj2","key1","convertOptionIdName","key2","val","idOrName","defaultValue","isString","isNumber","isStringSafe","isNameSpecified","componentModel","indexOf","makeInternalComponentId","idSuffix","setComponentTypeToKeyInfo","mappingResult","mainType","componentModelCtor","subType","newCmptOption","existComponent","determineSubType","compressBatches","batchA","batchB","mapA","mapB","makeMap","mapToArray","sourceBatch","map","otherMap","seriesId","dataIndices","dataIndex","otherDataIndices","j","lenj","isData","queryDataIndex","data","payload","dataIndexInside","indexOfRawIndex","indexOfName","makeInner","innerUniqueIndex","hostObj","getRandomIdBase","parseFinder","ecModel","finderInput","_a","preParseFinder","mainTypeSpecified","queryOptionMap","others","defaultMainType","queryOption","queryResult","queryReferringComponents","useDefault","enableAll","enableNone","models","finder","obj","parsedKey","match","queryType","toLowerCase","includeMainTypes","SINGLE_REFERRING","MULTIPLE_REFERRING","userOption","indexOption","idOption","nameOption","specified","firstCmpt","getComponent","queryComponents","setAttribute","dom","getAttribute","getTooltipRenderMode","renderModeOption","env","groupData","array","getKey","buckets","keys","interpolateRawValues","precision","sourceValue","targetValue","isAutoPrecision","round","Math","max","getPrecision","interpolated","leftArr","rightArr","length_1","info","getDimensionInfo","leftVal","rightVal"],"sourceRoot":""}
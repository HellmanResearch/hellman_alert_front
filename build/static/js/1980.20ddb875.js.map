{"version":3,"file":"static/js/1980.20ddb875.js","mappings":"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","sources":["../node_modules/echarts/lib/visual/LegendVisualProvider.js","../node_modules/echarts/lib/visual/VisualMapping.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * LegendVisualProvider is an bridge that pick encoded color from data and\n * provide to the legend component.\n */\nvar LegendVisualProvider =\n/** @class */\nfunction () {\n  function LegendVisualProvider( // Function to get data after filtered. It stores all the encoding info\n  getDataWithEncodedVisual, // Function to get raw data before filtered.\n  getRawData) {\n    this._getDataWithEncodedVisual = getDataWithEncodedVisual;\n    this._getRawData = getRawData;\n  }\n\n  LegendVisualProvider.prototype.getAllNames = function () {\n    var rawData = this._getRawData(); // We find the name from the raw data. In case it's filtered by the legend component.\n    // Normally, the name can be found in rawData, but can't be found in filtered data will display as gray.\n\n\n    return rawData.mapArray(rawData.getName);\n  };\n\n  LegendVisualProvider.prototype.containName = function (name) {\n    var rawData = this._getRawData();\n\n    return rawData.indexOfName(name) >= 0;\n  };\n\n  LegendVisualProvider.prototype.indexOfName = function (name) {\n    // Only get data when necessary.\n    // Because LegendVisualProvider constructor may be new in the stage that data is not prepared yet.\n    // Invoking Series#getData immediately will throw an error.\n    var dataWithEncodedVisual = this._getDataWithEncodedVisual();\n\n    return dataWithEncodedVisual.indexOfName(name);\n  };\n\n  LegendVisualProvider.prototype.getItemVisual = function (dataIndex, key) {\n    // Get encoded visual properties from final filtered data.\n    var dataWithEncodedVisual = this._getDataWithEncodedVisual();\n\n    return dataWithEncodedVisual.getItemVisual(dataIndex, key);\n  };\n\n  return LegendVisualProvider;\n}();\n\nexport default LegendVisualProvider;","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport * as zrUtil from 'zrender/lib/core/util.js';\nimport * as zrColor from 'zrender/lib/tool/color.js';\nimport { linearMap } from '../util/number.js';\nimport { warn } from '../util/log.js';\nvar each = zrUtil.each;\nvar isObject = zrUtil.isObject;\nvar CATEGORY_DEFAULT_VISUAL_INDEX = -1;\n\nvar VisualMapping =\n/** @class */\nfunction () {\n  function VisualMapping(option) {\n    var mappingMethod = option.mappingMethod;\n    var visualType = option.type;\n    var thisOption = this.option = zrUtil.clone(option);\n    this.type = visualType;\n    this.mappingMethod = mappingMethod;\n    this._normalizeData = normalizers[mappingMethod];\n    var visualHandler = VisualMapping.visualHandlers[visualType];\n    this.applyVisual = visualHandler.applyVisual;\n    this.getColorMapper = visualHandler.getColorMapper;\n    this._normalizedToVisual = visualHandler._normalizedToVisual[mappingMethod];\n\n    if (mappingMethod === 'piecewise') {\n      normalizeVisualRange(thisOption);\n      preprocessForPiecewise(thisOption);\n    } else if (mappingMethod === 'category') {\n      thisOption.categories ? preprocessForSpecifiedCategory(thisOption) // categories is ordinal when thisOption.categories not specified,\n      // which need no more preprocess except normalize visual.\n      : normalizeVisualRange(thisOption, true);\n    } else {\n      // mappingMethod === 'linear' or 'fixed'\n      zrUtil.assert(mappingMethod !== 'linear' || thisOption.dataExtent);\n      normalizeVisualRange(thisOption);\n    }\n  }\n\n  VisualMapping.prototype.mapValueToVisual = function (value) {\n    var normalized = this._normalizeData(value);\n\n    return this._normalizedToVisual(normalized, value);\n  };\n\n  VisualMapping.prototype.getNormalizer = function () {\n    return zrUtil.bind(this._normalizeData, this);\n  };\n  /**\n   * List available visual types.\n   *\n   * @public\n   * @return {Array.<string>}\n   */\n\n\n  VisualMapping.listVisualTypes = function () {\n    return zrUtil.keys(VisualMapping.visualHandlers);\n  }; // /**\n  //  * @public\n  //  */\n  // static addVisualHandler(name, handler) {\n  //     visualHandlers[name] = handler;\n  // }\n\n  /**\n   * @public\n   */\n\n\n  VisualMapping.isValidType = function (visualType) {\n    return VisualMapping.visualHandlers.hasOwnProperty(visualType);\n  };\n  /**\n   * Convinent method.\n   * Visual can be Object or Array or primary type.\n   */\n\n\n  VisualMapping.eachVisual = function (visual, callback, context) {\n    if (zrUtil.isObject(visual)) {\n      zrUtil.each(visual, callback, context);\n    } else {\n      callback.call(context, visual);\n    }\n  };\n\n  VisualMapping.mapVisual = function (visual, callback, context) {\n    var isPrimary;\n    var newVisual = zrUtil.isArray(visual) ? [] : zrUtil.isObject(visual) ? {} : (isPrimary = true, null);\n    VisualMapping.eachVisual(visual, function (v, key) {\n      var newVal = callback.call(context, v, key);\n      isPrimary ? newVisual = newVal : newVisual[key] = newVal;\n    });\n    return newVisual;\n  };\n  /**\n   * Retrieve visual properties from given object.\n   */\n\n\n  VisualMapping.retrieveVisuals = function (obj) {\n    var ret = {};\n    var hasVisual;\n    obj && each(VisualMapping.visualHandlers, function (h, visualType) {\n      if (obj.hasOwnProperty(visualType)) {\n        ret[visualType] = obj[visualType];\n        hasVisual = true;\n      }\n    });\n    return hasVisual ? ret : null;\n  };\n  /**\n   * Give order to visual types, considering colorSaturation, colorAlpha depends on color.\n   *\n   * @public\n   * @param {(Object|Array)} visualTypes If Object, like: {color: ..., colorSaturation: ...}\n   *                                     IF Array, like: ['color', 'symbol', 'colorSaturation']\n   * @return {Array.<string>} Sorted visual types.\n   */\n\n\n  VisualMapping.prepareVisualTypes = function (visualTypes) {\n    if (zrUtil.isArray(visualTypes)) {\n      visualTypes = visualTypes.slice();\n    } else if (isObject(visualTypes)) {\n      var types_1 = [];\n      each(visualTypes, function (item, type) {\n        types_1.push(type);\n      });\n      visualTypes = types_1;\n    } else {\n      return [];\n    }\n\n    visualTypes.sort(function (type1, type2) {\n      // color should be front of colorSaturation, colorAlpha, ...\n      // symbol and symbolSize do not matter.\n      return type2 === 'color' && type1 !== 'color' && type1.indexOf('color') === 0 ? 1 : -1;\n    });\n    return visualTypes;\n  };\n  /**\n   * 'color', 'colorSaturation', 'colorAlpha', ... are depends on 'color'.\n   * Other visuals are only depends on themself.\n   */\n\n\n  VisualMapping.dependsOn = function (visualType1, visualType2) {\n    return visualType2 === 'color' ? !!(visualType1 && visualType1.indexOf(visualType2) === 0) : visualType1 === visualType2;\n  };\n  /**\n   * @param value\n   * @param pieceList [{value: ..., interval: [min, max]}, ...]\n   *                         Always from small to big.\n   * @param findClosestWhenOutside Default to be false\n   * @return index\n   */\n\n\n  VisualMapping.findPieceIndex = function (value, pieceList, findClosestWhenOutside) {\n    var possibleI;\n    var abs = Infinity; // value has the higher priority.\n\n    for (var i = 0, len = pieceList.length; i < len; i++) {\n      var pieceValue = pieceList[i].value;\n\n      if (pieceValue != null) {\n        if (pieceValue === value // FIXME\n        // It is supposed to compare value according to value type of dimension,\n        // but currently value type can exactly be string or number.\n        // Compromise for numeric-like string (like '12'), especially\n        // in the case that visualMap.categories is ['22', '33'].\n        || zrUtil.isString(pieceValue) && pieceValue === value + '') {\n          return i;\n        }\n\n        findClosestWhenOutside && updatePossible(pieceValue, i);\n      }\n    }\n\n    for (var i = 0, len = pieceList.length; i < len; i++) {\n      var piece = pieceList[i];\n      var interval = piece.interval;\n      var close_1 = piece.close;\n\n      if (interval) {\n        if (interval[0] === -Infinity) {\n          if (littleThan(close_1[1], value, interval[1])) {\n            return i;\n          }\n        } else if (interval[1] === Infinity) {\n          if (littleThan(close_1[0], interval[0], value)) {\n            return i;\n          }\n        } else if (littleThan(close_1[0], interval[0], value) && littleThan(close_1[1], value, interval[1])) {\n          return i;\n        }\n\n        findClosestWhenOutside && updatePossible(interval[0], i);\n        findClosestWhenOutside && updatePossible(interval[1], i);\n      }\n    }\n\n    if (findClosestWhenOutside) {\n      return value === Infinity ? pieceList.length - 1 : value === -Infinity ? 0 : possibleI;\n    }\n\n    function updatePossible(val, index) {\n      var newAbs = Math.abs(val - value);\n\n      if (newAbs < abs) {\n        abs = newAbs;\n        possibleI = index;\n      }\n    }\n  };\n\n  VisualMapping.visualHandlers = {\n    color: {\n      applyVisual: makeApplyVisual('color'),\n      getColorMapper: function () {\n        var thisOption = this.option;\n        return zrUtil.bind(thisOption.mappingMethod === 'category' ? function (value, isNormalized) {\n          !isNormalized && (value = this._normalizeData(value));\n          return doMapCategory.call(this, value);\n        } : function (value, isNormalized, out) {\n          // If output rgb array\n          // which will be much faster and useful in pixel manipulation\n          var returnRGBArray = !!out;\n          !isNormalized && (value = this._normalizeData(value));\n          out = zrColor.fastLerp(value, thisOption.parsedVisual, out);\n          return returnRGBArray ? out : zrColor.stringify(out, 'rgba');\n        }, this);\n      },\n      _normalizedToVisual: {\n        linear: function (normalized) {\n          return zrColor.stringify(zrColor.fastLerp(normalized, this.option.parsedVisual), 'rgba');\n        },\n        category: doMapCategory,\n        piecewise: function (normalized, value) {\n          var result = getSpecifiedVisual.call(this, value);\n\n          if (result == null) {\n            result = zrColor.stringify(zrColor.fastLerp(normalized, this.option.parsedVisual), 'rgba');\n          }\n\n          return result;\n        },\n        fixed: doMapFixed\n      }\n    },\n    colorHue: makePartialColorVisualHandler(function (color, value) {\n      return zrColor.modifyHSL(color, value);\n    }),\n    colorSaturation: makePartialColorVisualHandler(function (color, value) {\n      return zrColor.modifyHSL(color, null, value);\n    }),\n    colorLightness: makePartialColorVisualHandler(function (color, value) {\n      return zrColor.modifyHSL(color, null, null, value);\n    }),\n    colorAlpha: makePartialColorVisualHandler(function (color, value) {\n      return zrColor.modifyAlpha(color, value);\n    }),\n    decal: {\n      applyVisual: makeApplyVisual('decal'),\n      _normalizedToVisual: {\n        linear: null,\n        category: doMapCategory,\n        piecewise: null,\n        fixed: null\n      }\n    },\n    opacity: {\n      applyVisual: makeApplyVisual('opacity'),\n      _normalizedToVisual: createNormalizedToNumericVisual([0, 1])\n    },\n    liftZ: {\n      applyVisual: makeApplyVisual('liftZ'),\n      _normalizedToVisual: {\n        linear: doMapFixed,\n        category: doMapFixed,\n        piecewise: doMapFixed,\n        fixed: doMapFixed\n      }\n    },\n    symbol: {\n      applyVisual: function (value, getter, setter) {\n        var symbolCfg = this.mapValueToVisual(value);\n        setter('symbol', symbolCfg);\n      },\n      _normalizedToVisual: {\n        linear: doMapToArray,\n        category: doMapCategory,\n        piecewise: function (normalized, value) {\n          var result = getSpecifiedVisual.call(this, value);\n\n          if (result == null) {\n            result = doMapToArray.call(this, normalized);\n          }\n\n          return result;\n        },\n        fixed: doMapFixed\n      }\n    },\n    symbolSize: {\n      applyVisual: makeApplyVisual('symbolSize'),\n      _normalizedToVisual: createNormalizedToNumericVisual([0, 1])\n    }\n  };\n  return VisualMapping;\n}();\n\nfunction preprocessForPiecewise(thisOption) {\n  var pieceList = thisOption.pieceList;\n  thisOption.hasSpecialVisual = false;\n  zrUtil.each(pieceList, function (piece, index) {\n    piece.originIndex = index; // piece.visual is \"result visual value\" but not\n    // a visual range, so it does not need to be normalized.\n\n    if (piece.visual != null) {\n      thisOption.hasSpecialVisual = true;\n    }\n  });\n}\n\nfunction preprocessForSpecifiedCategory(thisOption) {\n  // Hash categories.\n  var categories = thisOption.categories;\n  var categoryMap = thisOption.categoryMap = {};\n  var visual = thisOption.visual;\n  each(categories, function (cate, index) {\n    categoryMap[cate] = index;\n  }); // Process visual map input.\n\n  if (!zrUtil.isArray(visual)) {\n    var visualArr_1 = [];\n\n    if (zrUtil.isObject(visual)) {\n      each(visual, function (v, cate) {\n        var index = categoryMap[cate];\n        visualArr_1[index != null ? index : CATEGORY_DEFAULT_VISUAL_INDEX] = v;\n      });\n    } else {\n      // Is primary type, represents default visual.\n      visualArr_1[CATEGORY_DEFAULT_VISUAL_INDEX] = visual;\n    }\n\n    visual = setVisualToOption(thisOption, visualArr_1);\n  } // Remove categories that has no visual,\n  // then we can mapping them to CATEGORY_DEFAULT_VISUAL_INDEX.\n\n\n  for (var i = categories.length - 1; i >= 0; i--) {\n    if (visual[i] == null) {\n      delete categoryMap[categories[i]];\n      categories.pop();\n    }\n  }\n}\n\nfunction normalizeVisualRange(thisOption, isCategory) {\n  var visual = thisOption.visual;\n  var visualArr = [];\n\n  if (zrUtil.isObject(visual)) {\n    each(visual, function (v) {\n      visualArr.push(v);\n    });\n  } else if (visual != null) {\n    visualArr.push(visual);\n  }\n\n  var doNotNeedPair = {\n    color: 1,\n    symbol: 1\n  };\n\n  if (!isCategory && visualArr.length === 1 && !doNotNeedPair.hasOwnProperty(thisOption.type)) {\n    // Do not care visualArr.length === 0, which is illegal.\n    visualArr[1] = visualArr[0];\n  }\n\n  setVisualToOption(thisOption, visualArr);\n}\n\nfunction makePartialColorVisualHandler(applyValue) {\n  return {\n    applyVisual: function (value, getter, setter) {\n      // Only used in HSL\n      var colorChannel = this.mapValueToVisual(value); // Must not be array value\n\n      setter('color', applyValue(getter('color'), colorChannel));\n    },\n    _normalizedToVisual: createNormalizedToNumericVisual([0, 1])\n  };\n}\n\nfunction doMapToArray(normalized) {\n  var visual = this.option.visual;\n  return visual[Math.round(linearMap(normalized, [0, 1], [0, visual.length - 1], true))] || {}; // TODO {}?\n}\n\nfunction makeApplyVisual(visualType) {\n  return function (value, getter, setter) {\n    setter(visualType, this.mapValueToVisual(value));\n  };\n}\n\nfunction doMapCategory(normalized) {\n  var visual = this.option.visual;\n  return visual[this.option.loop && normalized !== CATEGORY_DEFAULT_VISUAL_INDEX ? normalized % visual.length : normalized];\n}\n\nfunction doMapFixed() {\n  // visual will be convert to array.\n  return this.option.visual[0];\n}\n/**\n * Create mapped to numeric visual\n */\n\n\nfunction createNormalizedToNumericVisual(sourceExtent) {\n  return {\n    linear: function (normalized) {\n      return linearMap(normalized, sourceExtent, this.option.visual, true);\n    },\n    category: doMapCategory,\n    piecewise: function (normalized, value) {\n      var result = getSpecifiedVisual.call(this, value);\n\n      if (result == null) {\n        result = linearMap(normalized, sourceExtent, this.option.visual, true);\n      }\n\n      return result;\n    },\n    fixed: doMapFixed\n  };\n}\n\nfunction getSpecifiedVisual(value) {\n  var thisOption = this.option;\n  var pieceList = thisOption.pieceList;\n\n  if (thisOption.hasSpecialVisual) {\n    var pieceIndex = VisualMapping.findPieceIndex(value, pieceList);\n    var piece = pieceList[pieceIndex];\n\n    if (piece && piece.visual) {\n      return piece.visual[this.type];\n    }\n  }\n}\n\nfunction setVisualToOption(thisOption, visualArr) {\n  thisOption.visual = visualArr;\n\n  if (thisOption.type === 'color') {\n    thisOption.parsedVisual = zrUtil.map(visualArr, function (item) {\n      var color = zrColor.parse(item);\n\n      if (!color && process.env.NODE_ENV !== 'production') {\n        warn(\"'\" + item + \"' is an illegal color, fallback to '#000000'\", true);\n      }\n\n      return color || [0, 0, 0, 1];\n    });\n  }\n\n  return visualArr;\n}\n/**\n * Normalizers by mapping methods.\n */\n\n\nvar normalizers = {\n  linear: function (value) {\n    return linearMap(value, this.option.dataExtent, [0, 1], true);\n  },\n  piecewise: function (value) {\n    var pieceList = this.option.pieceList;\n    var pieceIndex = VisualMapping.findPieceIndex(value, pieceList, true);\n\n    if (pieceIndex != null) {\n      return linearMap(pieceIndex, [0, pieceList.length - 1], [0, 1], true);\n    }\n  },\n  category: function (value) {\n    var index = this.option.categories ? this.option.categoryMap[value] : value; // ordinal value\n\n    return index == null ? CATEGORY_DEFAULT_VISUAL_INDEX : index;\n  },\n  fixed: zrUtil.noop\n};\n\nfunction littleThan(close, a, b) {\n  return close ? a <= b : a < b;\n}\n\nexport default VisualMapping;"],"names":["LegendVisualProvider","getDataWithEncodedVisual","getRawData","this","_getDataWithEncodedVisual","_getRawData","prototype","getAllNames","rawData","mapArray","getName","containName","name","indexOfName","getItemVisual","dataIndex","key","each","zrUtil","isObject","CATEGORY_DEFAULT_VISUAL_INDEX","VisualMapping","option","mappingMethod","visualType","type","thisOption","_normalizeData","normalizers","visualHandler","visualHandlers","applyVisual","getColorMapper","_normalizedToVisual","normalizeVisualRange","pieceList","hasSpecialVisual","piece","index","originIndex","visual","preprocessForPiecewise","categories","categoryMap","cate","visualArr_1","v","setVisualToOption","i","length","pop","preprocessForSpecifiedCategory","dataExtent","mapValueToVisual","value","normalized","getNormalizer","listVisualTypes","isValidType","hasOwnProperty","eachVisual","callback","context","call","mapVisual","isPrimary","newVisual","newVal","retrieveVisuals","obj","hasVisual","ret","h","prepareVisualTypes","visualTypes","slice","types_1","item","push","sort","type1","type2","indexOf","dependsOn","visualType1","visualType2","findPieceIndex","findClosestWhenOutside","possibleI","abs","Infinity","len","pieceValue","updatePossible","interval","close_1","close","littleThan","val","newAbs","Math","color","makeApplyVisual","isNormalized","doMapCategory","out","returnRGBArray","zrColor","parsedVisual","linear","category","piecewise","result","getSpecifiedVisual","fixed","doMapFixed","colorHue","makePartialColorVisualHandler","colorSaturation","colorLightness","colorAlpha","decal","opacity","createNormalizedToNumericVisual","liftZ","symbol","getter","setter","doMapToArray","symbolSize","isCategory","visualArr","applyValue","colorChannel","round","linearMap","loop","sourceExtent","pieceIndex","a","b"],"sourceRoot":""}
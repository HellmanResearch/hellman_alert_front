{"version":3,"file":"static/js/7647.8312aa94.js","mappings":"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","sources":["../node_modules/echarts/lib/data/DataStore.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { assert, clone, createHashMap, isFunction, keys, map, reduce } from 'zrender/lib/core/util.js';\nimport { parseDataValue } from './helper/dataValueHelper.js';\nimport { shouldRetrieveDataByName } from './Source.js';\nvar UNDEFINED = 'undefined';\n/* global Float64Array, Int32Array, Uint32Array, Uint16Array */\n// Caution: MUST not use `new CtorUint32Array(arr, 0, len)`, because the Ctor of array is\n// different from the Ctor of typed array.\n\nexport var CtorUint32Array = typeof Uint32Array === UNDEFINED ? Array : Uint32Array;\nexport var CtorUint16Array = typeof Uint16Array === UNDEFINED ? Array : Uint16Array;\nexport var CtorInt32Array = typeof Int32Array === UNDEFINED ? Array : Int32Array;\nexport var CtorFloat64Array = typeof Float64Array === UNDEFINED ? Array : Float64Array;\n/**\n * Multi dimensional data store\n */\n\nvar dataCtors = {\n  'float': CtorFloat64Array,\n  'int': CtorInt32Array,\n  // Ordinal data type can be string or int\n  'ordinal': Array,\n  'number': Array,\n  'time': CtorFloat64Array\n};\nvar defaultDimValueGetters;\n\nfunction getIndicesCtor(rawCount) {\n  // The possible max value in this._indicies is always this._rawCount despite of filtering.\n  return rawCount > 65535 ? CtorUint32Array : CtorUint16Array;\n}\n\n;\n\nfunction getInitialExtent() {\n  return [Infinity, -Infinity];\n}\n\n;\n\nfunction cloneChunk(originalChunk) {\n  var Ctor = originalChunk.constructor; // Only shallow clone is enough when Array.\n\n  return Ctor === Array ? originalChunk.slice() : new Ctor(originalChunk);\n}\n\nfunction prepareStore(store, dimIdx, dimType, end, append) {\n  var DataCtor = dataCtors[dimType || 'float'];\n\n  if (append) {\n    var oldStore = store[dimIdx];\n    var oldLen = oldStore && oldStore.length;\n\n    if (!(oldLen === end)) {\n      var newStore = new DataCtor(end); // The cost of the copy is probably inconsiderable\n      // within the initial chunkSize.\n\n      for (var j = 0; j < oldLen; j++) {\n        newStore[j] = oldStore[j];\n      }\n\n      store[dimIdx] = newStore;\n    }\n  } else {\n    store[dimIdx] = new DataCtor(end);\n  }\n}\n\n;\n/**\n * Basically, DataStore API keep immutable.\n */\n\nvar DataStore =\n/** @class */\nfunction () {\n  function DataStore() {\n    this._chunks = []; // It will not be calculated util needed.\n\n    this._rawExtent = [];\n    this._extent = [];\n    this._count = 0;\n    this._rawCount = 0;\n    this._calcDimNameToIdx = createHashMap();\n  }\n  /**\n   * Initialize from data\n   */\n\n\n  DataStore.prototype.initData = function (provider, inputDimensions, dimValueGetter) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(isFunction(provider.getItem) && isFunction(provider.count), 'Invalid data provider.');\n    }\n\n    this._provider = provider; // Clear\n\n    this._chunks = [];\n    this._indices = null;\n    this.getRawIndex = this._getRawIdxIdentity;\n    var source = provider.getSource();\n    var defaultGetter = this.defaultDimValueGetter = defaultDimValueGetters[source.sourceFormat]; // Default dim value getter\n\n    this._dimValueGetter = dimValueGetter || defaultGetter; // Reset raw extent.\n\n    this._rawExtent = [];\n    var willRetrieveDataByName = shouldRetrieveDataByName(source);\n    this._dimensions = map(inputDimensions, function (dim) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (willRetrieveDataByName) {\n          assert(dim.property != null);\n        }\n      }\n\n      return {\n        // Only pick these two props. Not leak other properties like orderMeta.\n        type: dim.type,\n        property: dim.property\n      };\n    });\n\n    this._initDataFromProvider(0, provider.count());\n  };\n\n  DataStore.prototype.getProvider = function () {\n    return this._provider;\n  };\n  /**\n   * Caution: even when a `source` instance owned by a series, the created data store\n   * may still be shared by different sereis (the source hash does not use all `source`\n   * props, see `sourceManager`). In this case, the `source` props that are not used in\n   * hash (like `source.dimensionDefine`) probably only belongs to a certain series and\n   * thus should not be fetch here.\n   */\n\n\n  DataStore.prototype.getSource = function () {\n    return this._provider.getSource();\n  };\n  /**\n   * @caution Only used in dataStack.\n   */\n\n\n  DataStore.prototype.ensureCalculationDimension = function (dimName, type) {\n    var calcDimNameToIdx = this._calcDimNameToIdx;\n    var dimensions = this._dimensions;\n    var calcDimIdx = calcDimNameToIdx.get(dimName);\n\n    if (calcDimIdx != null) {\n      if (dimensions[calcDimIdx].type === type) {\n        return calcDimIdx;\n      }\n    } else {\n      calcDimIdx = dimensions.length;\n    }\n\n    dimensions[calcDimIdx] = {\n      type: type\n    };\n    calcDimNameToIdx.set(dimName, calcDimIdx);\n    this._chunks[calcDimIdx] = new dataCtors[type || 'float'](this._rawCount);\n    this._rawExtent[calcDimIdx] = getInitialExtent();\n    return calcDimIdx;\n  };\n\n  DataStore.prototype.collectOrdinalMeta = function (dimIdx, ordinalMeta) {\n    var chunk = this._chunks[dimIdx];\n    var dim = this._dimensions[dimIdx];\n    var rawExtents = this._rawExtent;\n    var offset = dim.ordinalOffset || 0;\n    var len = chunk.length;\n\n    if (offset === 0) {\n      // We need to reset the rawExtent if collect is from start.\n      // Because this dimension may be guessed as number and calcuating a wrong extent.\n      rawExtents[dimIdx] = getInitialExtent();\n    }\n\n    var dimRawExtent = rawExtents[dimIdx]; // Parse from previous data offset. len may be changed after appendData\n\n    for (var i = offset; i < len; i++) {\n      var val = chunk[i] = ordinalMeta.parseAndCollect(chunk[i]);\n\n      if (!isNaN(val)) {\n        dimRawExtent[0] = Math.min(val, dimRawExtent[0]);\n        dimRawExtent[1] = Math.max(val, dimRawExtent[1]);\n      }\n    }\n\n    dim.ordinalMeta = ordinalMeta;\n    dim.ordinalOffset = len;\n    dim.type = 'ordinal'; // Force to be ordinal\n  };\n\n  DataStore.prototype.getOrdinalMeta = function (dimIdx) {\n    var dimInfo = this._dimensions[dimIdx];\n    var ordinalMeta = dimInfo.ordinalMeta;\n    return ordinalMeta;\n  };\n\n  DataStore.prototype.getDimensionProperty = function (dimIndex) {\n    var item = this._dimensions[dimIndex];\n    return item && item.property;\n  };\n  /**\n   * Caution: Can be only called on raw data (before `this._indices` created).\n   */\n\n\n  DataStore.prototype.appendData = function (data) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(!this._indices, 'appendData can only be called on raw data.');\n    }\n\n    var provider = this._provider;\n    var start = this.count();\n    provider.appendData(data);\n    var end = provider.count();\n\n    if (!provider.persistent) {\n      end += start;\n    }\n\n    if (start < end) {\n      this._initDataFromProvider(start, end, true);\n    }\n\n    return [start, end];\n  };\n\n  DataStore.prototype.appendValues = function (values, minFillLen) {\n    var chunks = this._chunks;\n    var dimensions = this._dimensions;\n    var dimLen = dimensions.length;\n    var rawExtent = this._rawExtent;\n    var start = this.count();\n    var end = start + Math.max(values.length, minFillLen || 0);\n\n    for (var i = 0; i < dimLen; i++) {\n      var dim = dimensions[i];\n      prepareStore(chunks, i, dim.type, end, true);\n    }\n\n    var emptyDataItem = [];\n\n    for (var idx = start; idx < end; idx++) {\n      var sourceIdx = idx - start; // Store the data by dimensions\n\n      for (var dimIdx = 0; dimIdx < dimLen; dimIdx++) {\n        var dim = dimensions[dimIdx];\n        var val = defaultDimValueGetters.arrayRows.call(this, values[sourceIdx] || emptyDataItem, dim.property, sourceIdx, dimIdx);\n        chunks[dimIdx][idx] = val;\n        var dimRawExtent = rawExtent[dimIdx];\n        val < dimRawExtent[0] && (dimRawExtent[0] = val);\n        val > dimRawExtent[1] && (dimRawExtent[1] = val);\n      }\n    }\n\n    this._rawCount = this._count = end;\n    return {\n      start: start,\n      end: end\n    };\n  };\n\n  DataStore.prototype._initDataFromProvider = function (start, end, append) {\n    var provider = this._provider;\n    var chunks = this._chunks;\n    var dimensions = this._dimensions;\n    var dimLen = dimensions.length;\n    var rawExtent = this._rawExtent;\n    var dimNames = map(dimensions, function (dim) {\n      return dim.property;\n    });\n\n    for (var i = 0; i < dimLen; i++) {\n      var dim = dimensions[i];\n\n      if (!rawExtent[i]) {\n        rawExtent[i] = getInitialExtent();\n      }\n\n      prepareStore(chunks, i, dim.type, end, append);\n    }\n\n    if (provider.fillStorage) {\n      provider.fillStorage(start, end, chunks, rawExtent);\n    } else {\n      var dataItem = [];\n\n      for (var idx = start; idx < end; idx++) {\n        // NOTICE: Try not to write things into dataItem\n        dataItem = provider.getItem(idx, dataItem); // Each data item is value\n        // [1, 2]\n        // 2\n        // Bar chart, line chart which uses category axis\n        // only gives the 'y' value. 'x' value is the indices of category\n        // Use a tempValue to normalize the value to be a (x, y) value\n        // Store the data by dimensions\n\n        for (var dimIdx = 0; dimIdx < dimLen; dimIdx++) {\n          var dimStorage = chunks[dimIdx]; // PENDING NULL is empty or zero\n\n          var val = this._dimValueGetter(dataItem, dimNames[dimIdx], idx, dimIdx);\n\n          dimStorage[idx] = val;\n          var dimRawExtent = rawExtent[dimIdx];\n          val < dimRawExtent[0] && (dimRawExtent[0] = val);\n          val > dimRawExtent[1] && (dimRawExtent[1] = val);\n        }\n      }\n    }\n\n    if (!provider.persistent && provider.clean) {\n      // Clean unused data if data source is typed array.\n      provider.clean();\n    }\n\n    this._rawCount = this._count = end; // Reset data extent\n\n    this._extent = [];\n  };\n\n  DataStore.prototype.count = function () {\n    return this._count;\n  };\n  /**\n   * Get value. Return NaN if idx is out of range.\n   */\n\n\n  DataStore.prototype.get = function (dim, idx) {\n    if (!(idx >= 0 && idx < this._count)) {\n      return NaN;\n    }\n\n    var dimStore = this._chunks[dim];\n    return dimStore ? dimStore[this.getRawIndex(idx)] : NaN;\n  };\n\n  DataStore.prototype.getValues = function (dimensions, idx) {\n    var values = [];\n    var dimArr = [];\n\n    if (idx == null) {\n      idx = dimensions; // TODO get all from store?\n\n      dimensions = []; // All dimensions\n\n      for (var i = 0; i < this._dimensions.length; i++) {\n        dimArr.push(i);\n      }\n    } else {\n      dimArr = dimensions;\n    }\n\n    for (var i = 0, len = dimArr.length; i < len; i++) {\n      values.push(this.get(dimArr[i], idx));\n    }\n\n    return values;\n  };\n  /**\n   * @param dim concrete dim\n   */\n\n\n  DataStore.prototype.getByRawIndex = function (dim, rawIdx) {\n    if (!(rawIdx >= 0 && rawIdx < this._rawCount)) {\n      return NaN;\n    }\n\n    var dimStore = this._chunks[dim];\n    return dimStore ? dimStore[rawIdx] : NaN;\n  };\n  /**\n   * Get sum of data in one dimension\n   */\n\n\n  DataStore.prototype.getSum = function (dim) {\n    var dimData = this._chunks[dim];\n    var sum = 0;\n\n    if (dimData) {\n      for (var i = 0, len = this.count(); i < len; i++) {\n        var value = this.get(dim, i);\n\n        if (!isNaN(value)) {\n          sum += value;\n        }\n      }\n    }\n\n    return sum;\n  };\n  /**\n   * Get median of data in one dimension\n   */\n\n\n  DataStore.prototype.getMedian = function (dim) {\n    var dimDataArray = []; // map all data of one dimension\n\n    this.each([dim], function (val) {\n      if (!isNaN(val)) {\n        dimDataArray.push(val);\n      }\n    }); // TODO\n    // Use quick select?\n\n    var sortedDimDataArray = dimDataArray.sort(function (a, b) {\n      return a - b;\n    });\n    var len = this.count(); // calculate median\n\n    return len === 0 ? 0 : len % 2 === 1 ? sortedDimDataArray[(len - 1) / 2] : (sortedDimDataArray[len / 2] + sortedDimDataArray[len / 2 - 1]) / 2;\n  };\n  /**\n   * Retreive the index with given raw data index\n   */\n\n\n  DataStore.prototype.indexOfRawIndex = function (rawIndex) {\n    if (rawIndex >= this._rawCount || rawIndex < 0) {\n      return -1;\n    }\n\n    if (!this._indices) {\n      return rawIndex;\n    } // Indices are ascending\n\n\n    var indices = this._indices; // If rawIndex === dataIndex\n\n    var rawDataIndex = indices[rawIndex];\n\n    if (rawDataIndex != null && rawDataIndex < this._count && rawDataIndex === rawIndex) {\n      return rawIndex;\n    }\n\n    var left = 0;\n    var right = this._count - 1;\n\n    while (left <= right) {\n      var mid = (left + right) / 2 | 0;\n\n      if (indices[mid] < rawIndex) {\n        left = mid + 1;\n      } else if (indices[mid] > rawIndex) {\n        right = mid - 1;\n      } else {\n        return mid;\n      }\n    }\n\n    return -1;\n  };\n  /**\n   * Retreive the index of nearest value\n   * @param dim\n   * @param value\n   * @param [maxDistance=Infinity]\n   * @return If and only if multiple indices has\n   *         the same value, they are put to the result.\n   */\n\n\n  DataStore.prototype.indicesOfNearest = function (dim, value, maxDistance) {\n    var chunks = this._chunks;\n    var dimData = chunks[dim];\n    var nearestIndices = [];\n\n    if (!dimData) {\n      return nearestIndices;\n    }\n\n    if (maxDistance == null) {\n      maxDistance = Infinity;\n    }\n\n    var minDist = Infinity;\n    var minDiff = -1;\n    var nearestIndicesLen = 0; // Check the test case of `test/ut/spec/data/SeriesData.js`.\n\n    for (var i = 0, len = this.count(); i < len; i++) {\n      var dataIndex = this.getRawIndex(i);\n      var diff = value - dimData[dataIndex];\n      var dist = Math.abs(diff);\n\n      if (dist <= maxDistance) {\n        // When the `value` is at the middle of `this.get(dim, i)` and `this.get(dim, i+1)`,\n        // we'd better not push both of them to `nearestIndices`, otherwise it is easy to\n        // get more than one item in `nearestIndices` (more specifically, in `tooltip`).\n        // So we chose the one that `diff >= 0` in this csae.\n        // But if `this.get(dim, i)` and `this.get(dim, j)` get the same value, both of them\n        // should be push to `nearestIndices`.\n        if (dist < minDist || dist === minDist && diff >= 0 && minDiff < 0) {\n          minDist = dist;\n          minDiff = diff;\n          nearestIndicesLen = 0;\n        }\n\n        if (diff === minDiff) {\n          nearestIndices[nearestIndicesLen++] = i;\n        }\n      }\n    }\n\n    nearestIndices.length = nearestIndicesLen;\n    return nearestIndices;\n  };\n\n  DataStore.prototype.getIndices = function () {\n    var newIndices;\n    var indices = this._indices;\n\n    if (indices) {\n      var Ctor = indices.constructor;\n      var thisCount = this._count; // `new Array(a, b, c)` is different from `new Uint32Array(a, b, c)`.\n\n      if (Ctor === Array) {\n        newIndices = new Ctor(thisCount);\n\n        for (var i = 0; i < thisCount; i++) {\n          newIndices[i] = indices[i];\n        }\n      } else {\n        newIndices = new Ctor(indices.buffer, 0, thisCount);\n      }\n    } else {\n      var Ctor = getIndicesCtor(this._rawCount);\n      newIndices = new Ctor(this.count());\n\n      for (var i = 0; i < newIndices.length; i++) {\n        newIndices[i] = i;\n      }\n    }\n\n    return newIndices;\n  };\n  /**\n   * Data filter.\n   */\n\n\n  DataStore.prototype.filter = function (dims, cb) {\n    if (!this._count) {\n      return this;\n    }\n\n    var newStore = this.clone();\n    var count = newStore.count();\n    var Ctor = getIndicesCtor(newStore._rawCount);\n    var newIndices = new Ctor(count);\n    var value = [];\n    var dimSize = dims.length;\n    var offset = 0;\n    var dim0 = dims[0];\n    var chunks = newStore._chunks;\n\n    for (var i = 0; i < count; i++) {\n      var keep = void 0;\n      var rawIdx = newStore.getRawIndex(i); // Simple optimization\n\n      if (dimSize === 0) {\n        keep = cb(i);\n      } else if (dimSize === 1) {\n        var val = chunks[dim0][rawIdx];\n        keep = cb(val, i);\n      } else {\n        var k = 0;\n\n        for (; k < dimSize; k++) {\n          value[k] = chunks[dims[k]][rawIdx];\n        }\n\n        value[k] = i;\n        keep = cb.apply(null, value);\n      }\n\n      if (keep) {\n        newIndices[offset++] = rawIdx;\n      }\n    } // Set indices after filtered.\n\n\n    if (offset < count) {\n      newStore._indices = newIndices;\n    }\n\n    newStore._count = offset; // Reset data extent\n\n    newStore._extent = [];\n\n    newStore._updateGetRawIdx();\n\n    return newStore;\n  };\n  /**\n   * Select data in range. (For optimization of filter)\n   * (Manually inline code, support 5 million data filtering in data zoom.)\n   */\n\n\n  DataStore.prototype.selectRange = function (range) {\n    var newStore = this.clone();\n    var len = newStore._count;\n\n    if (!len) {\n      return this;\n    }\n\n    var dims = keys(range);\n    var dimSize = dims.length;\n\n    if (!dimSize) {\n      return this;\n    }\n\n    var originalCount = newStore.count();\n    var Ctor = getIndicesCtor(newStore._rawCount);\n    var newIndices = new Ctor(originalCount);\n    var offset = 0;\n    var dim0 = dims[0];\n    var min = range[dim0][0];\n    var max = range[dim0][1];\n    var storeArr = newStore._chunks;\n    var quickFinished = false;\n\n    if (!newStore._indices) {\n      // Extreme optimization for common case. About 2x faster in chrome.\n      var idx = 0;\n\n      if (dimSize === 1) {\n        var dimStorage = storeArr[dims[0]];\n\n        for (var i = 0; i < len; i++) {\n          var val = dimStorage[i]; // NaN will not be filtered. Consider the case, in line chart, empty\n          // value indicates the line should be broken. But for the case like\n          // scatter plot, a data item with empty value will not be rendered,\n          // but the axis extent may be effected if some other dim of the data\n          // item has value. Fortunately it is not a significant negative effect.\n\n          if (val >= min && val <= max || isNaN(val)) {\n            newIndices[offset++] = idx;\n          }\n\n          idx++;\n        }\n\n        quickFinished = true;\n      } else if (dimSize === 2) {\n        var dimStorage = storeArr[dims[0]];\n        var dimStorage2 = storeArr[dims[1]];\n        var min2 = range[dims[1]][0];\n        var max2 = range[dims[1]][1];\n\n        for (var i = 0; i < len; i++) {\n          var val = dimStorage[i];\n          var val2 = dimStorage2[i]; // Do not filter NaN, see comment above.\n\n          if ((val >= min && val <= max || isNaN(val)) && (val2 >= min2 && val2 <= max2 || isNaN(val2))) {\n            newIndices[offset++] = idx;\n          }\n\n          idx++;\n        }\n\n        quickFinished = true;\n      }\n    }\n\n    if (!quickFinished) {\n      if (dimSize === 1) {\n        for (var i = 0; i < originalCount; i++) {\n          var rawIndex = newStore.getRawIndex(i);\n          var val = storeArr[dims[0]][rawIndex]; // Do not filter NaN, see comment above.\n\n          if (val >= min && val <= max || isNaN(val)) {\n            newIndices[offset++] = rawIndex;\n          }\n        }\n      } else {\n        for (var i = 0; i < originalCount; i++) {\n          var keep = true;\n          var rawIndex = newStore.getRawIndex(i);\n\n          for (var k = 0; k < dimSize; k++) {\n            var dimk = dims[k];\n            var val = storeArr[dimk][rawIndex]; // Do not filter NaN, see comment above.\n\n            if (val < range[dimk][0] || val > range[dimk][1]) {\n              keep = false;\n            }\n          }\n\n          if (keep) {\n            newIndices[offset++] = newStore.getRawIndex(i);\n          }\n        }\n      }\n    } // Set indices after filtered.\n\n\n    if (offset < originalCount) {\n      newStore._indices = newIndices;\n    }\n\n    newStore._count = offset; // Reset data extent\n\n    newStore._extent = [];\n\n    newStore._updateGetRawIdx();\n\n    return newStore;\n  }; // /**\n  //  * Data mapping to a plain array\n  //  */\n  // mapArray(dims: DimensionIndex[], cb: MapArrayCb): any[] {\n  //     const result: any[] = [];\n  //     this.each(dims, function () {\n  //         result.push(cb && (cb as MapArrayCb).apply(null, arguments));\n  //     });\n  //     return result;\n  // }\n\n  /**\n   * Data mapping to a new List with given dimensions\n   */\n\n\n  DataStore.prototype.map = function (dims, cb) {\n    // TODO only clone picked chunks.\n    var target = this.clone(dims);\n\n    this._updateDims(target, dims, cb);\n\n    return target;\n  };\n  /**\n   * @caution Danger!! Only used in dataStack.\n   */\n\n\n  DataStore.prototype.modify = function (dims, cb) {\n    this._updateDims(this, dims, cb);\n  };\n\n  DataStore.prototype._updateDims = function (target, dims, cb) {\n    var targetChunks = target._chunks;\n    var tmpRetValue = [];\n    var dimSize = dims.length;\n    var dataCount = target.count();\n    var values = [];\n    var rawExtent = target._rawExtent;\n\n    for (var i = 0; i < dims.length; i++) {\n      rawExtent[dims[i]] = getInitialExtent();\n    }\n\n    for (var dataIndex = 0; dataIndex < dataCount; dataIndex++) {\n      var rawIndex = target.getRawIndex(dataIndex);\n\n      for (var k = 0; k < dimSize; k++) {\n        values[k] = targetChunks[dims[k]][rawIndex];\n      }\n\n      values[dimSize] = dataIndex;\n      var retValue = cb && cb.apply(null, values);\n\n      if (retValue != null) {\n        // a number or string (in oridinal dimension)?\n        if (typeof retValue !== 'object') {\n          tmpRetValue[0] = retValue;\n          retValue = tmpRetValue;\n        }\n\n        for (var i = 0; i < retValue.length; i++) {\n          var dim = dims[i];\n          var val = retValue[i];\n          var rawExtentOnDim = rawExtent[dim];\n          var dimStore = targetChunks[dim];\n\n          if (dimStore) {\n            dimStore[rawIndex] = val;\n          }\n\n          if (val < rawExtentOnDim[0]) {\n            rawExtentOnDim[0] = val;\n          }\n\n          if (val > rawExtentOnDim[1]) {\n            rawExtentOnDim[1] = val;\n          }\n        }\n      }\n    }\n  };\n  /**\n   * Large data down sampling using largest-triangle-three-buckets\n   * @param {string} valueDimension\n   * @param {number} targetCount\n   */\n\n\n  DataStore.prototype.lttbDownSample = function (valueDimension, rate) {\n    var target = this.clone([valueDimension], true);\n    var targetStorage = target._chunks;\n    var dimStore = targetStorage[valueDimension];\n    var len = this.count();\n    var sampledIndex = 0;\n    var frameSize = Math.floor(1 / rate);\n    var currentRawIndex = this.getRawIndex(0);\n    var maxArea;\n    var area;\n    var nextRawIndex;\n    var newIndices = new (getIndicesCtor(this._rawCount))(Math.min((Math.ceil(len / frameSize) + 2) * 2, len)); // First frame use the first data.\n\n    newIndices[sampledIndex++] = currentRawIndex;\n\n    for (var i = 1; i < len - 1; i += frameSize) {\n      var nextFrameStart = Math.min(i + frameSize, len - 1);\n      var nextFrameEnd = Math.min(i + frameSize * 2, len);\n      var avgX = (nextFrameEnd + nextFrameStart) / 2;\n      var avgY = 0;\n\n      for (var idx = nextFrameStart; idx < nextFrameEnd; idx++) {\n        var rawIndex = this.getRawIndex(idx);\n        var y = dimStore[rawIndex];\n\n        if (isNaN(y)) {\n          continue;\n        }\n\n        avgY += y;\n      }\n\n      avgY /= nextFrameEnd - nextFrameStart;\n      var frameStart = i;\n      var frameEnd = Math.min(i + frameSize, len);\n      var pointAX = i - 1;\n      var pointAY = dimStore[currentRawIndex];\n      maxArea = -1;\n      nextRawIndex = frameStart;\n      var firstNaNIndex = -1;\n      var countNaN = 0; // Find a point from current frame that construct a triangel with largest area with previous selected point\n      // And the average of next frame.\n\n      for (var idx = frameStart; idx < frameEnd; idx++) {\n        var rawIndex = this.getRawIndex(idx);\n        var y = dimStore[rawIndex];\n\n        if (isNaN(y)) {\n          countNaN++;\n\n          if (firstNaNIndex < 0) {\n            firstNaNIndex = rawIndex;\n          }\n\n          continue;\n        } // Calculate triangle area over three buckets\n\n\n        area = Math.abs((pointAX - avgX) * (y - pointAY) - (pointAX - idx) * (avgY - pointAY));\n\n        if (area > maxArea) {\n          maxArea = area;\n          nextRawIndex = rawIndex; // Next a is this b\n        }\n      }\n\n      if (countNaN > 0 && countNaN < frameEnd - frameStart) {\n        // Append first NaN point in every bucket.\n        // It is necessary to ensure the correct order of indices.\n        newIndices[sampledIndex++] = Math.min(firstNaNIndex, nextRawIndex);\n        nextRawIndex = Math.max(firstNaNIndex, nextRawIndex);\n      }\n\n      newIndices[sampledIndex++] = nextRawIndex;\n      currentRawIndex = nextRawIndex; // This a is the next a (chosen b)\n    } // First frame use the last data.\n\n\n    newIndices[sampledIndex++] = this.getRawIndex(len - 1);\n    target._count = sampledIndex;\n    target._indices = newIndices;\n    target.getRawIndex = this._getRawIdx;\n    return target;\n  };\n  /**\n   * Large data down sampling on given dimension\n   * @param sampleIndex Sample index for name and id\n   */\n\n\n  DataStore.prototype.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n    var target = this.clone([dimension], true);\n    var targetStorage = target._chunks;\n    var frameValues = [];\n    var frameSize = Math.floor(1 / rate);\n    var dimStore = targetStorage[dimension];\n    var len = this.count();\n    var rawExtentOnDim = target._rawExtent[dimension] = getInitialExtent();\n    var newIndices = new (getIndicesCtor(this._rawCount))(Math.ceil(len / frameSize));\n    var offset = 0;\n\n    for (var i = 0; i < len; i += frameSize) {\n      // Last frame\n      if (frameSize > len - i) {\n        frameSize = len - i;\n        frameValues.length = frameSize;\n      }\n\n      for (var k = 0; k < frameSize; k++) {\n        var dataIdx = this.getRawIndex(i + k);\n        frameValues[k] = dimStore[dataIdx];\n      }\n\n      var value = sampleValue(frameValues);\n      var sampleFrameIdx = this.getRawIndex(Math.min(i + sampleIndex(frameValues, value) || 0, len - 1)); // Only write value on the filtered data\n\n      dimStore[sampleFrameIdx] = value;\n\n      if (value < rawExtentOnDim[0]) {\n        rawExtentOnDim[0] = value;\n      }\n\n      if (value > rawExtentOnDim[1]) {\n        rawExtentOnDim[1] = value;\n      }\n\n      newIndices[offset++] = sampleFrameIdx;\n    }\n\n    target._count = offset;\n    target._indices = newIndices;\n\n    target._updateGetRawIdx();\n\n    return target;\n  };\n  /**\n   * Data iteration\n   * @param ctx default this\n   * @example\n   *  list.each('x', function (x, idx) {});\n   *  list.each(['x', 'y'], function (x, y, idx) {});\n   *  list.each(function (idx) {})\n   */\n\n\n  DataStore.prototype.each = function (dims, cb) {\n    if (!this._count) {\n      return;\n    }\n\n    var dimSize = dims.length;\n    var chunks = this._chunks;\n\n    for (var i = 0, len = this.count(); i < len; i++) {\n      var rawIdx = this.getRawIndex(i); // Simple optimization\n\n      switch (dimSize) {\n        case 0:\n          cb(i);\n          break;\n\n        case 1:\n          cb(chunks[dims[0]][rawIdx], i);\n          break;\n\n        case 2:\n          cb(chunks[dims[0]][rawIdx], chunks[dims[1]][rawIdx], i);\n          break;\n\n        default:\n          var k = 0;\n          var value = [];\n\n          for (; k < dimSize; k++) {\n            value[k] = chunks[dims[k]][rawIdx];\n          } // Index\n\n\n          value[k] = i;\n          cb.apply(null, value);\n      }\n    }\n  };\n  /**\n   * Get extent of data in one dimension\n   */\n\n\n  DataStore.prototype.getDataExtent = function (dim) {\n    // Make sure use concrete dim as cache name.\n    var dimData = this._chunks[dim];\n    var initialExtent = getInitialExtent();\n\n    if (!dimData) {\n      return initialExtent;\n    } // Make more strict checkings to ensure hitting cache.\n\n\n    var currEnd = this.count(); // Consider the most cases when using data zoom, `getDataExtent`\n    // happened before filtering. We cache raw extent, which is not\n    // necessary to be cleared and recalculated when restore data.\n\n    var useRaw = !this._indices;\n    var dimExtent;\n\n    if (useRaw) {\n      return this._rawExtent[dim].slice();\n    }\n\n    dimExtent = this._extent[dim];\n\n    if (dimExtent) {\n      return dimExtent.slice();\n    }\n\n    dimExtent = initialExtent;\n    var min = dimExtent[0];\n    var max = dimExtent[1];\n\n    for (var i = 0; i < currEnd; i++) {\n      var rawIdx = this.getRawIndex(i);\n      var value = dimData[rawIdx];\n      value < min && (min = value);\n      value > max && (max = value);\n    }\n\n    dimExtent = [min, max];\n    this._extent[dim] = dimExtent;\n    return dimExtent;\n  };\n  /**\n   * Get raw data item\n   */\n\n\n  DataStore.prototype.getRawDataItem = function (idx) {\n    var rawIdx = this.getRawIndex(idx);\n\n    if (!this._provider.persistent) {\n      var val = [];\n      var chunks = this._chunks;\n\n      for (var i = 0; i < chunks.length; i++) {\n        val.push(chunks[i][rawIdx]);\n      }\n\n      return val;\n    } else {\n      return this._provider.getItem(rawIdx);\n    }\n  };\n  /**\n   * Clone shallow.\n   *\n   * @param clonedDims Determine which dims to clone. Will share the data if not specified.\n   */\n\n\n  DataStore.prototype.clone = function (clonedDims, ignoreIndices) {\n    var target = new DataStore();\n    var chunks = this._chunks;\n    var clonedDimsMap = clonedDims && reduce(clonedDims, function (obj, dimIdx) {\n      obj[dimIdx] = true;\n      return obj;\n    }, {});\n\n    if (clonedDimsMap) {\n      for (var i = 0; i < chunks.length; i++) {\n        // Not clone if dim is not picked.\n        target._chunks[i] = !clonedDimsMap[i] ? chunks[i] : cloneChunk(chunks[i]);\n      }\n    } else {\n      target._chunks = chunks;\n    }\n\n    this._copyCommonProps(target);\n\n    if (!ignoreIndices) {\n      target._indices = this._cloneIndices();\n    }\n\n    target._updateGetRawIdx();\n\n    return target;\n  };\n\n  DataStore.prototype._copyCommonProps = function (target) {\n    target._count = this._count;\n    target._rawCount = this._rawCount;\n    target._provider = this._provider;\n    target._dimensions = this._dimensions;\n    target._extent = clone(this._extent);\n    target._rawExtent = clone(this._rawExtent);\n  };\n\n  DataStore.prototype._cloneIndices = function () {\n    if (this._indices) {\n      var Ctor = this._indices.constructor;\n      var indices = void 0;\n\n      if (Ctor === Array) {\n        var thisCount = this._indices.length;\n        indices = new Ctor(thisCount);\n\n        for (var i = 0; i < thisCount; i++) {\n          indices[i] = this._indices[i];\n        }\n      } else {\n        indices = new Ctor(this._indices);\n      }\n\n      return indices;\n    }\n\n    return null;\n  };\n\n  DataStore.prototype._getRawIdxIdentity = function (idx) {\n    return idx;\n  };\n\n  DataStore.prototype._getRawIdx = function (idx) {\n    if (idx < this._count && idx >= 0) {\n      return this._indices[idx];\n    }\n\n    return -1;\n  };\n\n  DataStore.prototype._updateGetRawIdx = function () {\n    this.getRawIndex = this._indices ? this._getRawIdx : this._getRawIdxIdentity;\n  };\n\n  DataStore.internalField = function () {\n    function getDimValueSimply(dataItem, property, dataIndex, dimIndex) {\n      return parseDataValue(dataItem[dimIndex], this._dimensions[dimIndex]);\n    }\n\n    defaultDimValueGetters = {\n      arrayRows: getDimValueSimply,\n      objectRows: function (dataItem, property, dataIndex, dimIndex) {\n        return parseDataValue(dataItem[property], this._dimensions[dimIndex]);\n      },\n      keyedColumns: getDimValueSimply,\n      original: function (dataItem, property, dataIndex, dimIndex) {\n        // Performance sensitive, do not use modelUtil.getDataItemValue.\n        // If dataItem is an plain object with no value field, the let `value`\n        // will be assigned with the object, but it will be tread correctly\n        // in the `convertValue`.\n        var value = dataItem && (dataItem.value == null ? dataItem : dataItem.value);\n        return parseDataValue(value instanceof Array ? value[dimIndex] // If value is a single number or something else not array.\n        : value, this._dimensions[dimIndex]);\n      },\n      typedArray: function (dataItem, property, dataIndex, dimIndex) {\n        return dataItem[dimIndex];\n      }\n    };\n  }();\n\n  return DataStore;\n}();\n\nexport default DataStore;"],"names":["defaultDimValueGetters","UNDEFINED","CtorUint32Array","Uint32Array","Array","CtorUint16Array","Uint16Array","CtorInt32Array","Int32Array","CtorFloat64Array","Float64Array","dataCtors","getIndicesCtor","rawCount","cloneChunk","originalChunk","Ctor","constructor","slice","prepareStore","store","dimIdx","dimType","end","append","DataCtor","oldStore","oldLen","length","newStore","j","DataStore","this","_chunks","_rawExtent","_extent","_count","_rawCount","_calcDimNameToIdx","createHashMap","prototype","initData","provider","inputDimensions","dimValueGetter","_provider","_indices","getRawIndex","_getRawIdxIdentity","source","getSource","defaultGetter","defaultDimValueGetter","sourceFormat","_dimValueGetter","shouldRetrieveDataByName","_dimensions","map","dim","type","property","_initDataFromProvider","count","getProvider","ensureCalculationDimension","dimName","calcDimNameToIdx","dimensions","calcDimIdx","get","set","Infinity","collectOrdinalMeta","ordinalMeta","chunk","rawExtents","offset","ordinalOffset","len","dimRawExtent","i","val","parseAndCollect","isNaN","Math","min","max","getOrdinalMeta","getDimensionProperty","dimIndex","item","appendData","data","start","persistent","appendValues","values","minFillLen","chunks","dimLen","rawExtent","emptyDataItem","idx","sourceIdx","arrayRows","call","dimNames","fillStorage","dataItem","getItem","dimStorage","clean","NaN","dimStore","getValues","dimArr","push","getByRawIndex","rawIdx","getSum","sum","value","getMedian","dimDataArray","each","sortedDimDataArray","sort","a","b","indexOfRawIndex","rawIndex","indices","rawDataIndex","left","right","mid","indicesOfNearest","maxDistance","dimData","nearestIndices","minDist","minDiff","nearestIndicesLen","diff","dist","abs","getIndices","newIndices","thisCount","buffer","filter","dims","cb","clone","dimSize","dim0","keep","k","apply","_updateGetRawIdx","selectRange","range","keys","originalCount","storeArr","quickFinished","dimStorage2","min2","max2","val2","dimk","target","_updateDims","modify","targetChunks","tmpRetValue","dataCount","dataIndex","retValue","rawExtentOnDim","lttbDownSample","valueDimension","rate","maxArea","area","nextRawIndex","sampledIndex","frameSize","floor","currentRawIndex","ceil","nextFrameStart","nextFrameEnd","avgX","avgY","y","frameStart","frameEnd","pointAX","pointAY","firstNaNIndex","countNaN","_getRawIdx","downSample","dimension","sampleValue","sampleIndex","targetStorage","frameValues","dataIdx","sampleFrameIdx","getDataExtent","initialExtent","dimExtent","currEnd","getRawDataItem","clonedDims","ignoreIndices","clonedDimsMap","reduce","obj","_copyCommonProps","_cloneIndices","internalField","getDimValueSimply","parseDataValue","objectRows","keyedColumns","original","typedArray"],"sourceRoot":""}
{"version":3,"file":"static/js/6791.a3ace281.js","mappings":"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","sources":["../node_modules/echarts/lib/component/helper/BrushController.js","../node_modules/echarts/lib/component/helper/BrushTargetManager.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\";\nimport { curry, each, map, bind, merge, clone, defaults, assert } from 'zrender/lib/core/util.js';\nimport Eventful from 'zrender/lib/core/Eventful.js';\nimport * as graphic from '../../util/graphic.js';\nimport * as interactionMutex from './interactionMutex.js';\nimport DataDiffer from '../../data/DataDiffer.js';\nvar BRUSH_PANEL_GLOBAL = true;\nvar mathMin = Math.min;\nvar mathMax = Math.max;\nvar mathPow = Math.pow;\nvar COVER_Z = 10000;\nvar UNSELECT_THRESHOLD = 6;\nvar MIN_RESIZE_LINE_WIDTH = 6;\nvar MUTEX_RESOURCE_KEY = 'globalPan';\nvar DIRECTION_MAP = {\n  w: [0, 0],\n  e: [0, 1],\n  n: [1, 0],\n  s: [1, 1]\n};\nvar CURSOR_MAP = {\n  w: 'ew',\n  e: 'ew',\n  n: 'ns',\n  s: 'ns',\n  ne: 'nesw',\n  sw: 'nesw',\n  nw: 'nwse',\n  se: 'nwse'\n};\nvar DEFAULT_BRUSH_OPT = {\n  brushStyle: {\n    lineWidth: 2,\n    stroke: 'rgba(210,219,238,0.3)',\n    fill: '#D2DBEE'\n  },\n  transformable: true,\n  brushMode: 'single',\n  removeOnClick: false\n};\nvar baseUID = 0;\n/**\n * params:\n *     areas: Array.<Array>, coord relates to container group,\n *                             If no container specified, to global.\n *     opt {\n *         isEnd: boolean,\n *         removeOnClick: boolean\n *     }\n */\n\nvar BrushController =\n/** @class */\nfunction (_super) {\n  __extends(BrushController, _super);\n\n  function BrushController(zr) {\n    var _this = _super.call(this) || this;\n    /**\n     * @internal\n     */\n\n\n    _this._track = [];\n    /**\n     * @internal\n     */\n\n    _this._covers = [];\n    _this._handlers = {};\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert(zr);\n    }\n\n    _this._zr = zr;\n    _this.group = new graphic.Group();\n    _this._uid = 'brushController_' + baseUID++;\n    each(pointerHandlers, function (handler, eventName) {\n      this._handlers[eventName] = bind(handler, this);\n    }, _this);\n    return _this;\n  }\n  /**\n   * If set to `false`, select disabled.\n   */\n\n\n  BrushController.prototype.enableBrush = function (brushOption) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(this._mounted);\n    }\n\n    this._brushType && this._doDisableBrush();\n    brushOption.brushType && this._doEnableBrush(brushOption);\n    return this;\n  };\n\n  BrushController.prototype._doEnableBrush = function (brushOption) {\n    var zr = this._zr; // Consider roam, which takes globalPan too.\n\n    if (!this._enableGlobalPan) {\n      interactionMutex.take(zr, MUTEX_RESOURCE_KEY, this._uid);\n    }\n\n    each(this._handlers, function (handler, eventName) {\n      zr.on(eventName, handler);\n    });\n    this._brushType = brushOption.brushType;\n    this._brushOption = merge(clone(DEFAULT_BRUSH_OPT), brushOption, true);\n  };\n\n  BrushController.prototype._doDisableBrush = function () {\n    var zr = this._zr;\n    interactionMutex.release(zr, MUTEX_RESOURCE_KEY, this._uid);\n    each(this._handlers, function (handler, eventName) {\n      zr.off(eventName, handler);\n    });\n    this._brushType = this._brushOption = null;\n  };\n  /**\n   * @param panelOpts If not pass, it is global brush.\n   */\n\n\n  BrushController.prototype.setPanels = function (panelOpts) {\n    if (panelOpts && panelOpts.length) {\n      var panels_1 = this._panels = {};\n      each(panelOpts, function (panelOpts) {\n        panels_1[panelOpts.panelId] = clone(panelOpts);\n      });\n    } else {\n      this._panels = null;\n    }\n\n    return this;\n  };\n\n  BrushController.prototype.mount = function (opt) {\n    opt = opt || {};\n\n    if (process.env.NODE_ENV !== 'production') {\n      this._mounted = true; // should be at first.\n    }\n\n    this._enableGlobalPan = opt.enableGlobalPan;\n    var thisGroup = this.group;\n\n    this._zr.add(thisGroup);\n\n    thisGroup.attr({\n      x: opt.x || 0,\n      y: opt.y || 0,\n      rotation: opt.rotation || 0,\n      scaleX: opt.scaleX || 1,\n      scaleY: opt.scaleY || 1\n    });\n    this._transform = thisGroup.getLocalTransform();\n    return this;\n  }; // eachCover(cb, context): void {\n  //     each(this._covers, cb, context);\n  // }\n\n  /**\n   * Update covers.\n   * @param coverConfigList\n   *        If coverConfigList is null/undefined, all covers removed.\n   */\n\n\n  BrushController.prototype.updateCovers = function (coverConfigList) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(this._mounted);\n    }\n\n    coverConfigList = map(coverConfigList, function (coverConfig) {\n      return merge(clone(DEFAULT_BRUSH_OPT), coverConfig, true);\n    });\n    var tmpIdPrefix = '\\0-brush-index-';\n    var oldCovers = this._covers;\n    var newCovers = this._covers = [];\n    var controller = this;\n    var creatingCover = this._creatingCover;\n    new DataDiffer(oldCovers, coverConfigList, oldGetKey, getKey).add(addOrUpdate).update(addOrUpdate).remove(remove).execute();\n    return this;\n\n    function getKey(brushOption, index) {\n      return (brushOption.id != null ? brushOption.id : tmpIdPrefix + index) + '-' + brushOption.brushType;\n    }\n\n    function oldGetKey(cover, index) {\n      return getKey(cover.__brushOption, index);\n    }\n\n    function addOrUpdate(newIndex, oldIndex) {\n      var newBrushInternal = coverConfigList[newIndex]; // Consider setOption in event listener of brushSelect,\n      // where updating cover when creating should be forbiden.\n\n      if (oldIndex != null && oldCovers[oldIndex] === creatingCover) {\n        newCovers[newIndex] = oldCovers[oldIndex];\n      } else {\n        var cover = newCovers[newIndex] = oldIndex != null ? (oldCovers[oldIndex].__brushOption = newBrushInternal, oldCovers[oldIndex]) : endCreating(controller, createCover(controller, newBrushInternal));\n        updateCoverAfterCreation(controller, cover);\n      }\n    }\n\n    function remove(oldIndex) {\n      if (oldCovers[oldIndex] !== creatingCover) {\n        controller.group.remove(oldCovers[oldIndex]);\n      }\n    }\n  };\n\n  BrushController.prototype.unmount = function () {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!this._mounted) {\n        return;\n      }\n    }\n\n    this.enableBrush(false); // container may 'removeAll' outside.\n\n    clearCovers(this);\n\n    this._zr.remove(this.group);\n\n    if (process.env.NODE_ENV !== 'production') {\n      this._mounted = false; // should be at last.\n    }\n\n    return this;\n  };\n\n  BrushController.prototype.dispose = function () {\n    this.unmount();\n    this.off();\n  };\n\n  return BrushController;\n}(Eventful);\n\nfunction createCover(controller, brushOption) {\n  var cover = coverRenderers[brushOption.brushType].createCover(controller, brushOption);\n  cover.__brushOption = brushOption;\n  updateZ(cover, brushOption);\n  controller.group.add(cover);\n  return cover;\n}\n\nfunction endCreating(controller, creatingCover) {\n  var coverRenderer = getCoverRenderer(creatingCover);\n\n  if (coverRenderer.endCreating) {\n    coverRenderer.endCreating(controller, creatingCover);\n    updateZ(creatingCover, creatingCover.__brushOption);\n  }\n\n  return creatingCover;\n}\n\nfunction updateCoverShape(controller, cover) {\n  var brushOption = cover.__brushOption;\n  getCoverRenderer(cover).updateCoverShape(controller, cover, brushOption.range, brushOption);\n}\n\nfunction updateZ(cover, brushOption) {\n  var z = brushOption.z;\n  z == null && (z = COVER_Z);\n  cover.traverse(function (el) {\n    el.z = z;\n    el.z2 = z; // Consider in given container.\n  });\n}\n\nfunction updateCoverAfterCreation(controller, cover) {\n  getCoverRenderer(cover).updateCommon(controller, cover);\n  updateCoverShape(controller, cover);\n}\n\nfunction getCoverRenderer(cover) {\n  return coverRenderers[cover.__brushOption.brushType];\n} // return target panel or `true` (means global panel)\n\n\nfunction getPanelByPoint(controller, e, localCursorPoint) {\n  var panels = controller._panels;\n\n  if (!panels) {\n    return BRUSH_PANEL_GLOBAL; // Global panel\n  }\n\n  var panel;\n  var transform = controller._transform;\n  each(panels, function (pn) {\n    pn.isTargetByCursor(e, localCursorPoint, transform) && (panel = pn);\n  });\n  return panel;\n} // Return a panel or true\n\n\nfunction getPanelByCover(controller, cover) {\n  var panels = controller._panels;\n\n  if (!panels) {\n    return BRUSH_PANEL_GLOBAL; // Global panel\n  }\n\n  var panelId = cover.__brushOption.panelId; // User may give cover without coord sys info,\n  // which is then treated as global panel.\n\n  return panelId != null ? panels[panelId] : BRUSH_PANEL_GLOBAL;\n}\n\nfunction clearCovers(controller) {\n  var covers = controller._covers;\n  var originalLength = covers.length;\n  each(covers, function (cover) {\n    controller.group.remove(cover);\n  }, controller);\n  covers.length = 0;\n  return !!originalLength;\n}\n\nfunction trigger(controller, opt) {\n  var areas = map(controller._covers, function (cover) {\n    var brushOption = cover.__brushOption;\n    var range = clone(brushOption.range);\n    return {\n      brushType: brushOption.brushType,\n      panelId: brushOption.panelId,\n      range: range\n    };\n  });\n  controller.trigger('brush', {\n    areas: areas,\n    isEnd: !!opt.isEnd,\n    removeOnClick: !!opt.removeOnClick\n  });\n}\n\nfunction shouldShowCover(controller) {\n  var track = controller._track;\n\n  if (!track.length) {\n    return false;\n  }\n\n  var p2 = track[track.length - 1];\n  var p1 = track[0];\n  var dx = p2[0] - p1[0];\n  var dy = p2[1] - p1[1];\n  var dist = mathPow(dx * dx + dy * dy, 0.5);\n  return dist > UNSELECT_THRESHOLD;\n}\n\nfunction getTrackEnds(track) {\n  var tail = track.length - 1;\n  tail < 0 && (tail = 0);\n  return [track[0], track[tail]];\n}\n\n;\n\nfunction createBaseRectCover(rectRangeConverter, controller, brushOption, edgeNameSequences) {\n  var cover = new graphic.Group();\n  cover.add(new graphic.Rect({\n    name: 'main',\n    style: makeStyle(brushOption),\n    silent: true,\n    draggable: true,\n    cursor: 'move',\n    drift: curry(driftRect, rectRangeConverter, controller, cover, ['n', 's', 'w', 'e']),\n    ondragend: curry(trigger, controller, {\n      isEnd: true\n    })\n  }));\n  each(edgeNameSequences, function (nameSequence) {\n    cover.add(new graphic.Rect({\n      name: nameSequence.join(''),\n      style: {\n        opacity: 0\n      },\n      draggable: true,\n      silent: true,\n      invisible: true,\n      drift: curry(driftRect, rectRangeConverter, controller, cover, nameSequence),\n      ondragend: curry(trigger, controller, {\n        isEnd: true\n      })\n    }));\n  });\n  return cover;\n}\n\nfunction updateBaseRect(controller, cover, localRange, brushOption) {\n  var lineWidth = brushOption.brushStyle.lineWidth || 0;\n  var handleSize = mathMax(lineWidth, MIN_RESIZE_LINE_WIDTH);\n  var x = localRange[0][0];\n  var y = localRange[1][0];\n  var xa = x - lineWidth / 2;\n  var ya = y - lineWidth / 2;\n  var x2 = localRange[0][1];\n  var y2 = localRange[1][1];\n  var x2a = x2 - handleSize + lineWidth / 2;\n  var y2a = y2 - handleSize + lineWidth / 2;\n  var width = x2 - x;\n  var height = y2 - y;\n  var widtha = width + lineWidth;\n  var heighta = height + lineWidth;\n  updateRectShape(controller, cover, 'main', x, y, width, height);\n\n  if (brushOption.transformable) {\n    updateRectShape(controller, cover, 'w', xa, ya, handleSize, heighta);\n    updateRectShape(controller, cover, 'e', x2a, ya, handleSize, heighta);\n    updateRectShape(controller, cover, 'n', xa, ya, widtha, handleSize);\n    updateRectShape(controller, cover, 's', xa, y2a, widtha, handleSize);\n    updateRectShape(controller, cover, 'nw', xa, ya, handleSize, handleSize);\n    updateRectShape(controller, cover, 'ne', x2a, ya, handleSize, handleSize);\n    updateRectShape(controller, cover, 'sw', xa, y2a, handleSize, handleSize);\n    updateRectShape(controller, cover, 'se', x2a, y2a, handleSize, handleSize);\n  }\n}\n\nfunction updateCommon(controller, cover) {\n  var brushOption = cover.__brushOption;\n  var transformable = brushOption.transformable;\n  var mainEl = cover.childAt(0);\n  mainEl.useStyle(makeStyle(brushOption));\n  mainEl.attr({\n    silent: !transformable,\n    cursor: transformable ? 'move' : 'default'\n  });\n  each([['w'], ['e'], ['n'], ['s'], ['s', 'e'], ['s', 'w'], ['n', 'e'], ['n', 'w']], function (nameSequence) {\n    var el = cover.childOfName(nameSequence.join(''));\n    var globalDir = nameSequence.length === 1 ? getGlobalDirection1(controller, nameSequence[0]) : getGlobalDirection2(controller, nameSequence);\n    el && el.attr({\n      silent: !transformable,\n      invisible: !transformable,\n      cursor: transformable ? CURSOR_MAP[globalDir] + '-resize' : null\n    });\n  });\n}\n\nfunction updateRectShape(controller, cover, name, x, y, w, h) {\n  var el = cover.childOfName(name);\n  el && el.setShape(pointsToRect(clipByPanel(controller, cover, [[x, y], [x + w, y + h]])));\n}\n\nfunction makeStyle(brushOption) {\n  return defaults({\n    strokeNoScale: true\n  }, brushOption.brushStyle);\n}\n\nfunction formatRectRange(x, y, x2, y2) {\n  var min = [mathMin(x, x2), mathMin(y, y2)];\n  var max = [mathMax(x, x2), mathMax(y, y2)];\n  return [[min[0], max[0]], [min[1], max[1]] // y range\n  ];\n}\n\nfunction getTransform(controller) {\n  return graphic.getTransform(controller.group);\n}\n\nfunction getGlobalDirection1(controller, localDirName) {\n  var map = {\n    w: 'left',\n    e: 'right',\n    n: 'top',\n    s: 'bottom'\n  };\n  var inverseMap = {\n    left: 'w',\n    right: 'e',\n    top: 'n',\n    bottom: 's'\n  };\n  var dir = graphic.transformDirection(map[localDirName], getTransform(controller));\n  return inverseMap[dir];\n}\n\nfunction getGlobalDirection2(controller, localDirNameSeq) {\n  var globalDir = [getGlobalDirection1(controller, localDirNameSeq[0]), getGlobalDirection1(controller, localDirNameSeq[1])];\n  (globalDir[0] === 'e' || globalDir[0] === 'w') && globalDir.reverse();\n  return globalDir.join('');\n}\n\nfunction driftRect(rectRangeConverter, controller, cover, dirNameSequence, dx, dy) {\n  var brushOption = cover.__brushOption;\n  var rectRange = rectRangeConverter.toRectRange(brushOption.range);\n  var localDelta = toLocalDelta(controller, dx, dy);\n  each(dirNameSequence, function (dirName) {\n    var ind = DIRECTION_MAP[dirName];\n    rectRange[ind[0]][ind[1]] += localDelta[ind[0]];\n  });\n  brushOption.range = rectRangeConverter.fromRectRange(formatRectRange(rectRange[0][0], rectRange[1][0], rectRange[0][1], rectRange[1][1]));\n  updateCoverAfterCreation(controller, cover);\n  trigger(controller, {\n    isEnd: false\n  });\n}\n\nfunction driftPolygon(controller, cover, dx, dy) {\n  var range = cover.__brushOption.range;\n  var localDelta = toLocalDelta(controller, dx, dy);\n  each(range, function (point) {\n    point[0] += localDelta[0];\n    point[1] += localDelta[1];\n  });\n  updateCoverAfterCreation(controller, cover);\n  trigger(controller, {\n    isEnd: false\n  });\n}\n\nfunction toLocalDelta(controller, dx, dy) {\n  var thisGroup = controller.group;\n  var localD = thisGroup.transformCoordToLocal(dx, dy);\n  var localZero = thisGroup.transformCoordToLocal(0, 0);\n  return [localD[0] - localZero[0], localD[1] - localZero[1]];\n}\n\nfunction clipByPanel(controller, cover, data) {\n  var panel = getPanelByCover(controller, cover);\n  return panel && panel !== BRUSH_PANEL_GLOBAL ? panel.clipPath(data, controller._transform) : clone(data);\n}\n\nfunction pointsToRect(points) {\n  var xmin = mathMin(points[0][0], points[1][0]);\n  var ymin = mathMin(points[0][1], points[1][1]);\n  var xmax = mathMax(points[0][0], points[1][0]);\n  var ymax = mathMax(points[0][1], points[1][1]);\n  return {\n    x: xmin,\n    y: ymin,\n    width: xmax - xmin,\n    height: ymax - ymin\n  };\n}\n\nfunction resetCursor(controller, e, localCursorPoint) {\n  if ( // Check active\n  !controller._brushType // resetCursor should be always called when mouse is in zr area,\n  // but not called when mouse is out of zr area to avoid bad influence\n  // if `mousemove`, `mouseup` are triggered from `document` event.\n  || isOutsideZrArea(controller, e.offsetX, e.offsetY)) {\n    return;\n  }\n\n  var zr = controller._zr;\n  var covers = controller._covers;\n  var currPanel = getPanelByPoint(controller, e, localCursorPoint); // Check whether in covers.\n\n  if (!controller._dragging) {\n    for (var i = 0; i < covers.length; i++) {\n      var brushOption = covers[i].__brushOption;\n\n      if (currPanel && (currPanel === BRUSH_PANEL_GLOBAL || brushOption.panelId === currPanel.panelId) && coverRenderers[brushOption.brushType].contain(covers[i], localCursorPoint[0], localCursorPoint[1])) {\n        // Use cursor style set on cover.\n        return;\n      }\n    }\n  }\n\n  currPanel && zr.setCursorStyle('crosshair');\n}\n\nfunction preventDefault(e) {\n  var rawE = e.event;\n  rawE.preventDefault && rawE.preventDefault();\n}\n\nfunction mainShapeContain(cover, x, y) {\n  return cover.childOfName('main').contain(x, y);\n}\n\nfunction updateCoverByMouse(controller, e, localCursorPoint, isEnd) {\n  var creatingCover = controller._creatingCover;\n  var panel = controller._creatingPanel;\n  var thisBrushOption = controller._brushOption;\n  var eventParams;\n\n  controller._track.push(localCursorPoint.slice());\n\n  if (shouldShowCover(controller) || creatingCover) {\n    if (panel && !creatingCover) {\n      thisBrushOption.brushMode === 'single' && clearCovers(controller);\n      var brushOption = clone(thisBrushOption);\n      brushOption.brushType = determineBrushType(brushOption.brushType, panel);\n      brushOption.panelId = panel === BRUSH_PANEL_GLOBAL ? null : panel.panelId;\n      creatingCover = controller._creatingCover = createCover(controller, brushOption);\n\n      controller._covers.push(creatingCover);\n    }\n\n    if (creatingCover) {\n      var coverRenderer = coverRenderers[determineBrushType(controller._brushType, panel)];\n      var coverBrushOption = creatingCover.__brushOption;\n      coverBrushOption.range = coverRenderer.getCreatingRange(clipByPanel(controller, creatingCover, controller._track));\n\n      if (isEnd) {\n        endCreating(controller, creatingCover);\n        coverRenderer.updateCommon(controller, creatingCover);\n      }\n\n      updateCoverShape(controller, creatingCover);\n      eventParams = {\n        isEnd: isEnd\n      };\n    }\n  } else if (isEnd && thisBrushOption.brushMode === 'single' && thisBrushOption.removeOnClick) {\n    // Help user to remove covers easily, only by a tiny drag, in 'single' mode.\n    // But a single click do not clear covers, because user may have casual\n    // clicks (for example, click on other component and do not expect covers\n    // disappear).\n    // Only some cover removed, trigger action, but not every click trigger action.\n    if (getPanelByPoint(controller, e, localCursorPoint) && clearCovers(controller)) {\n      eventParams = {\n        isEnd: isEnd,\n        removeOnClick: true\n      };\n    }\n  }\n\n  return eventParams;\n}\n\nfunction determineBrushType(brushType, panel) {\n  if (brushType === 'auto') {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(panel && panel.defaultBrushType, 'MUST have defaultBrushType when brushType is \"atuo\"');\n    }\n\n    return panel.defaultBrushType;\n  }\n\n  return brushType;\n}\n\nvar pointerHandlers = {\n  mousedown: function (e) {\n    if (this._dragging) {\n      // In case some browser do not support globalOut,\n      // and release mouse out side the browser.\n      handleDragEnd(this, e);\n    } else if (!e.target || !e.target.draggable) {\n      preventDefault(e);\n      var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY);\n      this._creatingCover = null;\n      var panel = this._creatingPanel = getPanelByPoint(this, e, localCursorPoint);\n\n      if (panel) {\n        this._dragging = true;\n        this._track = [localCursorPoint.slice()];\n      }\n    }\n  },\n  mousemove: function (e) {\n    var x = e.offsetX;\n    var y = e.offsetY;\n    var localCursorPoint = this.group.transformCoordToLocal(x, y);\n    resetCursor(this, e, localCursorPoint);\n\n    if (this._dragging) {\n      preventDefault(e);\n      var eventParams = updateCoverByMouse(this, e, localCursorPoint, false);\n      eventParams && trigger(this, eventParams);\n    }\n  },\n  mouseup: function (e) {\n    handleDragEnd(this, e);\n  }\n};\n\nfunction handleDragEnd(controller, e) {\n  if (controller._dragging) {\n    preventDefault(e);\n    var x = e.offsetX;\n    var y = e.offsetY;\n    var localCursorPoint = controller.group.transformCoordToLocal(x, y);\n    var eventParams = updateCoverByMouse(controller, e, localCursorPoint, true);\n    controller._dragging = false;\n    controller._track = [];\n    controller._creatingCover = null; // trigger event shoule be at final, after procedure will be nested.\n\n    eventParams && trigger(controller, eventParams);\n  }\n}\n\nfunction isOutsideZrArea(controller, x, y) {\n  var zr = controller._zr;\n  return x < 0 || x > zr.getWidth() || y < 0 || y > zr.getHeight();\n}\n/**\n * key: brushType\n */\n\n\nvar coverRenderers = {\n  lineX: getLineRenderer(0),\n  lineY: getLineRenderer(1),\n  rect: {\n    createCover: function (controller, brushOption) {\n      function returnInput(range) {\n        return range;\n      }\n\n      return createBaseRectCover({\n        toRectRange: returnInput,\n        fromRectRange: returnInput\n      }, controller, brushOption, [['w'], ['e'], ['n'], ['s'], ['s', 'e'], ['s', 'w'], ['n', 'e'], ['n', 'w']]);\n    },\n    getCreatingRange: function (localTrack) {\n      var ends = getTrackEnds(localTrack);\n      return formatRectRange(ends[1][0], ends[1][1], ends[0][0], ends[0][1]);\n    },\n    updateCoverShape: function (controller, cover, localRange, brushOption) {\n      updateBaseRect(controller, cover, localRange, brushOption);\n    },\n    updateCommon: updateCommon,\n    contain: mainShapeContain\n  },\n  polygon: {\n    createCover: function (controller, brushOption) {\n      var cover = new graphic.Group(); // Do not use graphic.Polygon because graphic.Polyline do not close the\n      // border of the shape when drawing, which is a better experience for user.\n\n      cover.add(new graphic.Polyline({\n        name: 'main',\n        style: makeStyle(brushOption),\n        silent: true\n      }));\n      return cover;\n    },\n    getCreatingRange: function (localTrack) {\n      return localTrack;\n    },\n    endCreating: function (controller, cover) {\n      cover.remove(cover.childAt(0)); // Use graphic.Polygon close the shape.\n\n      cover.add(new graphic.Polygon({\n        name: 'main',\n        draggable: true,\n        drift: curry(driftPolygon, controller, cover),\n        ondragend: curry(trigger, controller, {\n          isEnd: true\n        })\n      }));\n    },\n    updateCoverShape: function (controller, cover, localRange, brushOption) {\n      cover.childAt(0).setShape({\n        points: clipByPanel(controller, cover, localRange)\n      });\n    },\n    updateCommon: updateCommon,\n    contain: mainShapeContain\n  }\n};\n\nfunction getLineRenderer(xyIndex) {\n  return {\n    createCover: function (controller, brushOption) {\n      return createBaseRectCover({\n        toRectRange: function (range) {\n          var rectRange = [range, [0, 100]];\n          xyIndex && rectRange.reverse();\n          return rectRange;\n        },\n        fromRectRange: function (rectRange) {\n          return rectRange[xyIndex];\n        }\n      }, controller, brushOption, [[['w'], ['e']], [['n'], ['s']]][xyIndex]);\n    },\n    getCreatingRange: function (localTrack) {\n      var ends = getTrackEnds(localTrack);\n      var min = mathMin(ends[0][xyIndex], ends[1][xyIndex]);\n      var max = mathMax(ends[0][xyIndex], ends[1][xyIndex]);\n      return [min, max];\n    },\n    updateCoverShape: function (controller, cover, localRange, brushOption) {\n      var otherExtent; // If brushWidth not specified, fit the panel.\n\n      var panel = getPanelByCover(controller, cover);\n\n      if (panel !== BRUSH_PANEL_GLOBAL && panel.getLinearBrushOtherExtent) {\n        otherExtent = panel.getLinearBrushOtherExtent(xyIndex);\n      } else {\n        var zr = controller._zr;\n        otherExtent = [0, [zr.getWidth(), zr.getHeight()][1 - xyIndex]];\n      }\n\n      var rectRange = [localRange, otherExtent];\n      xyIndex && rectRange.reverse();\n      updateBaseRect(controller, cover, rectRange, brushOption);\n    },\n    updateCommon: updateCommon,\n    contain: mainShapeContain\n  };\n}\n\nexport default BrushController;","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { each, indexOf, curry, assert, map, createHashMap } from 'zrender/lib/core/util.js';\nimport * as graphic from '../../util/graphic.js';\nimport * as brushHelper from './brushHelper.js';\nimport { parseFinder as modelUtilParseFinder } from '../../util/model.js'; // FIXME\n// how to genarialize to more coordinate systems.\n\nvar INCLUDE_FINDER_MAIN_TYPES = ['grid', 'xAxis', 'yAxis', 'geo', 'graph', 'polar', 'radiusAxis', 'angleAxis', 'bmap'];\n\nvar BrushTargetManager =\n/** @class */\nfunction () {\n  /**\n   * @param finder contains Index/Id/Name of xAxis/yAxis/geo/grid\n   *        Each can be {number|Array.<number>}. like: {xAxisIndex: [3, 4]}\n   * @param opt.include include coordinate system types.\n   */\n  function BrushTargetManager(finder, ecModel, opt) {\n    var _this = this;\n\n    this._targetInfoList = [];\n    var foundCpts = parseFinder(ecModel, finder);\n    each(targetInfoBuilders, function (builder, type) {\n      if (!opt || !opt.include || indexOf(opt.include, type) >= 0) {\n        builder(foundCpts, _this._targetInfoList);\n      }\n    });\n  }\n\n  BrushTargetManager.prototype.setOutputRanges = function (areas, ecModel) {\n    this.matchOutputRanges(areas, ecModel, function (area, coordRange, coordSys) {\n      (area.coordRanges || (area.coordRanges = [])).push(coordRange); // area.coordRange is the first of area.coordRanges\n\n      if (!area.coordRange) {\n        area.coordRange = coordRange; // In 'category' axis, coord to pixel is not reversible, so we can not\n        // rebuild range by coordRange accrately, which may bring trouble when\n        // brushing only one item. So we use __rangeOffset to rebuilding range\n        // by coordRange. And this it only used in brush component so it is no\n        // need to be adapted to coordRanges.\n\n        var result = coordConvert[area.brushType](0, coordSys, coordRange);\n        area.__rangeOffset = {\n          offset: diffProcessor[area.brushType](result.values, area.range, [1, 1]),\n          xyMinMax: result.xyMinMax\n        };\n      }\n    });\n    return areas;\n  };\n\n  BrushTargetManager.prototype.matchOutputRanges = function (areas, ecModel, cb) {\n    each(areas, function (area) {\n      var targetInfo = this.findTargetInfo(area, ecModel);\n\n      if (targetInfo && targetInfo !== true) {\n        each(targetInfo.coordSyses, function (coordSys) {\n          var result = coordConvert[area.brushType](1, coordSys, area.range, true);\n          cb(area, result.values, coordSys, ecModel);\n        });\n      }\n    }, this);\n  };\n  /**\n   * the `areas` is `BrushModel.areas`.\n   * Called in layout stage.\n   * convert `area.coordRange` to global range and set panelId to `area.range`.\n   */\n\n\n  BrushTargetManager.prototype.setInputRanges = function (areas, ecModel) {\n    each(areas, function (area) {\n      var targetInfo = this.findTargetInfo(area, ecModel);\n\n      if (process.env.NODE_ENV !== 'production') {\n        assert(!targetInfo || targetInfo === true || area.coordRange, 'coordRange must be specified when coord index specified.');\n        assert(!targetInfo || targetInfo !== true || area.range, 'range must be specified in global brush.');\n      }\n\n      area.range = area.range || []; // convert coordRange to global range and set panelId.\n\n      if (targetInfo && targetInfo !== true) {\n        area.panelId = targetInfo.panelId; // (1) area.range shoule always be calculate from coordRange but does\n        // not keep its original value, for the sake of the dataZoom scenario,\n        // where area.coordRange remains unchanged but area.range may be changed.\n        // (2) Only support converting one coordRange to pixel range in brush\n        // component. So do not consider `coordRanges`.\n        // (3) About __rangeOffset, see comment above.\n\n        var result = coordConvert[area.brushType](0, targetInfo.coordSys, area.coordRange);\n        var rangeOffset = area.__rangeOffset;\n        area.range = rangeOffset ? diffProcessor[area.brushType](result.values, rangeOffset.offset, getScales(result.xyMinMax, rangeOffset.xyMinMax)) : result.values;\n      }\n    }, this);\n  };\n\n  BrushTargetManager.prototype.makePanelOpts = function (api, getDefaultBrushType) {\n    return map(this._targetInfoList, function (targetInfo) {\n      var rect = targetInfo.getPanelRect();\n      return {\n        panelId: targetInfo.panelId,\n        defaultBrushType: getDefaultBrushType ? getDefaultBrushType(targetInfo) : null,\n        clipPath: brushHelper.makeRectPanelClipPath(rect),\n        isTargetByCursor: brushHelper.makeRectIsTargetByCursor(rect, api, targetInfo.coordSysModel),\n        getLinearBrushOtherExtent: brushHelper.makeLinearBrushOtherExtent(rect)\n      };\n    });\n  };\n\n  BrushTargetManager.prototype.controlSeries = function (area, seriesModel, ecModel) {\n    // Check whether area is bound in coord, and series do not belong to that coord.\n    // If do not do this check, some brush (like lineX) will controll all axes.\n    var targetInfo = this.findTargetInfo(area, ecModel);\n    return targetInfo === true || targetInfo && indexOf(targetInfo.coordSyses, seriesModel.coordinateSystem) >= 0;\n  };\n  /**\n   * If return Object, a coord found.\n   * If reutrn true, global found.\n   * Otherwise nothing found.\n   */\n\n\n  BrushTargetManager.prototype.findTargetInfo = function (area, ecModel) {\n    var targetInfoList = this._targetInfoList;\n    var foundCpts = parseFinder(ecModel, area);\n\n    for (var i = 0; i < targetInfoList.length; i++) {\n      var targetInfo = targetInfoList[i];\n      var areaPanelId = area.panelId;\n\n      if (areaPanelId) {\n        if (targetInfo.panelId === areaPanelId) {\n          return targetInfo;\n        }\n      } else {\n        for (var j = 0; j < targetInfoMatchers.length; j++) {\n          if (targetInfoMatchers[j](foundCpts, targetInfo)) {\n            return targetInfo;\n          }\n        }\n      }\n    }\n\n    return true;\n  };\n\n  return BrushTargetManager;\n}();\n\nfunction formatMinMax(minMax) {\n  minMax[0] > minMax[1] && minMax.reverse();\n  return minMax;\n}\n\nfunction parseFinder(ecModel, finder) {\n  return modelUtilParseFinder(ecModel, finder, {\n    includeMainTypes: INCLUDE_FINDER_MAIN_TYPES\n  });\n}\n\nvar targetInfoBuilders = {\n  grid: function (foundCpts, targetInfoList) {\n    var xAxisModels = foundCpts.xAxisModels;\n    var yAxisModels = foundCpts.yAxisModels;\n    var gridModels = foundCpts.gridModels; // Remove duplicated.\n\n    var gridModelMap = createHashMap();\n    var xAxesHas = {};\n    var yAxesHas = {};\n\n    if (!xAxisModels && !yAxisModels && !gridModels) {\n      return;\n    }\n\n    each(xAxisModels, function (axisModel) {\n      var gridModel = axisModel.axis.grid.model;\n      gridModelMap.set(gridModel.id, gridModel);\n      xAxesHas[gridModel.id] = true;\n    });\n    each(yAxisModels, function (axisModel) {\n      var gridModel = axisModel.axis.grid.model;\n      gridModelMap.set(gridModel.id, gridModel);\n      yAxesHas[gridModel.id] = true;\n    });\n    each(gridModels, function (gridModel) {\n      gridModelMap.set(gridModel.id, gridModel);\n      xAxesHas[gridModel.id] = true;\n      yAxesHas[gridModel.id] = true;\n    });\n    gridModelMap.each(function (gridModel) {\n      var grid = gridModel.coordinateSystem;\n      var cartesians = [];\n      each(grid.getCartesians(), function (cartesian, index) {\n        if (indexOf(xAxisModels, cartesian.getAxis('x').model) >= 0 || indexOf(yAxisModels, cartesian.getAxis('y').model) >= 0) {\n          cartesians.push(cartesian);\n        }\n      });\n      targetInfoList.push({\n        panelId: 'grid--' + gridModel.id,\n        gridModel: gridModel,\n        coordSysModel: gridModel,\n        // Use the first one as the representitive coordSys.\n        coordSys: cartesians[0],\n        coordSyses: cartesians,\n        getPanelRect: panelRectBuilders.grid,\n        xAxisDeclared: xAxesHas[gridModel.id],\n        yAxisDeclared: yAxesHas[gridModel.id]\n      });\n    });\n  },\n  geo: function (foundCpts, targetInfoList) {\n    each(foundCpts.geoModels, function (geoModel) {\n      var coordSys = geoModel.coordinateSystem;\n      targetInfoList.push({\n        panelId: 'geo--' + geoModel.id,\n        geoModel: geoModel,\n        coordSysModel: geoModel,\n        coordSys: coordSys,\n        coordSyses: [coordSys],\n        getPanelRect: panelRectBuilders.geo\n      });\n    });\n  }\n};\nvar targetInfoMatchers = [// grid\nfunction (foundCpts, targetInfo) {\n  var xAxisModel = foundCpts.xAxisModel;\n  var yAxisModel = foundCpts.yAxisModel;\n  var gridModel = foundCpts.gridModel;\n  !gridModel && xAxisModel && (gridModel = xAxisModel.axis.grid.model);\n  !gridModel && yAxisModel && (gridModel = yAxisModel.axis.grid.model);\n  return gridModel && gridModel === targetInfo.gridModel;\n}, // geo\nfunction (foundCpts, targetInfo) {\n  var geoModel = foundCpts.geoModel;\n  return geoModel && geoModel === targetInfo.geoModel;\n}];\nvar panelRectBuilders = {\n  grid: function () {\n    // grid is not Transformable.\n    return this.coordSys.master.getRect().clone();\n  },\n  geo: function () {\n    var coordSys = this.coordSys;\n    var rect = coordSys.getBoundingRect().clone(); // geo roam and zoom transform\n\n    rect.applyTransform(graphic.getTransform(coordSys));\n    return rect;\n  }\n};\nvar coordConvert = {\n  lineX: curry(axisConvert, 0),\n  lineY: curry(axisConvert, 1),\n  rect: function (to, coordSys, rangeOrCoordRange, clamp) {\n    var xminymin = to ? coordSys.pointToData([rangeOrCoordRange[0][0], rangeOrCoordRange[1][0]], clamp) : coordSys.dataToPoint([rangeOrCoordRange[0][0], rangeOrCoordRange[1][0]], clamp);\n    var xmaxymax = to ? coordSys.pointToData([rangeOrCoordRange[0][1], rangeOrCoordRange[1][1]], clamp) : coordSys.dataToPoint([rangeOrCoordRange[0][1], rangeOrCoordRange[1][1]], clamp);\n    var values = [formatMinMax([xminymin[0], xmaxymax[0]]), formatMinMax([xminymin[1], xmaxymax[1]])];\n    return {\n      values: values,\n      xyMinMax: values\n    };\n  },\n  polygon: function (to, coordSys, rangeOrCoordRange, clamp) {\n    var xyMinMax = [[Infinity, -Infinity], [Infinity, -Infinity]];\n    var values = map(rangeOrCoordRange, function (item) {\n      var p = to ? coordSys.pointToData(item, clamp) : coordSys.dataToPoint(item, clamp);\n      xyMinMax[0][0] = Math.min(xyMinMax[0][0], p[0]);\n      xyMinMax[1][0] = Math.min(xyMinMax[1][0], p[1]);\n      xyMinMax[0][1] = Math.max(xyMinMax[0][1], p[0]);\n      xyMinMax[1][1] = Math.max(xyMinMax[1][1], p[1]);\n      return p;\n    });\n    return {\n      values: values,\n      xyMinMax: xyMinMax\n    };\n  }\n};\n\nfunction axisConvert(axisNameIndex, to, coordSys, rangeOrCoordRange) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert(coordSys.type === 'cartesian2d', 'lineX/lineY brush is available only in cartesian2d.');\n  }\n\n  var axis = coordSys.getAxis(['x', 'y'][axisNameIndex]);\n  var values = formatMinMax(map([0, 1], function (i) {\n    return to ? axis.coordToData(axis.toLocalCoord(rangeOrCoordRange[i]), true) : axis.toGlobalCoord(axis.dataToCoord(rangeOrCoordRange[i]));\n  }));\n  var xyMinMax = [];\n  xyMinMax[axisNameIndex] = values;\n  xyMinMax[1 - axisNameIndex] = [NaN, NaN];\n  return {\n    values: values,\n    xyMinMax: xyMinMax\n  };\n}\n\nvar diffProcessor = {\n  lineX: curry(axisDiffProcessor, 0),\n  lineY: curry(axisDiffProcessor, 1),\n  rect: function (values, refer, scales) {\n    return [[values[0][0] - scales[0] * refer[0][0], values[0][1] - scales[0] * refer[0][1]], [values[1][0] - scales[1] * refer[1][0], values[1][1] - scales[1] * refer[1][1]]];\n  },\n  polygon: function (values, refer, scales) {\n    return map(values, function (item, idx) {\n      return [item[0] - scales[0] * refer[idx][0], item[1] - scales[1] * refer[idx][1]];\n    });\n  }\n};\n\nfunction axisDiffProcessor(axisNameIndex, values, refer, scales) {\n  return [values[0] - scales[axisNameIndex] * refer[0], values[1] - scales[axisNameIndex] * refer[1]];\n} // We have to process scale caused by dataZoom manually,\n// although it might be not accurate.\n// Return [0~1, 0~1]\n\n\nfunction getScales(xyMinMaxCurr, xyMinMaxOrigin) {\n  var sizeCurr = getSize(xyMinMaxCurr);\n  var sizeOrigin = getSize(xyMinMaxOrigin);\n  var scales = [sizeCurr[0] / sizeOrigin[0], sizeCurr[1] / sizeOrigin[1]];\n  isNaN(scales[0]) && (scales[0] = 1);\n  isNaN(scales[1]) && (scales[1] = 1);\n  return scales;\n}\n\nfunction getSize(xyMinMax) {\n  return xyMinMax ? [xyMinMax[0][1] - xyMinMax[0][0], xyMinMax[1][1] - xyMinMax[1][0]] : [NaN, NaN];\n}\n\nexport default BrushTargetManager;"],"names":["BRUSH_PANEL_GLOBAL","mathMin","Math","min","mathMax","max","mathPow","pow","MUTEX_RESOURCE_KEY","DIRECTION_MAP","w","e","n","s","CURSOR_MAP","ne","sw","nw","se","DEFAULT_BRUSH_OPT","brushStyle","lineWidth","stroke","fill","transformable","brushMode","removeOnClick","baseUID","BrushController","_super","zr","_this","call","this","_track","_covers","_handlers","_zr","group","graphic","_uid","each","pointerHandlers","handler","eventName","bind","__extends","prototype","enableBrush","brushOption","_brushType","_doDisableBrush","brushType","_doEnableBrush","_enableGlobalPan","interactionMutex","on","_brushOption","merge","clone","off","setPanels","panelOpts","length","panels_1","_panels","panelId","mount","opt","enableGlobalPan","thisGroup","add","attr","x","y","rotation","scaleX","scaleY","_transform","getLocalTransform","updateCovers","coverConfigList","map","coverConfig","oldCovers","newCovers","controller","creatingCover","_creatingCover","DataDiffer","cover","index","getKey","__brushOption","addOrUpdate","update","remove","oldIndex","execute","id","newIndex","newBrushInternal","endCreating","createCover","updateCoverAfterCreation","unmount","clearCovers","dispose","Eventful","coverRenderers","updateZ","coverRenderer","getCoverRenderer","updateCoverShape","range","z","traverse","el","z2","updateCommon","getPanelByPoint","localCursorPoint","panel","panels","transform","pn","isTargetByCursor","getPanelByCover","covers","originalLength","trigger","areas","isEnd","getTrackEnds","track","tail","createBaseRectCover","rectRangeConverter","edgeNameSequences","name","style","makeStyle","silent","draggable","cursor","drift","curry","driftRect","ondragend","nameSequence","join","opacity","invisible","updateBaseRect","localRange","handleSize","xa","ya","x2","y2","x2a","y2a","width","height","widtha","heighta","updateRectShape","mainEl","childAt","useStyle","childOfName","globalDir","getGlobalDirection1","localDirNameSeq","reverse","getGlobalDirection2","h","setShape","points","xmin","ymin","xmax","ymax","pointsToRect","clipByPanel","defaults","strokeNoScale","formatRectRange","localDirName","dir","getTransform","left","right","top","bottom","dirNameSequence","dx","dy","rectRange","toRectRange","localDelta","toLocalDelta","dirName","ind","fromRectRange","driftPolygon","point","localD","transformCoordToLocal","localZero","data","clipPath","preventDefault","rawE","event","mainShapeContain","contain","updateCoverByMouse","eventParams","_creatingPanel","thisBrushOption","push","slice","p2","p1","shouldShowCover","determineBrushType","getCreatingRange","defaultBrushType","mousedown","_dragging","handleDragEnd","target","offsetX","offsetY","mousemove","getWidth","getHeight","isOutsideZrArea","currPanel","i","setCursorStyle","resetCursor","mouseup","lineX","getLineRenderer","lineY","rect","returnInput","localTrack","ends","polygon","xyIndex","otherExtent","getLinearBrushOtherExtent","INCLUDE_FINDER_MAIN_TYPES","BrushTargetManager","finder","ecModel","_targetInfoList","foundCpts","parseFinder","targetInfoBuilders","builder","type","include","indexOf","setOutputRanges","matchOutputRanges","area","coordRange","coordSys","coordRanges","result","coordConvert","__rangeOffset","offset","diffProcessor","values","xyMinMax","cb","targetInfo","findTargetInfo","coordSyses","setInputRanges","rangeOffset","xyMinMaxCurr","xyMinMaxOrigin","sizeCurr","getSize","sizeOrigin","scales","isNaN","getScales","makePanelOpts","api","getDefaultBrushType","getPanelRect","brushHelper","coordSysModel","controlSeries","seriesModel","coordinateSystem","targetInfoList","areaPanelId","j","targetInfoMatchers","formatMinMax","minMax","modelUtilParseFinder","includeMainTypes","grid","xAxisModels","yAxisModels","gridModels","gridModelMap","createHashMap","xAxesHas","yAxesHas","axisModel","gridModel","axis","model","set","cartesians","getCartesians","cartesian","getAxis","panelRectBuilders","xAxisDeclared","yAxisDeclared","geo","geoModels","geoModel","xAxisModel","yAxisModel","master","getRect","getBoundingRect","applyTransform","axisConvert","to","rangeOrCoordRange","clamp","xminymin","pointToData","dataToPoint","xmaxymax","Infinity","item","p","axisNameIndex","coordToData","toLocalCoord","toGlobalCoord","dataToCoord","NaN","axisDiffProcessor","refer","idx"],"sourceRoot":""}
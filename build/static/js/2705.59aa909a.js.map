{"version":3,"file":"static/js/2705.59aa909a.js","mappings":"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","sources":["../node_modules/echarts/lib/util/layout.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// Layout helpers for each component positioning\nimport * as zrUtil from 'zrender/lib/core/util.js';\nimport BoundingRect from 'zrender/lib/core/BoundingRect.js';\nimport { parsePercent } from './number.js';\nimport * as formatUtil from './format.js';\nvar each = zrUtil.each;\n/**\n * @public\n */\n\nexport var LOCATION_PARAMS = ['left', 'right', 'top', 'bottom', 'width', 'height'];\n/**\n * @public\n */\n\nexport var HV_NAMES = [['width', 'left', 'right'], ['height', 'top', 'bottom']];\n\nfunction boxLayout(orient, group, gap, maxWidth, maxHeight) {\n  var x = 0;\n  var y = 0;\n\n  if (maxWidth == null) {\n    maxWidth = Infinity;\n  }\n\n  if (maxHeight == null) {\n    maxHeight = Infinity;\n  }\n\n  var currentLineMaxSize = 0;\n  group.eachChild(function (child, idx) {\n    var rect = child.getBoundingRect();\n    var nextChild = group.childAt(idx + 1);\n    var nextChildRect = nextChild && nextChild.getBoundingRect();\n    var nextX;\n    var nextY;\n\n    if (orient === 'horizontal') {\n      var moveX = rect.width + (nextChildRect ? -nextChildRect.x + rect.x : 0);\n      nextX = x + moveX; // Wrap when width exceeds maxWidth or meet a `newline` group\n      // FIXME compare before adding gap?\n\n      if (nextX > maxWidth || child.newline) {\n        x = 0;\n        nextX = moveX;\n        y += currentLineMaxSize + gap;\n        currentLineMaxSize = rect.height;\n      } else {\n        // FIXME: consider rect.y is not `0`?\n        currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);\n      }\n    } else {\n      var moveY = rect.height + (nextChildRect ? -nextChildRect.y + rect.y : 0);\n      nextY = y + moveY; // Wrap when width exceeds maxHeight or meet a `newline` group\n\n      if (nextY > maxHeight || child.newline) {\n        x += currentLineMaxSize + gap;\n        y = 0;\n        nextY = moveY;\n        currentLineMaxSize = rect.width;\n      } else {\n        currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);\n      }\n    }\n\n    if (child.newline) {\n      return;\n    }\n\n    child.x = x;\n    child.y = y;\n    child.markRedraw();\n    orient === 'horizontal' ? x = nextX + gap : y = nextY + gap;\n  });\n}\n/**\n * VBox or HBox layouting\n * @param {string} orient\n * @param {module:zrender/graphic/Group} group\n * @param {number} gap\n * @param {number} [width=Infinity]\n * @param {number} [height=Infinity]\n */\n\n\nexport var box = boxLayout;\n/**\n * VBox layouting\n * @param {module:zrender/graphic/Group} group\n * @param {number} gap\n * @param {number} [width=Infinity]\n * @param {number} [height=Infinity]\n */\n\nexport var vbox = zrUtil.curry(boxLayout, 'vertical');\n/**\n * HBox layouting\n * @param {module:zrender/graphic/Group} group\n * @param {number} gap\n * @param {number} [width=Infinity]\n * @param {number} [height=Infinity]\n */\n\nexport var hbox = zrUtil.curry(boxLayout, 'horizontal');\n/**\n * If x or x2 is not specified or 'center' 'left' 'right',\n * the width would be as long as possible.\n * If y or y2 is not specified or 'middle' 'top' 'bottom',\n * the height would be as long as possible.\n */\n\nexport function getAvailableSize(positionInfo, containerRect, margin) {\n  var containerWidth = containerRect.width;\n  var containerHeight = containerRect.height;\n  var x = parsePercent(positionInfo.left, containerWidth);\n  var y = parsePercent(positionInfo.top, containerHeight);\n  var x2 = parsePercent(positionInfo.right, containerWidth);\n  var y2 = parsePercent(positionInfo.bottom, containerHeight);\n  (isNaN(x) || isNaN(parseFloat(positionInfo.left))) && (x = 0);\n  (isNaN(x2) || isNaN(parseFloat(positionInfo.right))) && (x2 = containerWidth);\n  (isNaN(y) || isNaN(parseFloat(positionInfo.top))) && (y = 0);\n  (isNaN(y2) || isNaN(parseFloat(positionInfo.bottom))) && (y2 = containerHeight);\n  margin = formatUtil.normalizeCssArray(margin || 0);\n  return {\n    width: Math.max(x2 - x - margin[1] - margin[3], 0),\n    height: Math.max(y2 - y - margin[0] - margin[2], 0)\n  };\n}\n/**\n * Parse position info.\n */\n\nexport function getLayoutRect(positionInfo, containerRect, margin) {\n  margin = formatUtil.normalizeCssArray(margin || 0);\n  var containerWidth = containerRect.width;\n  var containerHeight = containerRect.height;\n  var left = parsePercent(positionInfo.left, containerWidth);\n  var top = parsePercent(positionInfo.top, containerHeight);\n  var right = parsePercent(positionInfo.right, containerWidth);\n  var bottom = parsePercent(positionInfo.bottom, containerHeight);\n  var width = parsePercent(positionInfo.width, containerWidth);\n  var height = parsePercent(positionInfo.height, containerHeight);\n  var verticalMargin = margin[2] + margin[0];\n  var horizontalMargin = margin[1] + margin[3];\n  var aspect = positionInfo.aspect; // If width is not specified, calculate width from left and right\n\n  if (isNaN(width)) {\n    width = containerWidth - right - horizontalMargin - left;\n  }\n\n  if (isNaN(height)) {\n    height = containerHeight - bottom - verticalMargin - top;\n  }\n\n  if (aspect != null) {\n    // If width and height are not given\n    // 1. Graph should not exceeds the container\n    // 2. Aspect must be keeped\n    // 3. Graph should take the space as more as possible\n    // FIXME\n    // Margin is not considered, because there is no case that both\n    // using margin and aspect so far.\n    if (isNaN(width) && isNaN(height)) {\n      if (aspect > containerWidth / containerHeight) {\n        width = containerWidth * 0.8;\n      } else {\n        height = containerHeight * 0.8;\n      }\n    } // Calculate width or height with given aspect\n\n\n    if (isNaN(width)) {\n      width = aspect * height;\n    }\n\n    if (isNaN(height)) {\n      height = width / aspect;\n    }\n  } // If left is not specified, calculate left from right and width\n\n\n  if (isNaN(left)) {\n    left = containerWidth - right - width - horizontalMargin;\n  }\n\n  if (isNaN(top)) {\n    top = containerHeight - bottom - height - verticalMargin;\n  } // Align left and top\n\n\n  switch (positionInfo.left || positionInfo.right) {\n    case 'center':\n      left = containerWidth / 2 - width / 2 - margin[3];\n      break;\n\n    case 'right':\n      left = containerWidth - width - horizontalMargin;\n      break;\n  }\n\n  switch (positionInfo.top || positionInfo.bottom) {\n    case 'middle':\n    case 'center':\n      top = containerHeight / 2 - height / 2 - margin[0];\n      break;\n\n    case 'bottom':\n      top = containerHeight - height - verticalMargin;\n      break;\n  } // If something is wrong and left, top, width, height are calculated as NaN\n\n\n  left = left || 0;\n  top = top || 0;\n\n  if (isNaN(width)) {\n    // Width may be NaN if only one value is given except width\n    width = containerWidth - horizontalMargin - left - (right || 0);\n  }\n\n  if (isNaN(height)) {\n    // Height may be NaN if only one value is given except height\n    height = containerHeight - verticalMargin - top - (bottom || 0);\n  }\n\n  var rect = new BoundingRect(left + margin[3], top + margin[0], width, height);\n  rect.margin = margin;\n  return rect;\n}\n/**\n * Position a zr element in viewport\n *  Group position is specified by either\n *  {left, top}, {right, bottom}\n *  If all properties exists, right and bottom will be igonred.\n *\n * Logic:\n *     1. Scale (against origin point in parent coord)\n *     2. Rotate (against origin point in parent coord)\n *     3. Traslate (with el.position by this method)\n * So this method only fixes the last step 'Traslate', which does not affect\n * scaling and rotating.\n *\n * If be called repeatly with the same input el, the same result will be gotten.\n *\n * Return true if the layout happend.\n *\n * @param el Should have `getBoundingRect` method.\n * @param positionInfo\n * @param positionInfo.left\n * @param positionInfo.top\n * @param positionInfo.right\n * @param positionInfo.bottom\n * @param positionInfo.width Only for opt.boundingModel: 'raw'\n * @param positionInfo.height Only for opt.boundingModel: 'raw'\n * @param containerRect\n * @param margin\n * @param opt\n * @param opt.hv Only horizontal or only vertical. Default to be [1, 1]\n * @param opt.boundingMode\n *        Specify how to calculate boundingRect when locating.\n *        'all': Position the boundingRect that is transformed and uioned\n *               both itself and its descendants.\n *               This mode simplies confine the elements in the bounding\n *               of their container (e.g., using 'right: 0').\n *        'raw': Position the boundingRect that is not transformed and only itself.\n *               This mode is useful when you want a element can overflow its\n *               container. (Consider a rotated circle needs to be located in a corner.)\n *               In this mode positionInfo.width/height can only be number.\n */\n\nexport function positionElement(el, positionInfo, containerRect, margin, opt, out) {\n  var h = !opt || !opt.hv || opt.hv[0];\n  var v = !opt || !opt.hv || opt.hv[1];\n  var boundingMode = opt && opt.boundingMode || 'all';\n  out = out || el;\n  out.x = el.x;\n  out.y = el.y;\n\n  if (!h && !v) {\n    return false;\n  }\n\n  var rect;\n\n  if (boundingMode === 'raw') {\n    rect = el.type === 'group' ? new BoundingRect(0, 0, +positionInfo.width || 0, +positionInfo.height || 0) : el.getBoundingRect();\n  } else {\n    rect = el.getBoundingRect();\n\n    if (el.needLocalTransform()) {\n      var transform = el.getLocalTransform(); // Notice: raw rect may be inner object of el,\n      // which should not be modified.\n\n      rect = rect.clone();\n      rect.applyTransform(transform);\n    }\n  } // The real width and height can not be specified but calculated by the given el.\n\n\n  var layoutRect = getLayoutRect(zrUtil.defaults({\n    width: rect.width,\n    height: rect.height\n  }, positionInfo), containerRect, margin); // Because 'tranlate' is the last step in transform\n  // (see zrender/core/Transformable#getLocalTransform),\n  // we can just only modify el.position to get final result.\n\n  var dx = h ? layoutRect.x - rect.x : 0;\n  var dy = v ? layoutRect.y - rect.y : 0;\n\n  if (boundingMode === 'raw') {\n    out.x = dx;\n    out.y = dy;\n  } else {\n    out.x += dx;\n    out.y += dy;\n  }\n\n  if (out === el) {\n    el.markRedraw();\n  }\n\n  return true;\n}\n/**\n * @param option Contains some of the properties in HV_NAMES.\n * @param hvIdx 0: horizontal; 1: vertical.\n */\n\nexport function sizeCalculable(option, hvIdx) {\n  return option[HV_NAMES[hvIdx][0]] != null || option[HV_NAMES[hvIdx][1]] != null && option[HV_NAMES[hvIdx][2]] != null;\n}\nexport function fetchLayoutMode(ins) {\n  var layoutMode = ins.layoutMode || ins.constructor.layoutMode;\n  return zrUtil.isObject(layoutMode) ? layoutMode : layoutMode ? {\n    type: layoutMode\n  } : null;\n}\n/**\n * Consider Case:\n * When default option has {left: 0, width: 100}, and we set {right: 0}\n * through setOption or media query, using normal zrUtil.merge will cause\n * {right: 0} does not take effect.\n *\n * @example\n * ComponentModel.extend({\n *     init: function () {\n *         ...\n *         let inputPositionParams = layout.getLayoutParams(option);\n *         this.mergeOption(inputPositionParams);\n *     },\n *     mergeOption: function (newOption) {\n *         newOption && zrUtil.merge(thisOption, newOption, true);\n *         layout.mergeLayoutParam(thisOption, newOption);\n *     }\n * });\n *\n * @param targetOption\n * @param newOption\n * @param opt\n */\n\nexport function mergeLayoutParam(targetOption, newOption, opt) {\n  var ignoreSize = opt && opt.ignoreSize;\n  !zrUtil.isArray(ignoreSize) && (ignoreSize = [ignoreSize, ignoreSize]);\n  var hResult = merge(HV_NAMES[0], 0);\n  var vResult = merge(HV_NAMES[1], 1);\n  copy(HV_NAMES[0], targetOption, hResult);\n  copy(HV_NAMES[1], targetOption, vResult);\n\n  function merge(names, hvIdx) {\n    var newParams = {};\n    var newValueCount = 0;\n    var merged = {};\n    var mergedValueCount = 0;\n    var enoughParamNumber = 2;\n    each(names, function (name) {\n      merged[name] = targetOption[name];\n    });\n    each(names, function (name) {\n      // Consider case: newOption.width is null, which is\n      // set by user for removing width setting.\n      hasProp(newOption, name) && (newParams[name] = merged[name] = newOption[name]);\n      hasValue(newParams, name) && newValueCount++;\n      hasValue(merged, name) && mergedValueCount++;\n    });\n\n    if (ignoreSize[hvIdx]) {\n      // Only one of left/right is premitted to exist.\n      if (hasValue(newOption, names[1])) {\n        merged[names[2]] = null;\n      } else if (hasValue(newOption, names[2])) {\n        merged[names[1]] = null;\n      }\n\n      return merged;\n    } // Case: newOption: {width: ..., right: ...},\n    // or targetOption: {right: ...} and newOption: {width: ...},\n    // There is no conflict when merged only has params count\n    // little than enoughParamNumber.\n\n\n    if (mergedValueCount === enoughParamNumber || !newValueCount) {\n      return merged;\n    } // Case: newOption: {width: ..., right: ...},\n    // Than we can make sure user only want those two, and ignore\n    // all origin params in targetOption.\n    else if (newValueCount >= enoughParamNumber) {\n        return newParams;\n      } else {\n        // Chose another param from targetOption by priority.\n        for (var i = 0; i < names.length; i++) {\n          var name_1 = names[i];\n\n          if (!hasProp(newParams, name_1) && hasProp(targetOption, name_1)) {\n            newParams[name_1] = targetOption[name_1];\n            break;\n          }\n        }\n\n        return newParams;\n      }\n  }\n\n  function hasProp(obj, name) {\n    return obj.hasOwnProperty(name);\n  }\n\n  function hasValue(obj, name) {\n    return obj[name] != null && obj[name] !== 'auto';\n  }\n\n  function copy(names, target, source) {\n    each(names, function (name) {\n      target[name] = source[name];\n    });\n  }\n}\n/**\n * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n */\n\nexport function getLayoutParams(source) {\n  return copyLayoutParams({}, source);\n}\n/**\n * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n * @param {Object} source\n * @return {Object} Result contains those props.\n */\n\nexport function copyLayoutParams(target, source) {\n  source && target && each(LOCATION_PARAMS, function (name) {\n    source.hasOwnProperty(name) && (target[name] = source[name]);\n  });\n  return target;\n}"],"names":["each","zrUtil","LOCATION_PARAMS","HV_NAMES","boxLayout","orient","group","gap","maxWidth","maxHeight","x","y","Infinity","currentLineMaxSize","eachChild","child","idx","nextX","nextY","rect","getBoundingRect","nextChild","childAt","nextChildRect","moveX","width","newline","height","Math","max","moveY","markRedraw","box","getAvailableSize","positionInfo","containerRect","margin","containerWidth","containerHeight","parsePercent","left","top","x2","right","y2","bottom","isNaN","parseFloat","formatUtil","getLayoutRect","verticalMargin","horizontalMargin","aspect","BoundingRect","positionElement","el","opt","out","h","hv","v","boundingMode","type","needLocalTransform","transform","getLocalTransform","clone","applyTransform","layoutRect","dx","dy","sizeCalculable","option","hvIdx","fetchLayoutMode","ins","layoutMode","constructor","mergeLayoutParam","targetOption","newOption","ignoreSize","hResult","merge","vResult","names","newParams","newValueCount","merged","mergedValueCount","name","hasProp","hasValue","i","length","name_1","obj","hasOwnProperty","copy","target","source","getLayoutParams","copyLayoutParams"],"sourceRoot":""}
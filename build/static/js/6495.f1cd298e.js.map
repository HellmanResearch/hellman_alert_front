{"version":3,"file":"static/js/6495.f1cd298e.js","mappings":"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","sources":["../node_modules/echarts/lib/data/SeriesData.js","../node_modules/echarts/lib/data/SeriesDimensionDefine.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/* global Int32Array */\nimport * as zrUtil from 'zrender/lib/core/util.js';\nimport Model from '../model/Model.js';\nimport DataDiffer from './DataDiffer.js';\nimport { DefaultDataProvider } from './helper/dataProvider.js';\nimport { summarizeDimensions } from './helper/dimensionHelper.js';\nimport SeriesDimensionDefine from './SeriesDimensionDefine.js';\nimport { SOURCE_FORMAT_TYPED_ARRAY, SOURCE_FORMAT_ORIGINAL } from '../util/types.js';\nimport { convertOptionIdName, isDataItemOption } from '../util/model.js';\nimport { setCommonECData } from '../util/innerStore.js';\nimport { isSourceInstance } from './Source.js';\nimport DataStore from './DataStore.js';\nimport { isSeriesDataSchema } from './helper/SeriesDataSchema.js';\nvar isObject = zrUtil.isObject;\nvar map = zrUtil.map;\nvar CtorInt32Array = typeof Int32Array === 'undefined' ? Array : Int32Array; // Use prefix to avoid index to be the same as otherIdList[idx],\n// which will cause weird udpate animation.\n\nvar ID_PREFIX = 'e\\0\\0';\nvar INDEX_NOT_FOUND = -1; // type SeriesDimensionIndex = DimensionIndex;\n\nvar TRANSFERABLE_PROPERTIES = ['hasItemOption', '_nameList', '_idList', '_invertedIndicesMap', '_dimSummary', 'userOutput', '_rawData', '_dimValueGetter', '_nameDimIdx', '_idDimIdx', '_nameRepeatCount'];\nvar CLONE_PROPERTIES = ['_approximateExtent']; // -----------------------------\n// Internal method declarations:\n// -----------------------------\n\nvar prepareInvertedIndex;\nvar getId;\nvar getIdNameFromStore;\nvar normalizeDimensions;\nvar transferProperties;\nvar cloneListForMapAndSample;\nvar makeIdFromName;\n\nvar SeriesData =\n/** @class */\nfunction () {\n  /**\n   * @param dimensionsInput.dimensions\n   *        For example, ['someDimName', {name: 'someDimName', type: 'someDimType'}, ...].\n   *        Dimensions should be concrete names like x, y, z, lng, lat, angle, radius\n   */\n  function SeriesData(dimensionsInput, hostModel) {\n    this.type = 'list';\n    this._dimOmitted = false;\n    this._nameList = [];\n    this._idList = []; // Models of data option is stored sparse for optimizing memory cost\n    // Never used yet (not used yet).\n    // private _optionModels: Model[] = [];\n    // Global visual properties after visual coding\n\n    this._visual = {}; // Globel layout properties.\n\n    this._layout = {}; // Item visual properties after visual coding\n\n    this._itemVisuals = []; // Item layout properties after layout\n\n    this._itemLayouts = []; // Graphic elemnents\n\n    this._graphicEls = []; // key: dim, value: extent\n\n    this._approximateExtent = {};\n    this._calculationInfo = {}; // Having detected that there is data item is non primitive type\n    // (in type `OptionDataItemObject`).\n    // Like `data: [ { value: xx, itemStyle: {...} }, ...]`\n    // At present it only happen in `SOURCE_FORMAT_ORIGINAL`.\n\n    this.hasItemOption = false; // Methods that create a new list based on this list should be listed here.\n    // Notice that those method should `RETURN` the new list.\n\n    this.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'lttbDownSample', 'map']; // Methods that change indices of this list should be listed here.\n\n    this.CHANGABLE_METHODS = ['filterSelf', 'selectRange'];\n    this.DOWNSAMPLE_METHODS = ['downSample', 'lttbDownSample'];\n    var dimensions;\n    var assignStoreDimIdx = false;\n\n    if (isSeriesDataSchema(dimensionsInput)) {\n      dimensions = dimensionsInput.dimensions;\n      this._dimOmitted = dimensionsInput.isDimensionOmitted();\n      this._schema = dimensionsInput;\n    } else {\n      assignStoreDimIdx = true;\n      dimensions = dimensionsInput;\n    }\n\n    dimensions = dimensions || ['x', 'y'];\n    var dimensionInfos = {};\n    var dimensionNames = [];\n    var invertedIndicesMap = {};\n    var needsHasOwn = false;\n    var emptyObj = {};\n\n    for (var i = 0; i < dimensions.length; i++) {\n      // Use the original dimensions[i], where other flag props may exists.\n      var dimInfoInput = dimensions[i];\n      var dimensionInfo = zrUtil.isString(dimInfoInput) ? new SeriesDimensionDefine({\n        name: dimInfoInput\n      }) : !(dimInfoInput instanceof SeriesDimensionDefine) ? new SeriesDimensionDefine(dimInfoInput) : dimInfoInput;\n      var dimensionName = dimensionInfo.name;\n      dimensionInfo.type = dimensionInfo.type || 'float';\n\n      if (!dimensionInfo.coordDim) {\n        dimensionInfo.coordDim = dimensionName;\n        dimensionInfo.coordDimIndex = 0;\n      }\n\n      var otherDims = dimensionInfo.otherDims = dimensionInfo.otherDims || {};\n      dimensionNames.push(dimensionName);\n      dimensionInfos[dimensionName] = dimensionInfo;\n\n      if (emptyObj[dimensionName] != null) {\n        needsHasOwn = true;\n      }\n\n      if (dimensionInfo.createInvertedIndices) {\n        invertedIndicesMap[dimensionName] = [];\n      }\n\n      if (otherDims.itemName === 0) {\n        this._nameDimIdx = i;\n      }\n\n      if (otherDims.itemId === 0) {\n        this._idDimIdx = i;\n      }\n\n      if (process.env.NODE_ENV !== 'production') {\n        zrUtil.assert(assignStoreDimIdx || dimensionInfo.storeDimIndex >= 0);\n      }\n\n      if (assignStoreDimIdx) {\n        dimensionInfo.storeDimIndex = i;\n      }\n    }\n\n    this.dimensions = dimensionNames;\n    this._dimInfos = dimensionInfos;\n\n    this._initGetDimensionInfo(needsHasOwn);\n\n    this.hostModel = hostModel;\n    this._invertedIndicesMap = invertedIndicesMap;\n\n    if (this._dimOmitted) {\n      var dimIdxToName_1 = this._dimIdxToName = zrUtil.createHashMap();\n      zrUtil.each(dimensionNames, function (dimName) {\n        dimIdxToName_1.set(dimensionInfos[dimName].storeDimIndex, dimName);\n      });\n    }\n  }\n  /**\n   *\n   * Get concrete dimension name by dimension name or dimension index.\n   * If input a dimension name, do not validate whether the dimension name exits.\n   *\n   * @caution\n   * @param dim Must make sure the dimension is `SeriesDimensionLoose`.\n   * Because only those dimensions will have auto-generated dimension names if not\n   * have a user-specified name, and other dimensions will get a return of null/undefined.\n   *\n   * @notice Becuause of this reason, should better use `getDimensionIndex` instead, for examples:\n   * ```js\n   * const val = data.getStore().get(data.getDimensionIndex(dim), dataIdx);\n   * ```\n   *\n   * @return Concrete dim name.\n   */\n\n\n  SeriesData.prototype.getDimension = function (dim) {\n    var dimIdx = this._recognizeDimIndex(dim);\n\n    if (dimIdx == null) {\n      return dim;\n    }\n\n    dimIdx = dim;\n\n    if (!this._dimOmitted) {\n      return this.dimensions[dimIdx];\n    } // Retrieve from series dimension definition becuase it probably contains\n    // generated dimension name (like 'x', 'y').\n\n\n    var dimName = this._dimIdxToName.get(dimIdx);\n\n    if (dimName != null) {\n      return dimName;\n    }\n\n    var sourceDimDef = this._schema.getSourceDimension(dimIdx);\n\n    if (sourceDimDef) {\n      return sourceDimDef.name;\n    }\n  };\n  /**\n   * Get dimension index in data store. Return -1 if not found.\n   * Can be used to index value from getRawValue.\n   */\n\n\n  SeriesData.prototype.getDimensionIndex = function (dim) {\n    var dimIdx = this._recognizeDimIndex(dim);\n\n    if (dimIdx != null) {\n      return dimIdx;\n    }\n\n    if (dim == null) {\n      return -1;\n    }\n\n    var dimInfo = this._getDimInfo(dim);\n\n    return dimInfo ? dimInfo.storeDimIndex : this._dimOmitted ? this._schema.getSourceDimensionIndex(dim) : -1;\n  };\n  /**\n   * The meanings of the input parameter `dim`:\n   *\n   * + If dim is a number (e.g., `1`), it means the index of the dimension.\n   *   For example, `getDimension(0)` will return 'x' or 'lng' or 'radius'.\n   * + If dim is a number-like string (e.g., `\"1\"`):\n   *     + If there is the same concrete dim name defined in `series.dimensions` or `dataset.dimensions`,\n   *        it means that concrete name.\n   *     + If not, it will be converted to a number, which means the index of the dimension.\n   *        (why? because of the backward compatbility. We have been tolerating number-like string in\n   *        dimension setting, although now it seems that it is not a good idea.)\n   *     For example, `visualMap[i].dimension: \"1\"` is the same meaning as `visualMap[i].dimension: 1`,\n   *     if no dimension name is defined as `\"1\"`.\n   * + If dim is a not-number-like string, it means the concrete dim name.\n   *   For example, it can be be default name `\"x\"`, `\"y\"`, `\"z\"`, `\"lng\"`, `\"lat\"`, `\"angle\"`, `\"radius\"`,\n   *   or customized in `dimensions` property of option like `\"age\"`.\n   *\n   * @return recogonized `DimensionIndex`. Otherwise return null/undefined (means that dim is `DimensionName`).\n   */\n\n\n  SeriesData.prototype._recognizeDimIndex = function (dim) {\n    if (zrUtil.isNumber(dim) // If being a number-like string but not being defined as a dimension name.\n    || dim != null && !isNaN(dim) && !this._getDimInfo(dim) && (!this._dimOmitted || this._schema.getSourceDimensionIndex(dim) < 0)) {\n      return +dim;\n    }\n  };\n\n  SeriesData.prototype._getStoreDimIndex = function (dim) {\n    var dimIdx = this.getDimensionIndex(dim);\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (dimIdx == null) {\n        throw new Error('Unkown dimension ' + dim);\n      }\n    }\n\n    return dimIdx;\n  };\n  /**\n   * Get type and calculation info of particular dimension\n   * @param dim\n   *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n   *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n   */\n\n\n  SeriesData.prototype.getDimensionInfo = function (dim) {\n    // Do not clone, because there may be categories in dimInfo.\n    return this._getDimInfo(this.getDimension(dim));\n  };\n\n  SeriesData.prototype._initGetDimensionInfo = function (needsHasOwn) {\n    var dimensionInfos = this._dimInfos;\n    this._getDimInfo = needsHasOwn ? function (dimName) {\n      return dimensionInfos.hasOwnProperty(dimName) ? dimensionInfos[dimName] : undefined;\n    } : function (dimName) {\n      return dimensionInfos[dimName];\n    };\n  };\n  /**\n   * concrete dimension name list on coord.\n   */\n\n\n  SeriesData.prototype.getDimensionsOnCoord = function () {\n    return this._dimSummary.dataDimsOnCoord.slice();\n  };\n\n  SeriesData.prototype.mapDimension = function (coordDim, idx) {\n    var dimensionsSummary = this._dimSummary;\n\n    if (idx == null) {\n      return dimensionsSummary.encodeFirstDimNotExtra[coordDim];\n    }\n\n    var dims = dimensionsSummary.encode[coordDim];\n    return dims ? dims[idx] : null;\n  };\n\n  SeriesData.prototype.mapDimensionsAll = function (coordDim) {\n    var dimensionsSummary = this._dimSummary;\n    var dims = dimensionsSummary.encode[coordDim];\n    return (dims || []).slice();\n  };\n\n  SeriesData.prototype.getStore = function () {\n    return this._store;\n  };\n  /**\n   * Initialize from data\n   * @param data source or data or data store.\n   * @param nameList The name of a datum is used on data diff and\n   *        default label/tooltip.\n   *        A name can be specified in encode.itemName,\n   *        or dataItem.name (only for series option data),\n   *        or provided in nameList from outside.\n   */\n\n\n  SeriesData.prototype.initData = function (data, nameList, dimValueGetter) {\n    var _this = this;\n\n    var store;\n\n    if (data instanceof DataStore) {\n      store = data;\n    }\n\n    if (!store) {\n      var dimensions = this.dimensions;\n      var provider = isSourceInstance(data) || zrUtil.isArrayLike(data) ? new DefaultDataProvider(data, dimensions.length) : data;\n      store = new DataStore();\n      var dimensionInfos = map(dimensions, function (dimName) {\n        return {\n          type: _this._dimInfos[dimName].type,\n          property: dimName\n        };\n      });\n      store.initData(provider, dimensionInfos, dimValueGetter);\n    }\n\n    this._store = store; // Reset\n\n    this._nameList = (nameList || []).slice();\n    this._idList = [];\n    this._nameRepeatCount = {};\n\n    this._doInit(0, store.count()); // Cache summary info for fast visit. See \"dimensionHelper\".\n    // Needs to be initialized after store is prepared.\n\n\n    this._dimSummary = summarizeDimensions(this, this._schema);\n    this.userOutput = this._dimSummary.userOutput;\n  };\n  /**\n   * Caution: Can be only called on raw data (before `this._indices` created).\n   */\n\n\n  SeriesData.prototype.appendData = function (data) {\n    var range = this._store.appendData(data);\n\n    this._doInit(range[0], range[1]);\n  };\n  /**\n   * Caution: Can be only called on raw data (before `this._indices` created).\n   * This method does not modify `rawData` (`dataProvider`), but only\n   * add values to store.\n   *\n   * The final count will be increased by `Math.max(values.length, names.length)`.\n   *\n   * @param values That is the SourceType: 'arrayRows', like\n   *        [\n   *            [12, 33, 44],\n   *            [NaN, 43, 1],\n   *            ['-', 'asdf', 0]\n   *        ]\n   *        Each item is exaclty cooresponding to a dimension.\n   */\n\n\n  SeriesData.prototype.appendValues = function (values, names) {\n    var _a = this._store.appendValues(values, names.length),\n        start = _a.start,\n        end = _a.end;\n\n    var shouldMakeIdFromName = this._shouldMakeIdFromName();\n\n    this._updateOrdinalMeta();\n\n    if (names) {\n      for (var idx = start; idx < end; idx++) {\n        var sourceIdx = idx - start;\n        this._nameList[idx] = names[sourceIdx];\n\n        if (shouldMakeIdFromName) {\n          makeIdFromName(this, idx);\n        }\n      }\n    }\n  };\n\n  SeriesData.prototype._updateOrdinalMeta = function () {\n    var store = this._store;\n    var dimensions = this.dimensions;\n\n    for (var i = 0; i < dimensions.length; i++) {\n      var dimInfo = this._dimInfos[dimensions[i]];\n\n      if (dimInfo.ordinalMeta) {\n        store.collectOrdinalMeta(dimInfo.storeDimIndex, dimInfo.ordinalMeta);\n      }\n    }\n  };\n\n  SeriesData.prototype._shouldMakeIdFromName = function () {\n    var provider = this._store.getProvider();\n\n    return this._idDimIdx == null && provider.getSource().sourceFormat !== SOURCE_FORMAT_TYPED_ARRAY && !provider.fillStorage;\n  };\n\n  SeriesData.prototype._doInit = function (start, end) {\n    if (start >= end) {\n      return;\n    }\n\n    var store = this._store;\n    var provider = store.getProvider();\n\n    this._updateOrdinalMeta();\n\n    var nameList = this._nameList;\n    var idList = this._idList;\n    var sourceFormat = provider.getSource().sourceFormat;\n    var isFormatOriginal = sourceFormat === SOURCE_FORMAT_ORIGINAL; // Each data item is value\n    // [1, 2]\n    // 2\n    // Bar chart, line chart which uses category axis\n    // only gives the 'y' value. 'x' value is the indices of category\n    // Use a tempValue to normalize the value to be a (x, y) value\n    // If dataItem is {name: ...} or {id: ...}, it has highest priority.\n    // This kind of ids and names are always stored `_nameList` and `_idList`.\n\n    if (isFormatOriginal && !provider.pure) {\n      var sharedDataItem = [];\n\n      for (var idx = start; idx < end; idx++) {\n        // NOTICE: Try not to write things into dataItem\n        var dataItem = provider.getItem(idx, sharedDataItem);\n\n        if (!this.hasItemOption && isDataItemOption(dataItem)) {\n          this.hasItemOption = true;\n        }\n\n        if (dataItem) {\n          var itemName = dataItem.name;\n\n          if (nameList[idx] == null && itemName != null) {\n            nameList[idx] = convertOptionIdName(itemName, null);\n          }\n\n          var itemId = dataItem.id;\n\n          if (idList[idx] == null && itemId != null) {\n            idList[idx] = convertOptionIdName(itemId, null);\n          }\n        }\n      }\n    }\n\n    if (this._shouldMakeIdFromName()) {\n      for (var idx = start; idx < end; idx++) {\n        makeIdFromName(this, idx);\n      }\n    }\n\n    prepareInvertedIndex(this);\n  };\n  /**\n   * PENDING: In fact currently this function is only used to short-circuit\n   * the calling of `scale.unionExtentFromData` when data have been filtered by modules\n   * like \"dataZoom\". `scale.unionExtentFromData` is used to calculate data extent for series on\n   * an axis, but if a \"axis related data filter module\" is used, the extent of the axis have\n   * been fixed and no need to calling `scale.unionExtentFromData` actually.\n   * But if we add \"custom data filter\" in future, which is not \"axis related\", this method may\n   * be still needed.\n   *\n   * Optimize for the scenario that data is filtered by a given extent.\n   * Consider that if data amount is more than hundreds of thousand,\n   * extent calculation will cost more than 10ms and the cache will\n   * be erased because of the filtering.\n   */\n\n\n  SeriesData.prototype.getApproximateExtent = function (dim) {\n    return this._approximateExtent[dim] || this._store.getDataExtent(this._getStoreDimIndex(dim));\n  };\n  /**\n   * Calculate extent on a filtered data might be time consuming.\n   * Approximate extent is only used for: calculte extent of filtered data outside.\n   */\n\n\n  SeriesData.prototype.setApproximateExtent = function (extent, dim) {\n    dim = this.getDimension(dim);\n    this._approximateExtent[dim] = extent.slice();\n  };\n\n  SeriesData.prototype.getCalculationInfo = function (key) {\n    return this._calculationInfo[key];\n  };\n\n  SeriesData.prototype.setCalculationInfo = function (key, value) {\n    isObject(key) ? zrUtil.extend(this._calculationInfo, key) : this._calculationInfo[key] = value;\n  };\n  /**\n   * @return Never be null/undefined. `number` will be converted to string. Becuase:\n   * In most cases, name is used in display, where returning a string is more convenient.\n   * In other cases, name is used in query (see `indexOfName`), where we can keep the\n   * rule that name `2` equals to name `'2'`.\n   */\n\n\n  SeriesData.prototype.getName = function (idx) {\n    var rawIndex = this.getRawIndex(idx);\n    var name = this._nameList[rawIndex];\n\n    if (name == null && this._nameDimIdx != null) {\n      name = getIdNameFromStore(this, this._nameDimIdx, rawIndex);\n    }\n\n    if (name == null) {\n      name = '';\n    }\n\n    return name;\n  };\n\n  SeriesData.prototype._getCategory = function (dimIdx, idx) {\n    var ordinal = this._store.get(dimIdx, idx);\n\n    var ordinalMeta = this._store.getOrdinalMeta(dimIdx);\n\n    if (ordinalMeta) {\n      return ordinalMeta.categories[ordinal];\n    }\n\n    return ordinal;\n  };\n  /**\n   * @return Never null/undefined. `number` will be converted to string. Becuase:\n   * In all cases having encountered at present, id is used in making diff comparison, which\n   * are usually based on hash map. We can keep the rule that the internal id are always string\n   * (treat `2` is the same as `'2'`) to make the related logic simple.\n   */\n\n\n  SeriesData.prototype.getId = function (idx) {\n    return getId(this, this.getRawIndex(idx));\n  };\n\n  SeriesData.prototype.count = function () {\n    return this._store.count();\n  };\n  /**\n   * Get value. Return NaN if idx is out of range.\n   *\n   * @notice Should better to use `data.getStore().get(dimIndex, dataIdx)` instead.\n   */\n\n\n  SeriesData.prototype.get = function (dim, idx) {\n    var store = this._store;\n    var dimInfo = this._dimInfos[dim];\n\n    if (dimInfo) {\n      return store.get(dimInfo.storeDimIndex, idx);\n    }\n  };\n  /**\n   * @notice Should better to use `data.getStore().getByRawIndex(dimIndex, dataIdx)` instead.\n   */\n\n\n  SeriesData.prototype.getByRawIndex = function (dim, rawIdx) {\n    var store = this._store;\n    var dimInfo = this._dimInfos[dim];\n\n    if (dimInfo) {\n      return store.getByRawIndex(dimInfo.storeDimIndex, rawIdx);\n    }\n  };\n\n  SeriesData.prototype.getIndices = function () {\n    return this._store.getIndices();\n  };\n\n  SeriesData.prototype.getDataExtent = function (dim) {\n    return this._store.getDataExtent(this._getStoreDimIndex(dim));\n  };\n\n  SeriesData.prototype.getSum = function (dim) {\n    return this._store.getSum(this._getStoreDimIndex(dim));\n  };\n\n  SeriesData.prototype.getMedian = function (dim) {\n    return this._store.getMedian(this._getStoreDimIndex(dim));\n  };\n\n  SeriesData.prototype.getValues = function (dimensions, idx) {\n    var _this = this;\n\n    var store = this._store;\n    return zrUtil.isArray(dimensions) ? store.getValues(map(dimensions, function (dim) {\n      return _this._getStoreDimIndex(dim);\n    }), idx) : store.getValues(dimensions);\n  };\n  /**\n   * If value is NaN. Inlcuding '-'\n   * Only check the coord dimensions.\n   */\n\n\n  SeriesData.prototype.hasValue = function (idx) {\n    var dataDimIndicesOnCoord = this._dimSummary.dataDimIndicesOnCoord;\n\n    for (var i = 0, len = dataDimIndicesOnCoord.length; i < len; i++) {\n      // Ordinal type originally can be string or number.\n      // But when an ordinal type is used on coord, it can\n      // not be string but only number. So we can also use isNaN.\n      if (isNaN(this._store.get(dataDimIndicesOnCoord[i], idx))) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n  /**\n   * Retreive the index with given name\n   */\n\n\n  SeriesData.prototype.indexOfName = function (name) {\n    for (var i = 0, len = this._store.count(); i < len; i++) {\n      if (this.getName(i) === name) {\n        return i;\n      }\n    }\n\n    return -1;\n  };\n\n  SeriesData.prototype.getRawIndex = function (idx) {\n    return this._store.getRawIndex(idx);\n  };\n\n  SeriesData.prototype.indexOfRawIndex = function (rawIndex) {\n    return this._store.indexOfRawIndex(rawIndex);\n  };\n  /**\n   * Only support the dimension which inverted index created.\n   * Do not support other cases until required.\n   * @param dim concrete dim\n   * @param value ordinal index\n   * @return rawIndex\n   */\n\n\n  SeriesData.prototype.rawIndexOf = function (dim, value) {\n    var invertedIndices = dim && this._invertedIndicesMap[dim];\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!invertedIndices) {\n        throw new Error('Do not supported yet');\n      }\n    }\n\n    var rawIndex = invertedIndices[value];\n\n    if (rawIndex == null || isNaN(rawIndex)) {\n      return INDEX_NOT_FOUND;\n    }\n\n    return rawIndex;\n  };\n  /**\n   * Retreive the index of nearest value\n   * @param dim\n   * @param value\n   * @param [maxDistance=Infinity]\n   * @return If and only if multiple indices has\n   *         the same value, they are put to the result.\n   */\n\n\n  SeriesData.prototype.indicesOfNearest = function (dim, value, maxDistance) {\n    return this._store.indicesOfNearest(this._getStoreDimIndex(dim), value, maxDistance);\n  };\n\n  SeriesData.prototype.each = function (dims, cb, ctx) {\n    'use strict';\n\n    if (zrUtil.isFunction(dims)) {\n      ctx = cb;\n      cb = dims;\n      dims = [];\n    } // ctxCompat just for compat echarts3\n\n\n    var fCtx = ctx || this;\n    var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this);\n\n    this._store.each(dimIndices, fCtx ? zrUtil.bind(cb, fCtx) : cb);\n  };\n\n  SeriesData.prototype.filterSelf = function (dims, cb, ctx) {\n    'use strict';\n\n    if (zrUtil.isFunction(dims)) {\n      ctx = cb;\n      cb = dims;\n      dims = [];\n    } // ctxCompat just for compat echarts3\n\n\n    var fCtx = ctx || this;\n    var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this);\n    this._store = this._store.filter(dimIndices, fCtx ? zrUtil.bind(cb, fCtx) : cb);\n    return this;\n  };\n  /**\n   * Select data in range. (For optimization of filter)\n   * (Manually inline code, support 5 million data filtering in data zoom.)\n   */\n\n\n  SeriesData.prototype.selectRange = function (range) {\n    'use strict';\n\n    var _this = this;\n\n    var innerRange = {};\n    var dims = zrUtil.keys(range);\n    var dimIndices = [];\n    zrUtil.each(dims, function (dim) {\n      var dimIdx = _this._getStoreDimIndex(dim);\n\n      innerRange[dimIdx] = range[dim];\n      dimIndices.push(dimIdx);\n    });\n    this._store = this._store.selectRange(innerRange);\n    return this;\n  };\n  /* eslint-enable max-len */\n\n\n  SeriesData.prototype.mapArray = function (dims, cb, ctx) {\n    'use strict';\n\n    if (zrUtil.isFunction(dims)) {\n      ctx = cb;\n      cb = dims;\n      dims = [];\n    } // ctxCompat just for compat echarts3\n\n\n    ctx = ctx || this;\n    var result = [];\n    this.each(dims, function () {\n      result.push(cb && cb.apply(this, arguments));\n    }, ctx);\n    return result;\n  };\n\n  SeriesData.prototype.map = function (dims, cb, ctx, ctxCompat) {\n    'use strict'; // ctxCompat just for compat echarts3\n\n    var fCtx = ctx || ctxCompat || this;\n    var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this);\n    var list = cloneListForMapAndSample(this);\n    list._store = this._store.map(dimIndices, fCtx ? zrUtil.bind(cb, fCtx) : cb);\n    return list;\n  };\n\n  SeriesData.prototype.modify = function (dims, cb, ctx, ctxCompat) {\n    var _this = this; // ctxCompat just for compat echarts3\n\n\n    var fCtx = ctx || ctxCompat || this;\n\n    if (process.env.NODE_ENV !== 'production') {\n      zrUtil.each(normalizeDimensions(dims), function (dim) {\n        var dimInfo = _this.getDimensionInfo(dim);\n\n        if (!dimInfo.isCalculationCoord) {\n          console.error('Danger: only stack dimension can be modified');\n        }\n      });\n    }\n\n    var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this); // If do shallow clone here, if there are too many stacked series,\n    // it still cost lots of memory, becuase `_store.dimensions` are not shared.\n    // We should consider there probably be shallow clone happen in each sereis\n    // in consequent filter/map.\n\n    this._store.modify(dimIndices, fCtx ? zrUtil.bind(cb, fCtx) : cb);\n  };\n  /**\n   * Large data down sampling on given dimension\n   * @param sampleIndex Sample index for name and id\n   */\n\n\n  SeriesData.prototype.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n    var list = cloneListForMapAndSample(this);\n    list._store = this._store.downSample(this._getStoreDimIndex(dimension), rate, sampleValue, sampleIndex);\n    return list;\n  };\n  /**\n   * Large data down sampling using largest-triangle-three-buckets\n   * @param {string} valueDimension\n   * @param {number} targetCount\n   */\n\n\n  SeriesData.prototype.lttbDownSample = function (valueDimension, rate) {\n    var list = cloneListForMapAndSample(this);\n    list._store = this._store.lttbDownSample(this._getStoreDimIndex(valueDimension), rate);\n    return list;\n  };\n\n  SeriesData.prototype.getRawDataItem = function (idx) {\n    return this._store.getRawDataItem(idx);\n  };\n  /**\n   * Get model of one data item.\n   */\n  // TODO: Type of data item\n\n\n  SeriesData.prototype.getItemModel = function (idx) {\n    var hostModel = this.hostModel;\n    var dataItem = this.getRawDataItem(idx);\n    return new Model(dataItem, hostModel, hostModel && hostModel.ecModel);\n  };\n  /**\n   * Create a data differ\n   */\n\n\n  SeriesData.prototype.diff = function (otherList) {\n    var thisList = this;\n    return new DataDiffer(otherList ? otherList.getStore().getIndices() : [], this.getStore().getIndices(), function (idx) {\n      return getId(otherList, idx);\n    }, function (idx) {\n      return getId(thisList, idx);\n    });\n  };\n  /**\n   * Get visual property.\n   */\n\n\n  SeriesData.prototype.getVisual = function (key) {\n    var visual = this._visual;\n    return visual && visual[key];\n  };\n\n  SeriesData.prototype.setVisual = function (kvObj, val) {\n    this._visual = this._visual || {};\n\n    if (isObject(kvObj)) {\n      zrUtil.extend(this._visual, kvObj);\n    } else {\n      this._visual[kvObj] = val;\n    }\n  };\n  /**\n   * Get visual property of single data item\n   */\n  // eslint-disable-next-line\n\n\n  SeriesData.prototype.getItemVisual = function (idx, key) {\n    var itemVisual = this._itemVisuals[idx];\n    var val = itemVisual && itemVisual[key];\n\n    if (val == null) {\n      // Use global visual property\n      return this.getVisual(key);\n    }\n\n    return val;\n  };\n  /**\n   * If exists visual property of single data item\n   */\n\n\n  SeriesData.prototype.hasItemVisual = function () {\n    return this._itemVisuals.length > 0;\n  };\n  /**\n   * Make sure itemVisual property is unique\n   */\n  // TODO: use key to save visual to reduce memory.\n\n\n  SeriesData.prototype.ensureUniqueItemVisual = function (idx, key) {\n    var itemVisuals = this._itemVisuals;\n    var itemVisual = itemVisuals[idx];\n\n    if (!itemVisual) {\n      itemVisual = itemVisuals[idx] = {};\n    }\n\n    var val = itemVisual[key];\n\n    if (val == null) {\n      val = this.getVisual(key); // TODO Performance?\n\n      if (zrUtil.isArray(val)) {\n        val = val.slice();\n      } else if (isObject(val)) {\n        val = zrUtil.extend({}, val);\n      }\n\n      itemVisual[key] = val;\n    }\n\n    return val;\n  }; // eslint-disable-next-line\n\n\n  SeriesData.prototype.setItemVisual = function (idx, key, value) {\n    var itemVisual = this._itemVisuals[idx] || {};\n    this._itemVisuals[idx] = itemVisual;\n\n    if (isObject(key)) {\n      zrUtil.extend(itemVisual, key);\n    } else {\n      itemVisual[key] = value;\n    }\n  };\n  /**\n   * Clear itemVisuals and list visual.\n   */\n\n\n  SeriesData.prototype.clearAllVisual = function () {\n    this._visual = {};\n    this._itemVisuals = [];\n  };\n\n  SeriesData.prototype.setLayout = function (key, val) {\n    isObject(key) ? zrUtil.extend(this._layout, key) : this._layout[key] = val;\n  };\n  /**\n   * Get layout property.\n   */\n\n\n  SeriesData.prototype.getLayout = function (key) {\n    return this._layout[key];\n  };\n  /**\n   * Get layout of single data item\n   */\n\n\n  SeriesData.prototype.getItemLayout = function (idx) {\n    return this._itemLayouts[idx];\n  };\n  /**\n   * Set layout of single data item\n   */\n\n\n  SeriesData.prototype.setItemLayout = function (idx, layout, merge) {\n    this._itemLayouts[idx] = merge ? zrUtil.extend(this._itemLayouts[idx] || {}, layout) : layout;\n  };\n  /**\n   * Clear all layout of single data item\n   */\n\n\n  SeriesData.prototype.clearItemLayouts = function () {\n    this._itemLayouts.length = 0;\n  };\n  /**\n   * Set graphic element relative to data. It can be set as null\n   */\n\n\n  SeriesData.prototype.setItemGraphicEl = function (idx, el) {\n    var seriesIndex = this.hostModel && this.hostModel.seriesIndex;\n    setCommonECData(seriesIndex, this.dataType, idx, el);\n    this._graphicEls[idx] = el;\n  };\n\n  SeriesData.prototype.getItemGraphicEl = function (idx) {\n    return this._graphicEls[idx];\n  };\n\n  SeriesData.prototype.eachItemGraphicEl = function (cb, context) {\n    zrUtil.each(this._graphicEls, function (el, idx) {\n      if (el) {\n        cb && cb.call(context, el, idx);\n      }\n    });\n  };\n  /**\n   * Shallow clone a new list except visual and layout properties, and graph elements.\n   * New list only change the indices.\n   */\n\n\n  SeriesData.prototype.cloneShallow = function (list) {\n    if (!list) {\n      list = new SeriesData(this._schema ? this._schema : map(this.dimensions, this._getDimInfo, this), this.hostModel);\n    }\n\n    transferProperties(list, this);\n    list._store = this._store;\n    return list;\n  };\n  /**\n   * Wrap some method to add more feature\n   */\n\n\n  SeriesData.prototype.wrapMethod = function (methodName, injectFunction) {\n    var originalMethod = this[methodName];\n\n    if (!zrUtil.isFunction(originalMethod)) {\n      return;\n    }\n\n    this.__wrappedMethods = this.__wrappedMethods || [];\n\n    this.__wrappedMethods.push(methodName);\n\n    this[methodName] = function () {\n      var res = originalMethod.apply(this, arguments);\n      return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));\n    };\n  }; // ----------------------------------------------------------\n  // A work around for internal method visiting private member.\n  // ----------------------------------------------------------\n\n\n  SeriesData.internalField = function () {\n    prepareInvertedIndex = function (data) {\n      var invertedIndicesMap = data._invertedIndicesMap;\n      zrUtil.each(invertedIndicesMap, function (invertedIndices, dim) {\n        var dimInfo = data._dimInfos[dim]; // Currently, only dimensions that has ordinalMeta can create inverted indices.\n\n        var ordinalMeta = dimInfo.ordinalMeta;\n        var store = data._store;\n\n        if (ordinalMeta) {\n          invertedIndices = invertedIndicesMap[dim] = new CtorInt32Array(ordinalMeta.categories.length); // The default value of TypedArray is 0. To avoid miss\n          // mapping to 0, we should set it as INDEX_NOT_FOUND.\n\n          for (var i = 0; i < invertedIndices.length; i++) {\n            invertedIndices[i] = INDEX_NOT_FOUND;\n          }\n\n          for (var i = 0; i < store.count(); i++) {\n            // Only support the case that all values are distinct.\n            invertedIndices[store.get(dimInfo.storeDimIndex, i)] = i;\n          }\n        }\n      });\n    };\n\n    getIdNameFromStore = function (data, dimIdx, idx) {\n      return convertOptionIdName(data._getCategory(dimIdx, idx), null);\n    };\n    /**\n     * @see the comment of `List['getId']`.\n     */\n\n\n    getId = function (data, rawIndex) {\n      var id = data._idList[rawIndex];\n\n      if (id == null && data._idDimIdx != null) {\n        id = getIdNameFromStore(data, data._idDimIdx, rawIndex);\n      }\n\n      if (id == null) {\n        id = ID_PREFIX + rawIndex;\n      }\n\n      return id;\n    };\n\n    normalizeDimensions = function (dimensions) {\n      if (!zrUtil.isArray(dimensions)) {\n        dimensions = dimensions != null ? [dimensions] : [];\n      }\n\n      return dimensions;\n    };\n    /**\n     * Data in excludeDimensions is copied, otherwise transfered.\n     */\n\n\n    cloneListForMapAndSample = function (original) {\n      var list = new SeriesData(original._schema ? original._schema : map(original.dimensions, original._getDimInfo, original), original.hostModel); // FIXME If needs stackedOn, value may already been stacked\n\n      transferProperties(list, original);\n      return list;\n    };\n\n    transferProperties = function (target, source) {\n      zrUtil.each(TRANSFERABLE_PROPERTIES.concat(source.__wrappedMethods || []), function (propName) {\n        if (source.hasOwnProperty(propName)) {\n          target[propName] = source[propName];\n        }\n      });\n      target.__wrappedMethods = source.__wrappedMethods;\n      zrUtil.each(CLONE_PROPERTIES, function (propName) {\n        target[propName] = zrUtil.clone(source[propName]);\n      });\n      target._calculationInfo = zrUtil.extend({}, source._calculationInfo);\n    };\n\n    makeIdFromName = function (data, idx) {\n      var nameList = data._nameList;\n      var idList = data._idList;\n      var nameDimIdx = data._nameDimIdx;\n      var idDimIdx = data._idDimIdx;\n      var name = nameList[idx];\n      var id = idList[idx];\n\n      if (name == null && nameDimIdx != null) {\n        nameList[idx] = name = getIdNameFromStore(data, nameDimIdx, idx);\n      }\n\n      if (id == null && idDimIdx != null) {\n        idList[idx] = id = getIdNameFromStore(data, idDimIdx, idx);\n      }\n\n      if (id == null && name != null) {\n        var nameRepeatCount = data._nameRepeatCount;\n        var nmCnt = nameRepeatCount[name] = (nameRepeatCount[name] || 0) + 1;\n        id = name;\n\n        if (nmCnt > 1) {\n          id += '__ec__' + nmCnt;\n        }\n\n        idList[idx] = id;\n      }\n    };\n  }();\n\n  return SeriesData;\n}();\n\nexport default SeriesData;","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport * as zrUtil from 'zrender/lib/core/util.js';\n\nvar SeriesDimensionDefine =\n/** @class */\nfunction () {\n  /**\n   * @param opt All of the fields will be shallow copied.\n   */\n  function SeriesDimensionDefine(opt) {\n    /**\n     * The format of `otherDims` is:\n     * ```js\n     * {\n     *     tooltip?: number\n     *     label?: number\n     *     itemName?: number\n     *     seriesName?: number\n     * }\n     * ```\n     *\n     * A `series.encode` can specified these fields:\n     * ```js\n     * encode: {\n     *     // \"3, 1, 5\" is the index of data dimension.\n     *     tooltip: [3, 1, 5],\n     *     label: [0, 3],\n     *     ...\n     * }\n     * ```\n     * `otherDims` is the parse result of the `series.encode` above, like:\n     * ```js\n     * // Suppose the index of this data dimension is `3`.\n     * this.otherDims = {\n     *     // `3` is at the index `0` of the `encode.tooltip`\n     *     tooltip: 0,\n     *     // `3` is at the index `1` of the `encode.label`\n     *     label: 1\n     * };\n     * ```\n     *\n     * This prop should never be `null`/`undefined` after initialized.\n     */\n    this.otherDims = {};\n\n    if (opt != null) {\n      zrUtil.extend(this, opt);\n    }\n  }\n\n  return SeriesDimensionDefine;\n}();\n\n;\nexport default SeriesDimensionDefine;"],"names":["prepareInvertedIndex","getId","getIdNameFromStore","normalizeDimensions","transferProperties","cloneListForMapAndSample","makeIdFromName","isObject","zrUtil","map","CtorInt32Array","Int32Array","Array","TRANSFERABLE_PROPERTIES","CLONE_PROPERTIES","SeriesData","dimensionsInput","hostModel","dimensions","this","type","_dimOmitted","_nameList","_idList","_visual","_layout","_itemVisuals","_itemLayouts","_graphicEls","_approximateExtent","_calculationInfo","hasItemOption","TRANSFERABLE_METHODS","CHANGABLE_METHODS","DOWNSAMPLE_METHODS","assignStoreDimIdx","isSeriesDataSchema","isDimensionOmitted","_schema","dimensionInfos","dimensionNames","invertedIndicesMap","needsHasOwn","emptyObj","i","length","dimInfoInput","dimensionInfo","SeriesDimensionDefine","name","dimensionName","coordDim","coordDimIndex","otherDims","push","createInvertedIndices","itemName","_nameDimIdx","itemId","_idDimIdx","storeDimIndex","_dimInfos","_initGetDimensionInfo","_invertedIndicesMap","dimIdxToName_1","_dimIdxToName","dimName","set","prototype","getDimension","dim","dimIdx","_recognizeDimIndex","get","sourceDimDef","getSourceDimension","getDimensionIndex","dimInfo","_getDimInfo","getSourceDimensionIndex","isNaN","_getStoreDimIndex","getDimensionInfo","hasOwnProperty","undefined","getDimensionsOnCoord","_dimSummary","dataDimsOnCoord","slice","mapDimension","idx","dimensionsSummary","encodeFirstDimNotExtra","dims","encode","mapDimensionsAll","getStore","_store","initData","data","nameList","dimValueGetter","store","_this","DataStore","provider","isSourceInstance","DefaultDataProvider","property","_nameRepeatCount","_doInit","count","summarizeDimensions","userOutput","appendData","range","appendValues","values","names","_a","start","end","shouldMakeIdFromName","_shouldMakeIdFromName","_updateOrdinalMeta","sourceIdx","ordinalMeta","collectOrdinalMeta","getProvider","getSource","sourceFormat","SOURCE_FORMAT_TYPED_ARRAY","fillStorage","idList","SOURCE_FORMAT_ORIGINAL","pure","sharedDataItem","dataItem","getItem","isDataItemOption","convertOptionIdName","id","getApproximateExtent","getDataExtent","setApproximateExtent","extent","getCalculationInfo","key","setCalculationInfo","value","getName","rawIndex","getRawIndex","_getCategory","ordinal","getOrdinalMeta","categories","getByRawIndex","rawIdx","getIndices","getSum","getMedian","getValues","hasValue","dataDimIndicesOnCoord","len","indexOfName","indexOfRawIndex","rawIndexOf","indicesOfNearest","maxDistance","each","cb","ctx","fCtx","dimIndices","filterSelf","filter","selectRange","innerRange","mapArray","result","apply","arguments","ctxCompat","list","modify","downSample","dimension","rate","sampleValue","sampleIndex","lttbDownSample","valueDimension","getRawDataItem","getItemModel","Model","ecModel","diff","otherList","thisList","DataDiffer","getVisual","visual","setVisual","kvObj","val","getItemVisual","itemVisual","hasItemVisual","ensureUniqueItemVisual","itemVisuals","setItemVisual","clearAllVisual","setLayout","getLayout","getItemLayout","setItemLayout","layout","merge","clearItemLayouts","setItemGraphicEl","el","seriesIndex","setCommonECData","dataType","getItemGraphicEl","eachItemGraphicEl","context","call","cloneShallow","wrapMethod","methodName","injectFunction","originalMethod","__wrappedMethods","res","concat","internalField","invertedIndices","original","target","source","propName","nameDimIdx","idDimIdx","nameRepeatCount","nmCnt","opt"],"sourceRoot":""}
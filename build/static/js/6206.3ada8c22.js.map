{"version":3,"file":"static/js/6206.3ada8c22.js","mappings":"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","sources":["../node_modules/echarts/lib/layout/barGrid.js","../node_modules/echarts/lib/layout/barPolar.js","../node_modules/echarts/lib/layout/points.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { each, defaults, keys } from 'zrender/lib/core/util.js';\nimport { parsePercent } from '../util/number.js';\nimport { isDimensionStacked } from '../data/helper/dataStackHelper.js';\nimport createRenderPlanner from '../chart/helper/createRenderPlanner.js';\nimport { createFloat32Array } from '../util/vendor.js';\nvar STACK_PREFIX = '__ec_stack_';\n\nfunction getSeriesStackId(seriesModel) {\n  return seriesModel.get('stack') || STACK_PREFIX + seriesModel.seriesIndex;\n}\n\nfunction getAxisKey(axis) {\n  return axis.dim + axis.index;\n}\n/**\n * @return {Object} {width, offset, offsetCenter} If axis.type is not 'category', return undefined.\n */\n\n\nexport function getLayoutOnAxis(opt) {\n  var params = [];\n  var baseAxis = opt.axis;\n  var axisKey = 'axis0';\n\n  if (baseAxis.type !== 'category') {\n    return;\n  }\n\n  var bandWidth = baseAxis.getBandWidth();\n\n  for (var i = 0; i < opt.count || 0; i++) {\n    params.push(defaults({\n      bandWidth: bandWidth,\n      axisKey: axisKey,\n      stackId: STACK_PREFIX + i\n    }, opt));\n  }\n\n  var widthAndOffsets = doCalBarWidthAndOffset(params);\n  var result = [];\n\n  for (var i = 0; i < opt.count; i++) {\n    var item = widthAndOffsets[axisKey][STACK_PREFIX + i];\n    item.offsetCenter = item.offset + item.width / 2;\n    result.push(item);\n  }\n\n  return result;\n}\nexport function prepareLayoutBarSeries(seriesType, ecModel) {\n  var seriesModels = [];\n  ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n    // Check series coordinate, do layout for cartesian2d only\n    if (isOnCartesian(seriesModel)) {\n      seriesModels.push(seriesModel);\n    }\n  });\n  return seriesModels;\n}\n/**\n * Map from (baseAxis.dim + '_' + baseAxis.index) to min gap of two adjacent\n * values.\n * This works for time axes, value axes, and log axes.\n * For a single time axis, return value is in the form like\n * {'x_0': [1000000]}.\n * The value of 1000000 is in milliseconds.\n */\n\nfunction getValueAxesMinGaps(barSeries) {\n  /**\n   * Map from axis.index to values.\n   * For a single time axis, axisValues is in the form like\n   * {'x_0': [1495555200000, 1495641600000, 1495728000000]}.\n   * Items in axisValues[x], e.g. 1495555200000, are time values of all\n   * series.\n   */\n  var axisValues = {};\n  each(barSeries, function (seriesModel) {\n    var cartesian = seriesModel.coordinateSystem;\n    var baseAxis = cartesian.getBaseAxis();\n\n    if (baseAxis.type !== 'time' && baseAxis.type !== 'value') {\n      return;\n    }\n\n    var data = seriesModel.getData();\n    var key = baseAxis.dim + '_' + baseAxis.index;\n    var dimIdx = data.getDimensionIndex(data.mapDimension(baseAxis.dim));\n    var store = data.getStore();\n\n    for (var i = 0, cnt = store.count(); i < cnt; ++i) {\n      var value = store.get(dimIdx, i);\n\n      if (!axisValues[key]) {\n        // No previous data for the axis\n        axisValues[key] = [value];\n      } else {\n        // No value in previous series\n        axisValues[key].push(value);\n      } // Ignore duplicated time values in the same axis\n\n    }\n  });\n  var axisMinGaps = {};\n\n  for (var key in axisValues) {\n    if (axisValues.hasOwnProperty(key)) {\n      var valuesInAxis = axisValues[key];\n\n      if (valuesInAxis) {\n        // Sort axis values into ascending order to calculate gaps\n        valuesInAxis.sort(function (a, b) {\n          return a - b;\n        });\n        var min = null;\n\n        for (var j = 1; j < valuesInAxis.length; ++j) {\n          var delta = valuesInAxis[j] - valuesInAxis[j - 1];\n\n          if (delta > 0) {\n            // Ignore 0 delta because they are of the same axis value\n            min = min === null ? delta : Math.min(min, delta);\n          }\n        } // Set to null if only have one data\n\n\n        axisMinGaps[key] = min;\n      }\n    }\n  }\n\n  return axisMinGaps;\n}\n\nexport function makeColumnLayout(barSeries) {\n  var axisMinGaps = getValueAxesMinGaps(barSeries);\n  var seriesInfoList = [];\n  each(barSeries, function (seriesModel) {\n    var cartesian = seriesModel.coordinateSystem;\n    var baseAxis = cartesian.getBaseAxis();\n    var axisExtent = baseAxis.getExtent();\n    var bandWidth;\n\n    if (baseAxis.type === 'category') {\n      bandWidth = baseAxis.getBandWidth();\n    } else if (baseAxis.type === 'value' || baseAxis.type === 'time') {\n      var key = baseAxis.dim + '_' + baseAxis.index;\n      var minGap = axisMinGaps[key];\n      var extentSpan = Math.abs(axisExtent[1] - axisExtent[0]);\n      var scale = baseAxis.scale.getExtent();\n      var scaleSpan = Math.abs(scale[1] - scale[0]);\n      bandWidth = minGap ? extentSpan / scaleSpan * minGap : extentSpan; // When there is only one data value\n    } else {\n      var data = seriesModel.getData();\n      bandWidth = Math.abs(axisExtent[1] - axisExtent[0]) / data.count();\n    }\n\n    var barWidth = parsePercent(seriesModel.get('barWidth'), bandWidth);\n    var barMaxWidth = parsePercent(seriesModel.get('barMaxWidth'), bandWidth);\n    var barMinWidth = parsePercent( // barMinWidth by default is 0.5 / 1 in cartesian. Because in value axis,\n    // the auto-calculated bar width might be less than 0.5 / 1.\n    seriesModel.get('barMinWidth') || (isInLargeMode(seriesModel) ? 0.5 : 1), bandWidth);\n    var barGap = seriesModel.get('barGap');\n    var barCategoryGap = seriesModel.get('barCategoryGap');\n    seriesInfoList.push({\n      bandWidth: bandWidth,\n      barWidth: barWidth,\n      barMaxWidth: barMaxWidth,\n      barMinWidth: barMinWidth,\n      barGap: barGap,\n      barCategoryGap: barCategoryGap,\n      axisKey: getAxisKey(baseAxis),\n      stackId: getSeriesStackId(seriesModel)\n    });\n  });\n  return doCalBarWidthAndOffset(seriesInfoList);\n}\n\nfunction doCalBarWidthAndOffset(seriesInfoList) {\n  // Columns info on each category axis. Key is cartesian name\n  var columnsMap = {};\n  each(seriesInfoList, function (seriesInfo, idx) {\n    var axisKey = seriesInfo.axisKey;\n    var bandWidth = seriesInfo.bandWidth;\n    var columnsOnAxis = columnsMap[axisKey] || {\n      bandWidth: bandWidth,\n      remainedWidth: bandWidth,\n      autoWidthCount: 0,\n      categoryGap: null,\n      gap: '20%',\n      stacks: {}\n    };\n    var stacks = columnsOnAxis.stacks;\n    columnsMap[axisKey] = columnsOnAxis;\n    var stackId = seriesInfo.stackId;\n\n    if (!stacks[stackId]) {\n      columnsOnAxis.autoWidthCount++;\n    }\n\n    stacks[stackId] = stacks[stackId] || {\n      width: 0,\n      maxWidth: 0\n    }; // Caution: In a single coordinate system, these barGrid attributes\n    // will be shared by series. Consider that they have default values,\n    // only the attributes set on the last series will work.\n    // Do not change this fact unless there will be a break change.\n\n    var barWidth = seriesInfo.barWidth;\n\n    if (barWidth && !stacks[stackId].width) {\n      // See #6312, do not restrict width.\n      stacks[stackId].width = barWidth;\n      barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);\n      columnsOnAxis.remainedWidth -= barWidth;\n    }\n\n    var barMaxWidth = seriesInfo.barMaxWidth;\n    barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);\n    var barMinWidth = seriesInfo.barMinWidth;\n    barMinWidth && (stacks[stackId].minWidth = barMinWidth);\n    var barGap = seriesInfo.barGap;\n    barGap != null && (columnsOnAxis.gap = barGap);\n    var barCategoryGap = seriesInfo.barCategoryGap;\n    barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);\n  });\n  var result = {};\n  each(columnsMap, function (columnsOnAxis, coordSysName) {\n    result[coordSysName] = {};\n    var stacks = columnsOnAxis.stacks;\n    var bandWidth = columnsOnAxis.bandWidth;\n    var categoryGapPercent = columnsOnAxis.categoryGap;\n\n    if (categoryGapPercent == null) {\n      var columnCount = keys(stacks).length; // More columns in one group\n      // the spaces between group is smaller. Or the column will be too thin.\n\n      categoryGapPercent = Math.max(35 - columnCount * 4, 15) + '%';\n    }\n\n    var categoryGap = parsePercent(categoryGapPercent, bandWidth);\n    var barGapPercent = parsePercent(columnsOnAxis.gap, 1);\n    var remainedWidth = columnsOnAxis.remainedWidth;\n    var autoWidthCount = columnsOnAxis.autoWidthCount;\n    var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n    autoWidth = Math.max(autoWidth, 0); // Find if any auto calculated bar exceeded maxBarWidth\n\n    each(stacks, function (column) {\n      var maxWidth = column.maxWidth;\n      var minWidth = column.minWidth;\n\n      if (!column.width) {\n        var finalWidth = autoWidth;\n\n        if (maxWidth && maxWidth < finalWidth) {\n          finalWidth = Math.min(maxWidth, remainedWidth);\n        } // `minWidth` has higher priority. `minWidth` decide that wheter the\n        // bar is able to be visible. So `minWidth` should not be restricted\n        // by `maxWidth` or `remainedWidth` (which is from `bandWidth`). In\n        // the extreme cases for `value` axis, bars are allowed to overlap\n        // with each other if `minWidth` specified.\n\n\n        if (minWidth && minWidth > finalWidth) {\n          finalWidth = minWidth;\n        }\n\n        if (finalWidth !== autoWidth) {\n          column.width = finalWidth;\n          remainedWidth -= finalWidth + barGapPercent * finalWidth;\n          autoWidthCount--;\n        }\n      } else {\n        // `barMinWidth/barMaxWidth` has higher priority than `barWidth`, as\n        // CSS does. Becuase barWidth can be a percent value, where\n        // `barMaxWidth` can be used to restrict the final width.\n        var finalWidth = column.width;\n\n        if (maxWidth) {\n          finalWidth = Math.min(finalWidth, maxWidth);\n        } // `minWidth` has higher priority, as described above\n\n\n        if (minWidth) {\n          finalWidth = Math.max(finalWidth, minWidth);\n        }\n\n        column.width = finalWidth;\n        remainedWidth -= finalWidth + barGapPercent * finalWidth;\n        autoWidthCount--;\n      }\n    }); // Recalculate width again\n\n    autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n    autoWidth = Math.max(autoWidth, 0);\n    var widthSum = 0;\n    var lastColumn;\n    each(stacks, function (column, idx) {\n      if (!column.width) {\n        column.width = autoWidth;\n      }\n\n      lastColumn = column;\n      widthSum += column.width * (1 + barGapPercent);\n    });\n\n    if (lastColumn) {\n      widthSum -= lastColumn.width * barGapPercent;\n    }\n\n    var offset = -widthSum / 2;\n    each(stacks, function (column, stackId) {\n      result[coordSysName][stackId] = result[coordSysName][stackId] || {\n        bandWidth: bandWidth,\n        offset: offset,\n        width: column.width\n      };\n      offset += column.width * (1 + barGapPercent);\n    });\n  });\n  return result;\n}\n\nfunction retrieveColumnLayout(barWidthAndOffset, axis, seriesModel) {\n  if (barWidthAndOffset && axis) {\n    var result = barWidthAndOffset[getAxisKey(axis)];\n\n    if (result != null && seriesModel != null) {\n      return result[getSeriesStackId(seriesModel)];\n    }\n\n    return result;\n  }\n}\n\nexport { retrieveColumnLayout };\nexport function layout(seriesType, ecModel) {\n  var seriesModels = prepareLayoutBarSeries(seriesType, ecModel);\n  var barWidthAndOffset = makeColumnLayout(seriesModels);\n  each(seriesModels, function (seriesModel) {\n    var data = seriesModel.getData();\n    var cartesian = seriesModel.coordinateSystem;\n    var baseAxis = cartesian.getBaseAxis();\n    var stackId = getSeriesStackId(seriesModel);\n    var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];\n    var columnOffset = columnLayoutInfo.offset;\n    var columnWidth = columnLayoutInfo.width;\n    data.setLayout({\n      bandWidth: columnLayoutInfo.bandWidth,\n      offset: columnOffset,\n      size: columnWidth\n    });\n  });\n} // TODO: Do not support stack in large mode yet.\n\nexport function createProgressiveLayout(seriesType) {\n  return {\n    seriesType: seriesType,\n    plan: createRenderPlanner(),\n    reset: function (seriesModel) {\n      if (!isOnCartesian(seriesModel)) {\n        return;\n      }\n\n      var data = seriesModel.getData();\n      var cartesian = seriesModel.coordinateSystem;\n      var baseAxis = cartesian.getBaseAxis();\n      var valueAxis = cartesian.getOtherAxis(baseAxis);\n      var valueDimIdx = data.getDimensionIndex(data.mapDimension(valueAxis.dim));\n      var baseDimIdx = data.getDimensionIndex(data.mapDimension(baseAxis.dim));\n      var drawBackground = seriesModel.get('showBackground', true);\n      var valueDim = data.mapDimension(valueAxis.dim);\n      var stackResultDim = data.getCalculationInfo('stackResultDimension');\n      var stacked = isDimensionStacked(data, valueDim) && !!data.getCalculationInfo('stackedOnSeries');\n      var isValueAxisH = valueAxis.isHorizontal();\n      var valueAxisStart = getValueAxisStart(baseAxis, valueAxis);\n      var isLarge = isInLargeMode(seriesModel);\n      var barMinHeight = seriesModel.get('barMinHeight') || 0;\n      var stackedDimIdx = stackResultDim && data.getDimensionIndex(stackResultDim); // Layout info.\n\n      var columnWidth = data.getLayout('size');\n      var columnOffset = data.getLayout('offset');\n      return {\n        progress: function (params, data) {\n          var count = params.count;\n          var largePoints = isLarge && createFloat32Array(count * 3);\n          var largeBackgroundPoints = isLarge && drawBackground && createFloat32Array(count * 3);\n          var largeDataIndices = isLarge && createFloat32Array(count);\n          var coordLayout = cartesian.master.getRect();\n          var bgSize = isValueAxisH ? coordLayout.width : coordLayout.height;\n          var dataIndex;\n          var store = data.getStore();\n          var idxOffset = 0;\n\n          while ((dataIndex = params.next()) != null) {\n            var value = store.get(stacked ? stackedDimIdx : valueDimIdx, dataIndex);\n            var baseValue = store.get(baseDimIdx, dataIndex);\n            var baseCoord = valueAxisStart;\n            var startValue = void 0; // Because of the barMinHeight, we can not use the value in\n            // stackResultDimension directly.\n\n            if (stacked) {\n              startValue = +value - store.get(valueDimIdx, dataIndex);\n            }\n\n            var x = void 0;\n            var y = void 0;\n            var width = void 0;\n            var height = void 0;\n\n            if (isValueAxisH) {\n              var coord = cartesian.dataToPoint([value, baseValue]);\n\n              if (stacked) {\n                var startCoord = cartesian.dataToPoint([startValue, baseValue]);\n                baseCoord = startCoord[0];\n              }\n\n              x = baseCoord;\n              y = coord[1] + columnOffset;\n              width = coord[0] - baseCoord;\n              height = columnWidth;\n\n              if (Math.abs(width) < barMinHeight) {\n                width = (width < 0 ? -1 : 1) * barMinHeight;\n              }\n            } else {\n              var coord = cartesian.dataToPoint([baseValue, value]);\n\n              if (stacked) {\n                var startCoord = cartesian.dataToPoint([baseValue, startValue]);\n                baseCoord = startCoord[1];\n              }\n\n              x = coord[0] + columnOffset;\n              y = baseCoord;\n              width = columnWidth;\n              height = coord[1] - baseCoord;\n\n              if (Math.abs(height) < barMinHeight) {\n                // Include zero to has a positive bar\n                height = (height <= 0 ? -1 : 1) * barMinHeight;\n              }\n            }\n\n            if (!isLarge) {\n              data.setItemLayout(dataIndex, {\n                x: x,\n                y: y,\n                width: width,\n                height: height\n              });\n            } else {\n              largePoints[idxOffset] = x;\n              largePoints[idxOffset + 1] = y;\n              largePoints[idxOffset + 2] = isValueAxisH ? width : height;\n\n              if (largeBackgroundPoints) {\n                largeBackgroundPoints[idxOffset] = isValueAxisH ? coordLayout.x : x;\n                largeBackgroundPoints[idxOffset + 1] = isValueAxisH ? y : coordLayout.y;\n                largeBackgroundPoints[idxOffset + 2] = bgSize;\n              }\n\n              largeDataIndices[dataIndex] = dataIndex;\n            }\n\n            idxOffset += 3;\n          }\n\n          if (isLarge) {\n            data.setLayout({\n              largePoints: largePoints,\n              largeDataIndices: largeDataIndices,\n              largeBackgroundPoints: largeBackgroundPoints,\n              valueAxisHorizontal: isValueAxisH\n            });\n          }\n        }\n      };\n    }\n  };\n}\n\nfunction isOnCartesian(seriesModel) {\n  return seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === 'cartesian2d';\n}\n\nfunction isInLargeMode(seriesModel) {\n  return seriesModel.pipelineContext && seriesModel.pipelineContext.large;\n} // See cases in `test/bar-start.html` and `#7412`, `#8747`.\n\n\nfunction getValueAxisStart(baseAxis, valueAxis) {\n  return valueAxis.toGlobalCoord(valueAxis.dataToCoord(valueAxis.type === 'log' ? 1 : 0));\n}","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport * as zrUtil from 'zrender/lib/core/util.js';\nimport { parsePercent } from '../util/number.js';\nimport { isDimensionStacked } from '../data/helper/dataStackHelper.js';\n\nfunction getSeriesStackId(seriesModel) {\n  return seriesModel.get('stack') || '__ec_stack_' + seriesModel.seriesIndex;\n}\n\nfunction getAxisKey(polar, axis) {\n  return axis.dim + polar.model.componentIndex;\n}\n\nfunction barLayoutPolar(seriesType, ecModel, api) {\n  var lastStackCoords = {};\n  var barWidthAndOffset = calRadialBar(zrUtil.filter(ecModel.getSeriesByType(seriesType), function (seriesModel) {\n    return !ecModel.isSeriesFiltered(seriesModel) && seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === 'polar';\n  }));\n  ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n    // Check series coordinate, do layout for polar only\n    if (seriesModel.coordinateSystem.type !== 'polar') {\n      return;\n    }\n\n    var data = seriesModel.getData();\n    var polar = seriesModel.coordinateSystem;\n    var baseAxis = polar.getBaseAxis();\n    var axisKey = getAxisKey(polar, baseAxis);\n    var stackId = getSeriesStackId(seriesModel);\n    var columnLayoutInfo = barWidthAndOffset[axisKey][stackId];\n    var columnOffset = columnLayoutInfo.offset;\n    var columnWidth = columnLayoutInfo.width;\n    var valueAxis = polar.getOtherAxis(baseAxis);\n    var cx = seriesModel.coordinateSystem.cx;\n    var cy = seriesModel.coordinateSystem.cy;\n    var barMinHeight = seriesModel.get('barMinHeight') || 0;\n    var barMinAngle = seriesModel.get('barMinAngle') || 0;\n    lastStackCoords[stackId] = lastStackCoords[stackId] || [];\n    var valueDim = data.mapDimension(valueAxis.dim);\n    var baseDim = data.mapDimension(baseAxis.dim);\n    var stacked = isDimensionStacked(data, valueDim\n    /*, baseDim*/\n    );\n    var clampLayout = baseAxis.dim !== 'radius' || !seriesModel.get('roundCap', true);\n    var valueAxisStart = valueAxis.dataToCoord(0);\n\n    for (var idx = 0, len = data.count(); idx < len; idx++) {\n      var value = data.get(valueDim, idx);\n      var baseValue = data.get(baseDim, idx);\n      var sign = value >= 0 ? 'p' : 'n';\n      var baseCoord = valueAxisStart; // Because of the barMinHeight, we can not use the value in\n      // stackResultDimension directly.\n      // Only ordinal axis can be stacked.\n\n      if (stacked) {\n        if (!lastStackCoords[stackId][baseValue]) {\n          lastStackCoords[stackId][baseValue] = {\n            p: valueAxisStart,\n            n: valueAxisStart // Negative stack\n\n          };\n        } // Should also consider #4243\n\n\n        baseCoord = lastStackCoords[stackId][baseValue][sign];\n      }\n\n      var r0 = void 0;\n      var r = void 0;\n      var startAngle = void 0;\n      var endAngle = void 0; // radial sector\n\n      if (valueAxis.dim === 'radius') {\n        var radiusSpan = valueAxis.dataToCoord(value) - valueAxisStart;\n        var angle = baseAxis.dataToCoord(baseValue);\n\n        if (Math.abs(radiusSpan) < barMinHeight) {\n          radiusSpan = (radiusSpan < 0 ? -1 : 1) * barMinHeight;\n        }\n\n        r0 = baseCoord;\n        r = baseCoord + radiusSpan;\n        startAngle = angle - columnOffset;\n        endAngle = startAngle - columnWidth;\n        stacked && (lastStackCoords[stackId][baseValue][sign] = r);\n      } // tangential sector\n      else {\n          var angleSpan = valueAxis.dataToCoord(value, clampLayout) - valueAxisStart;\n          var radius = baseAxis.dataToCoord(baseValue);\n\n          if (Math.abs(angleSpan) < barMinAngle) {\n            angleSpan = (angleSpan < 0 ? -1 : 1) * barMinAngle;\n          }\n\n          r0 = radius + columnOffset;\n          r = r0 + columnWidth;\n          startAngle = baseCoord;\n          endAngle = baseCoord + angleSpan; // if the previous stack is at the end of the ring,\n          // add a round to differentiate it from origin\n          // let extent = angleAxis.getExtent();\n          // let stackCoord = angle;\n          // if (stackCoord === extent[0] && value > 0) {\n          //     stackCoord = extent[1];\n          // }\n          // else if (stackCoord === extent[1] && value < 0) {\n          //     stackCoord = extent[0];\n          // }\n\n          stacked && (lastStackCoords[stackId][baseValue][sign] = endAngle);\n        }\n\n      data.setItemLayout(idx, {\n        cx: cx,\n        cy: cy,\n        r0: r0,\n        r: r,\n        // Consider that positive angle is anti-clockwise,\n        // while positive radian of sector is clockwise\n        startAngle: -startAngle * Math.PI / 180,\n        endAngle: -endAngle * Math.PI / 180,\n\n        /**\n         * Keep the same logic with bar in catesion: use end value to\n         * control direction. Notice that if clockwise is true (by\n         * default), the sector will always draw clockwisely, no matter\n         * whether endAngle is greater or less than startAngle.\n         */\n        clockwise: startAngle >= endAngle\n      });\n    }\n  });\n}\n/**\n * Calculate bar width and offset for radial bar charts\n */\n\n\nfunction calRadialBar(barSeries) {\n  // Columns info on each category axis. Key is polar name\n  var columnsMap = {};\n  zrUtil.each(barSeries, function (seriesModel, idx) {\n    var data = seriesModel.getData();\n    var polar = seriesModel.coordinateSystem;\n    var baseAxis = polar.getBaseAxis();\n    var axisKey = getAxisKey(polar, baseAxis);\n    var axisExtent = baseAxis.getExtent();\n    var bandWidth = baseAxis.type === 'category' ? baseAxis.getBandWidth() : Math.abs(axisExtent[1] - axisExtent[0]) / data.count();\n    var columnsOnAxis = columnsMap[axisKey] || {\n      bandWidth: bandWidth,\n      remainedWidth: bandWidth,\n      autoWidthCount: 0,\n      categoryGap: '20%',\n      gap: '30%',\n      stacks: {}\n    };\n    var stacks = columnsOnAxis.stacks;\n    columnsMap[axisKey] = columnsOnAxis;\n    var stackId = getSeriesStackId(seriesModel);\n\n    if (!stacks[stackId]) {\n      columnsOnAxis.autoWidthCount++;\n    }\n\n    stacks[stackId] = stacks[stackId] || {\n      width: 0,\n      maxWidth: 0\n    };\n    var barWidth = parsePercent(seriesModel.get('barWidth'), bandWidth);\n    var barMaxWidth = parsePercent(seriesModel.get('barMaxWidth'), bandWidth);\n    var barGap = seriesModel.get('barGap');\n    var barCategoryGap = seriesModel.get('barCategoryGap');\n\n    if (barWidth && !stacks[stackId].width) {\n      barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);\n      stacks[stackId].width = barWidth;\n      columnsOnAxis.remainedWidth -= barWidth;\n    }\n\n    barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);\n    barGap != null && (columnsOnAxis.gap = barGap);\n    barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);\n  });\n  var result = {};\n  zrUtil.each(columnsMap, function (columnsOnAxis, coordSysName) {\n    result[coordSysName] = {};\n    var stacks = columnsOnAxis.stacks;\n    var bandWidth = columnsOnAxis.bandWidth;\n    var categoryGap = parsePercent(columnsOnAxis.categoryGap, bandWidth);\n    var barGapPercent = parsePercent(columnsOnAxis.gap, 1);\n    var remainedWidth = columnsOnAxis.remainedWidth;\n    var autoWidthCount = columnsOnAxis.autoWidthCount;\n    var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n    autoWidth = Math.max(autoWidth, 0); // Find if any auto calculated bar exceeded maxBarWidth\n\n    zrUtil.each(stacks, function (column, stack) {\n      var maxWidth = column.maxWidth;\n\n      if (maxWidth && maxWidth < autoWidth) {\n        maxWidth = Math.min(maxWidth, remainedWidth);\n\n        if (column.width) {\n          maxWidth = Math.min(maxWidth, column.width);\n        }\n\n        remainedWidth -= maxWidth;\n        column.width = maxWidth;\n        autoWidthCount--;\n      }\n    }); // Recalculate width again\n\n    autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n    autoWidth = Math.max(autoWidth, 0);\n    var widthSum = 0;\n    var lastColumn;\n    zrUtil.each(stacks, function (column, idx) {\n      if (!column.width) {\n        column.width = autoWidth;\n      }\n\n      lastColumn = column;\n      widthSum += column.width * (1 + barGapPercent);\n    });\n\n    if (lastColumn) {\n      widthSum -= lastColumn.width * barGapPercent;\n    }\n\n    var offset = -widthSum / 2;\n    zrUtil.each(stacks, function (column, stackId) {\n      result[coordSysName][stackId] = result[coordSysName][stackId] || {\n        offset: offset,\n        width: column.width\n      };\n      offset += column.width * (1 + barGapPercent);\n    });\n  });\n  return result;\n}\n\nexport default barLayoutPolar;","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { map } from 'zrender/lib/core/util.js';\nimport createRenderPlanner from '../chart/helper/createRenderPlanner.js';\nimport { isDimensionStacked } from '../data/helper/dataStackHelper.js';\nimport { createFloat32Array } from '../util/vendor.js';\nexport default function pointsLayout(seriesType, forceStoreInTypedArray) {\n  return {\n    seriesType: seriesType,\n    plan: createRenderPlanner(),\n    reset: function (seriesModel) {\n      var data = seriesModel.getData();\n      var coordSys = seriesModel.coordinateSystem;\n      var pipelineContext = seriesModel.pipelineContext;\n      var useTypedArray = forceStoreInTypedArray || pipelineContext.large;\n\n      if (!coordSys) {\n        return;\n      }\n\n      var dims = map(coordSys.dimensions, function (dim) {\n        return data.mapDimension(dim);\n      }).slice(0, 2);\n      var dimLen = dims.length;\n      var stackResultDim = data.getCalculationInfo('stackResultDimension');\n\n      if (isDimensionStacked(data, dims[0])) {\n        dims[0] = stackResultDim;\n      }\n\n      if (isDimensionStacked(data, dims[1])) {\n        dims[1] = stackResultDim;\n      }\n\n      var store = data.getStore();\n      var dimIdx0 = data.getDimensionIndex(dims[0]);\n      var dimIdx1 = data.getDimensionIndex(dims[1]);\n      return dimLen && {\n        progress: function (params, data) {\n          var segCount = params.end - params.start;\n          var points = useTypedArray && createFloat32Array(segCount * dimLen);\n          var tmpIn = [];\n          var tmpOut = [];\n\n          for (var i = params.start, offset = 0; i < params.end; i++) {\n            var point = void 0;\n\n            if (dimLen === 1) {\n              var x = store.get(dimIdx0, i); // NOTE: Make sure the second parameter is null to use default strategy.\n\n              point = coordSys.dataToPoint(x, null, tmpOut);\n            } else {\n              tmpIn[0] = store.get(dimIdx0, i);\n              tmpIn[1] = store.get(dimIdx1, i); // Let coordinate system to handle the NaN data.\n\n              point = coordSys.dataToPoint(tmpIn, null, tmpOut);\n            }\n\n            if (useTypedArray) {\n              points[offset++] = point[0];\n              points[offset++] = point[1];\n            } else {\n              data.setItemLayout(i, point.slice());\n            }\n          }\n\n          useTypedArray && data.setLayout('points', points);\n        }\n      };\n    }\n  };\n}\n;"],"names":["STACK_PREFIX","getSeriesStackId","seriesModel","get","seriesIndex","getAxisKey","axis","dim","index","getLayoutOnAxis","opt","params","baseAxis","type","bandWidth","getBandWidth","i","count","push","defaults","axisKey","stackId","widthAndOffsets","doCalBarWidthAndOffset","result","item","offsetCenter","offset","width","prepareLayoutBarSeries","seriesType","ecModel","seriesModels","eachSeriesByType","isOnCartesian","makeColumnLayout","barSeries","axisMinGaps","axisValues","each","coordinateSystem","getBaseAxis","data","getData","key","dimIdx","getDimensionIndex","mapDimension","store","getStore","cnt","value","hasOwnProperty","valuesInAxis","sort","a","b","min","j","length","delta","Math","getValueAxesMinGaps","seriesInfoList","axisExtent","getExtent","minGap","extentSpan","abs","scale","scaleSpan","barWidth","parsePercent","barMaxWidth","barMinWidth","isInLargeMode","barGap","barCategoryGap","columnsMap","seriesInfo","idx","columnsOnAxis","remainedWidth","autoWidthCount","categoryGap","gap","stacks","maxWidth","minWidth","coordSysName","categoryGapPercent","columnCount","keys","max","barGapPercent","autoWidth","column","finalWidth","lastColumn","widthSum","retrieveColumnLayout","barWidthAndOffset","layout","columnLayoutInfo","columnOffset","columnWidth","setLayout","size","createProgressiveLayout","plan","createRenderPlanner","reset","cartesian","valueAxis","getOtherAxis","valueDimIdx","baseDimIdx","drawBackground","valueDim","stackResultDim","getCalculationInfo","stacked","isDimensionStacked","isValueAxisH","isHorizontal","valueAxisStart","toGlobalCoord","dataToCoord","getValueAxisStart","isLarge","barMinHeight","stackedDimIdx","getLayout","progress","dataIndex","largePoints","createFloat32Array","largeBackgroundPoints","largeDataIndices","coordLayout","master","getRect","bgSize","height","idxOffset","next","baseValue","baseCoord","startValue","x","y","coord","dataToPoint","setItemLayout","valueAxisHorizontal","pipelineContext","large","polar","model","componentIndex","api","lastStackCoords","zrUtil","stack","calRadialBar","getSeriesByType","isSeriesFiltered","cx","cy","barMinAngle","baseDim","clampLayout","len","sign","p","n","r0","r","startAngle","endAngle","radiusSpan","angle","angleSpan","radius","PI","clockwise","pointsLayout","forceStoreInTypedArray","coordSys","useTypedArray","dims","map","dimensions","slice","dimLen","dimIdx0","dimIdx1","segCount","end","start","points","tmpIn","tmpOut","point"],"sourceRoot":""}
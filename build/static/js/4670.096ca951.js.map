{"version":3,"file":"static/js/4670.096ca951.js","mappings":"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","sources":["../node_modules/echarts/lib/component/axis/AngleAxisView.js","../node_modules/echarts/lib/component/axis/AxisBuilder.js","../node_modules/echarts/lib/component/axis/AxisView.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\";\nimport * as zrUtil from 'zrender/lib/core/util.js';\nimport * as graphic from '../../util/graphic.js';\nimport { createTextStyle } from '../../label/labelStyle.js';\nimport Model from '../../model/Model.js';\nimport AxisView from './AxisView.js';\nimport AxisBuilder from './AxisBuilder.js';\nimport { getECData } from '../../util/innerStore.js';\nvar elementList = ['axisLine', 'axisLabel', 'axisTick', 'minorTick', 'splitLine', 'minorSplitLine', 'splitArea'];\n\nfunction getAxisLineShape(polar, rExtent, angle) {\n  rExtent[1] > rExtent[0] && (rExtent = rExtent.slice().reverse());\n  var start = polar.coordToPoint([rExtent[0], angle]);\n  var end = polar.coordToPoint([rExtent[1], angle]);\n  return {\n    x1: start[0],\n    y1: start[1],\n    x2: end[0],\n    y2: end[1]\n  };\n}\n\nfunction getRadiusIdx(polar) {\n  var radiusAxis = polar.getRadiusAxis();\n  return radiusAxis.inverse ? 0 : 1;\n} // Remove the last tick which will overlap the first tick\n\n\nfunction fixAngleOverlap(list) {\n  var firstItem = list[0];\n  var lastItem = list[list.length - 1];\n\n  if (firstItem && lastItem && Math.abs(Math.abs(firstItem.coord - lastItem.coord) - 360) < 1e-4) {\n    list.pop();\n  }\n}\n\nvar AngleAxisView =\n/** @class */\nfunction (_super) {\n  __extends(AngleAxisView, _super);\n\n  function AngleAxisView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = AngleAxisView.type;\n    _this.axisPointerClass = 'PolarAxisPointer';\n    return _this;\n  }\n\n  AngleAxisView.prototype.render = function (angleAxisModel, ecModel) {\n    this.group.removeAll();\n\n    if (!angleAxisModel.get('show')) {\n      return;\n    }\n\n    var angleAxis = angleAxisModel.axis;\n    var polar = angleAxis.polar;\n    var radiusExtent = polar.getRadiusAxis().getExtent();\n    var ticksAngles = angleAxis.getTicksCoords();\n    var minorTickAngles = angleAxis.getMinorTicksCoords();\n    var labels = zrUtil.map(angleAxis.getViewLabels(), function (labelItem) {\n      labelItem = zrUtil.clone(labelItem);\n      var scale = angleAxis.scale;\n      var tickValue = scale.type === 'ordinal' ? scale.getRawOrdinalNumber(labelItem.tickValue) : labelItem.tickValue;\n      labelItem.coord = angleAxis.dataToCoord(tickValue);\n      return labelItem;\n    });\n    fixAngleOverlap(labels);\n    fixAngleOverlap(ticksAngles);\n    zrUtil.each(elementList, function (name) {\n      if (angleAxisModel.get([name, 'show']) && (!angleAxis.scale.isBlank() || name === 'axisLine')) {\n        angelAxisElementsBuilders[name](this.group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent, labels);\n      }\n    }, this);\n  };\n\n  AngleAxisView.type = 'angleAxis';\n  return AngleAxisView;\n}(AxisView);\n\nvar angelAxisElementsBuilders = {\n  axisLine: function (group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {\n    var lineStyleModel = angleAxisModel.getModel(['axisLine', 'lineStyle']); // extent id of the axis radius (r0 and r)\n\n    var rId = getRadiusIdx(polar);\n    var r0Id = rId ? 0 : 1;\n    var shape;\n\n    if (radiusExtent[r0Id] === 0) {\n      shape = new graphic.Circle({\n        shape: {\n          cx: polar.cx,\n          cy: polar.cy,\n          r: radiusExtent[rId]\n        },\n        style: lineStyleModel.getLineStyle(),\n        z2: 1,\n        silent: true\n      });\n    } else {\n      shape = new graphic.Ring({\n        shape: {\n          cx: polar.cx,\n          cy: polar.cy,\n          r: radiusExtent[rId],\n          r0: radiusExtent[r0Id]\n        },\n        style: lineStyleModel.getLineStyle(),\n        z2: 1,\n        silent: true\n      });\n    }\n\n    shape.style.fill = null;\n    group.add(shape);\n  },\n  axisTick: function (group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {\n    var tickModel = angleAxisModel.getModel('axisTick');\n    var tickLen = (tickModel.get('inside') ? -1 : 1) * tickModel.get('length');\n    var radius = radiusExtent[getRadiusIdx(polar)];\n    var lines = zrUtil.map(ticksAngles, function (tickAngleItem) {\n      return new graphic.Line({\n        shape: getAxisLineShape(polar, [radius, radius + tickLen], tickAngleItem.coord)\n      });\n    });\n    group.add(graphic.mergePath(lines, {\n      style: zrUtil.defaults(tickModel.getModel('lineStyle').getLineStyle(), {\n        stroke: angleAxisModel.get(['axisLine', 'lineStyle', 'color'])\n      })\n    }));\n  },\n  minorTick: function (group, angleAxisModel, polar, tickAngles, minorTickAngles, radiusExtent) {\n    if (!minorTickAngles.length) {\n      return;\n    }\n\n    var tickModel = angleAxisModel.getModel('axisTick');\n    var minorTickModel = angleAxisModel.getModel('minorTick');\n    var tickLen = (tickModel.get('inside') ? -1 : 1) * minorTickModel.get('length');\n    var radius = radiusExtent[getRadiusIdx(polar)];\n    var lines = [];\n\n    for (var i = 0; i < minorTickAngles.length; i++) {\n      for (var k = 0; k < minorTickAngles[i].length; k++) {\n        lines.push(new graphic.Line({\n          shape: getAxisLineShape(polar, [radius, radius + tickLen], minorTickAngles[i][k].coord)\n        }));\n      }\n    }\n\n    group.add(graphic.mergePath(lines, {\n      style: zrUtil.defaults(minorTickModel.getModel('lineStyle').getLineStyle(), zrUtil.defaults(tickModel.getLineStyle(), {\n        stroke: angleAxisModel.get(['axisLine', 'lineStyle', 'color'])\n      }))\n    }));\n  },\n  axisLabel: function (group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent, labels) {\n    var rawCategoryData = angleAxisModel.getCategories(true);\n    var commonLabelModel = angleAxisModel.getModel('axisLabel');\n    var labelMargin = commonLabelModel.get('margin');\n    var triggerEvent = angleAxisModel.get('triggerEvent'); // Use length of ticksAngles because it may remove the last tick to avoid overlapping\n\n    zrUtil.each(labels, function (labelItem, idx) {\n      var labelModel = commonLabelModel;\n      var tickValue = labelItem.tickValue;\n      var r = radiusExtent[getRadiusIdx(polar)];\n      var p = polar.coordToPoint([r + labelMargin, labelItem.coord]);\n      var cx = polar.cx;\n      var cy = polar.cy;\n      var labelTextAlign = Math.abs(p[0] - cx) / r < 0.3 ? 'center' : p[0] > cx ? 'left' : 'right';\n      var labelTextVerticalAlign = Math.abs(p[1] - cy) / r < 0.3 ? 'middle' : p[1] > cy ? 'top' : 'bottom';\n\n      if (rawCategoryData && rawCategoryData[tickValue]) {\n        var rawCategoryItem = rawCategoryData[tickValue];\n\n        if (zrUtil.isObject(rawCategoryItem) && rawCategoryItem.textStyle) {\n          labelModel = new Model(rawCategoryItem.textStyle, commonLabelModel, commonLabelModel.ecModel);\n        }\n      }\n\n      var textEl = new graphic.Text({\n        silent: AxisBuilder.isLabelSilent(angleAxisModel),\n        style: createTextStyle(labelModel, {\n          x: p[0],\n          y: p[1],\n          fill: labelModel.getTextColor() || angleAxisModel.get(['axisLine', 'lineStyle', 'color']),\n          text: labelItem.formattedLabel,\n          align: labelTextAlign,\n          verticalAlign: labelTextVerticalAlign\n        })\n      });\n      group.add(textEl); // Pack data for mouse event\n\n      if (triggerEvent) {\n        var eventData = AxisBuilder.makeAxisEventDataBase(angleAxisModel);\n        eventData.targetType = 'axisLabel';\n        eventData.value = labelItem.rawLabel;\n        getECData(textEl).eventData = eventData;\n      }\n    }, this);\n  },\n  splitLine: function (group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {\n    var splitLineModel = angleAxisModel.getModel('splitLine');\n    var lineStyleModel = splitLineModel.getModel('lineStyle');\n    var lineColors = lineStyleModel.get('color');\n    var lineCount = 0;\n    lineColors = lineColors instanceof Array ? lineColors : [lineColors];\n    var splitLines = [];\n\n    for (var i = 0; i < ticksAngles.length; i++) {\n      var colorIndex = lineCount++ % lineColors.length;\n      splitLines[colorIndex] = splitLines[colorIndex] || [];\n      splitLines[colorIndex].push(new graphic.Line({\n        shape: getAxisLineShape(polar, radiusExtent, ticksAngles[i].coord)\n      }));\n    } // Simple optimization\n    // Batching the lines if color are the same\n\n\n    for (var i = 0; i < splitLines.length; i++) {\n      group.add(graphic.mergePath(splitLines[i], {\n        style: zrUtil.defaults({\n          stroke: lineColors[i % lineColors.length]\n        }, lineStyleModel.getLineStyle()),\n        silent: true,\n        z: angleAxisModel.get('z')\n      }));\n    }\n  },\n  minorSplitLine: function (group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {\n    if (!minorTickAngles.length) {\n      return;\n    }\n\n    var minorSplitLineModel = angleAxisModel.getModel('minorSplitLine');\n    var lineStyleModel = minorSplitLineModel.getModel('lineStyle');\n    var lines = [];\n\n    for (var i = 0; i < minorTickAngles.length; i++) {\n      for (var k = 0; k < minorTickAngles[i].length; k++) {\n        lines.push(new graphic.Line({\n          shape: getAxisLineShape(polar, radiusExtent, minorTickAngles[i][k].coord)\n        }));\n      }\n    }\n\n    group.add(graphic.mergePath(lines, {\n      style: lineStyleModel.getLineStyle(),\n      silent: true,\n      z: angleAxisModel.get('z')\n    }));\n  },\n  splitArea: function (group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {\n    if (!ticksAngles.length) {\n      return;\n    }\n\n    var splitAreaModel = angleAxisModel.getModel('splitArea');\n    var areaStyleModel = splitAreaModel.getModel('areaStyle');\n    var areaColors = areaStyleModel.get('color');\n    var lineCount = 0;\n    areaColors = areaColors instanceof Array ? areaColors : [areaColors];\n    var splitAreas = [];\n    var RADIAN = Math.PI / 180;\n    var prevAngle = -ticksAngles[0].coord * RADIAN;\n    var r0 = Math.min(radiusExtent[0], radiusExtent[1]);\n    var r1 = Math.max(radiusExtent[0], radiusExtent[1]);\n    var clockwise = angleAxisModel.get('clockwise');\n\n    for (var i = 1, len = ticksAngles.length; i <= len; i++) {\n      var coord = i === len ? ticksAngles[0].coord : ticksAngles[i].coord;\n      var colorIndex = lineCount++ % areaColors.length;\n      splitAreas[colorIndex] = splitAreas[colorIndex] || [];\n      splitAreas[colorIndex].push(new graphic.Sector({\n        shape: {\n          cx: polar.cx,\n          cy: polar.cy,\n          r0: r0,\n          r: r1,\n          startAngle: prevAngle,\n          endAngle: -coord * RADIAN,\n          clockwise: clockwise\n        },\n        silent: true\n      }));\n      prevAngle = -coord * RADIAN;\n    } // Simple optimization\n    // Batching the lines if color are the same\n\n\n    for (var i = 0; i < splitAreas.length; i++) {\n      group.add(graphic.mergePath(splitAreas[i], {\n        style: zrUtil.defaults({\n          fill: areaColors[i % areaColors.length]\n        }, areaStyleModel.getAreaStyle()),\n        silent: true\n      }));\n    }\n  }\n};\nexport default AngleAxisView;","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { retrieve, defaults, extend, each, isObject, map, isString, isNumber, isFunction } from 'zrender/lib/core/util.js';\nimport * as graphic from '../../util/graphic.js';\nimport { getECData } from '../../util/innerStore.js';\nimport { createTextStyle } from '../../label/labelStyle.js';\nimport Model from '../../model/Model.js';\nimport { isRadianAroundZero, remRadian } from '../../util/number.js';\nimport { createSymbol, normalizeSymbolOffset } from '../../util/symbol.js';\nimport * as matrixUtil from 'zrender/lib/core/matrix.js';\nimport { applyTransform as v2ApplyTransform } from 'zrender/lib/core/vector.js';\nimport { shouldShowAllLabels } from '../../coord/axisHelper.js';\nimport { prepareLayoutList, hideOverlap } from '../../label/labelLayoutHelper.js';\nvar PI = Math.PI;\n/**\n * A final axis is translated and rotated from a \"standard axis\".\n * So opt.position and opt.rotation is required.\n *\n * A standard axis is and axis from [0, 0] to [0, axisExtent[1]],\n * for example: (0, 0) ------------> (0, 50)\n *\n * nameDirection or tickDirection or labelDirection is 1 means tick\n * or label is below the standard axis, whereas is -1 means above\n * the standard axis. labelOffset means offset between label and axis,\n * which is useful when 'onZero', where axisLabel is in the grid and\n * label in outside grid.\n *\n * Tips: like always,\n * positive rotation represents anticlockwise, and negative rotation\n * represents clockwise.\n * The direction of position coordinate is the same as the direction\n * of screen coordinate.\n *\n * Do not need to consider axis 'inverse', which is auto processed by\n * axis extent.\n */\n\nvar AxisBuilder =\n/** @class */\nfunction () {\n  function AxisBuilder(axisModel, opt) {\n    this.group = new graphic.Group();\n    this.opt = opt;\n    this.axisModel = axisModel; // Default value\n\n    defaults(opt, {\n      labelOffset: 0,\n      nameDirection: 1,\n      tickDirection: 1,\n      labelDirection: 1,\n      silent: true,\n      handleAutoShown: function () {\n        return true;\n      }\n    }); // FIXME Not use a seperate text group?\n\n    var transformGroup = new graphic.Group({\n      x: opt.position[0],\n      y: opt.position[1],\n      rotation: opt.rotation\n    }); // this.group.add(transformGroup);\n    // this._transformGroup = transformGroup;\n\n    transformGroup.updateTransform();\n    this._transformGroup = transformGroup;\n  }\n\n  AxisBuilder.prototype.hasBuilder = function (name) {\n    return !!builders[name];\n  };\n\n  AxisBuilder.prototype.add = function (name) {\n    builders[name](this.opt, this.axisModel, this.group, this._transformGroup);\n  };\n\n  AxisBuilder.prototype.getGroup = function () {\n    return this.group;\n  };\n\n  AxisBuilder.innerTextLayout = function (axisRotation, textRotation, direction) {\n    var rotationDiff = remRadian(textRotation - axisRotation);\n    var textAlign;\n    var textVerticalAlign;\n\n    if (isRadianAroundZero(rotationDiff)) {\n      // Label is parallel with axis line.\n      textVerticalAlign = direction > 0 ? 'top' : 'bottom';\n      textAlign = 'center';\n    } else if (isRadianAroundZero(rotationDiff - PI)) {\n      // Label is inverse parallel with axis line.\n      textVerticalAlign = direction > 0 ? 'bottom' : 'top';\n      textAlign = 'center';\n    } else {\n      textVerticalAlign = 'middle';\n\n      if (rotationDiff > 0 && rotationDiff < PI) {\n        textAlign = direction > 0 ? 'right' : 'left';\n      } else {\n        textAlign = direction > 0 ? 'left' : 'right';\n      }\n    }\n\n    return {\n      rotation: rotationDiff,\n      textAlign: textAlign,\n      textVerticalAlign: textVerticalAlign\n    };\n  };\n\n  AxisBuilder.makeAxisEventDataBase = function (axisModel) {\n    var eventData = {\n      componentType: axisModel.mainType,\n      componentIndex: axisModel.componentIndex\n    };\n    eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;\n    return eventData;\n  };\n\n  AxisBuilder.isLabelSilent = function (axisModel) {\n    var tooltipOpt = axisModel.get('tooltip');\n    return axisModel.get('silent') // Consider mouse cursor, add these restrictions.\n    || !(axisModel.get('triggerEvent') || tooltipOpt && tooltipOpt.show);\n  };\n\n  return AxisBuilder;\n}();\n\n;\nvar builders = {\n  axisLine: function (opt, axisModel, group, transformGroup) {\n    var shown = axisModel.get(['axisLine', 'show']);\n\n    if (shown === 'auto' && opt.handleAutoShown) {\n      shown = opt.handleAutoShown('axisLine');\n    }\n\n    if (!shown) {\n      return;\n    }\n\n    var extent = axisModel.axis.getExtent();\n    var matrix = transformGroup.transform;\n    var pt1 = [extent[0], 0];\n    var pt2 = [extent[1], 0];\n    var inverse = pt1[0] > pt2[0];\n\n    if (matrix) {\n      v2ApplyTransform(pt1, pt1, matrix);\n      v2ApplyTransform(pt2, pt2, matrix);\n    }\n\n    var lineStyle = extend({\n      lineCap: 'round'\n    }, axisModel.getModel(['axisLine', 'lineStyle']).getLineStyle());\n    var line = new graphic.Line({\n      shape: {\n        x1: pt1[0],\n        y1: pt1[1],\n        x2: pt2[0],\n        y2: pt2[1]\n      },\n      style: lineStyle,\n      strokeContainThreshold: opt.strokeContainThreshold || 5,\n      silent: true,\n      z2: 1\n    });\n    graphic.subPixelOptimizeLine(line.shape, line.style.lineWidth);\n    line.anid = 'line';\n    group.add(line);\n    var arrows = axisModel.get(['axisLine', 'symbol']);\n\n    if (arrows != null) {\n      var arrowSize = axisModel.get(['axisLine', 'symbolSize']);\n\n      if (isString(arrows)) {\n        // Use the same arrow for start and end point\n        arrows = [arrows, arrows];\n      }\n\n      if (isString(arrowSize) || isNumber(arrowSize)) {\n        // Use the same size for width and height\n        arrowSize = [arrowSize, arrowSize];\n      }\n\n      var arrowOffset = normalizeSymbolOffset(axisModel.get(['axisLine', 'symbolOffset']) || 0, arrowSize);\n      var symbolWidth_1 = arrowSize[0];\n      var symbolHeight_1 = arrowSize[1];\n      each([{\n        rotate: opt.rotation + Math.PI / 2,\n        offset: arrowOffset[0],\n        r: 0\n      }, {\n        rotate: opt.rotation - Math.PI / 2,\n        offset: arrowOffset[1],\n        r: Math.sqrt((pt1[0] - pt2[0]) * (pt1[0] - pt2[0]) + (pt1[1] - pt2[1]) * (pt1[1] - pt2[1]))\n      }], function (point, index) {\n        if (arrows[index] !== 'none' && arrows[index] != null) {\n          var symbol = createSymbol(arrows[index], -symbolWidth_1 / 2, -symbolHeight_1 / 2, symbolWidth_1, symbolHeight_1, lineStyle.stroke, true); // Calculate arrow position with offset\n\n          var r = point.r + point.offset;\n          var pt = inverse ? pt2 : pt1;\n          symbol.attr({\n            rotation: point.rotate,\n            x: pt[0] + r * Math.cos(opt.rotation),\n            y: pt[1] - r * Math.sin(opt.rotation),\n            silent: true,\n            z2: 11\n          });\n          group.add(symbol);\n        }\n      });\n    }\n  },\n  axisTickLabel: function (opt, axisModel, group, transformGroup) {\n    var ticksEls = buildAxisMajorTicks(group, transformGroup, axisModel, opt);\n    var labelEls = buildAxisLabel(group, transformGroup, axisModel, opt);\n    fixMinMaxLabelShow(axisModel, labelEls, ticksEls);\n    buildAxisMinorTicks(group, transformGroup, axisModel, opt.tickDirection); // This bit fixes the label overlap issue for the time chart.\n    // See https://github.com/apache/echarts/issues/14266 for more.\n\n    if (axisModel.get(['axisLabel', 'hideOverlap'])) {\n      var labelList = prepareLayoutList(map(labelEls, function (label) {\n        return {\n          label: label,\n          priority: label.z2,\n          defaultAttr: {\n            ignore: label.ignore\n          }\n        };\n      }));\n      hideOverlap(labelList);\n    }\n  },\n  axisName: function (opt, axisModel, group, transformGroup) {\n    var name = retrieve(opt.axisName, axisModel.get('name'));\n\n    if (!name) {\n      return;\n    }\n\n    var nameLocation = axisModel.get('nameLocation');\n    var nameDirection = opt.nameDirection;\n    var textStyleModel = axisModel.getModel('nameTextStyle');\n    var gap = axisModel.get('nameGap') || 0;\n    var extent = axisModel.axis.getExtent();\n    var gapSignal = extent[0] > extent[1] ? -1 : 1;\n    var pos = [nameLocation === 'start' ? extent[0] - gapSignal * gap : nameLocation === 'end' ? extent[1] + gapSignal * gap : (extent[0] + extent[1]) / 2, // Reuse labelOffset.\n    isNameLocationCenter(nameLocation) ? opt.labelOffset + nameDirection * gap : 0];\n    var labelLayout;\n    var nameRotation = axisModel.get('nameRotate');\n\n    if (nameRotation != null) {\n      nameRotation = nameRotation * PI / 180; // To radian.\n    }\n\n    var axisNameAvailableWidth;\n\n    if (isNameLocationCenter(nameLocation)) {\n      labelLayout = AxisBuilder.innerTextLayout(opt.rotation, nameRotation != null ? nameRotation : opt.rotation, // Adapt to axis.\n      nameDirection);\n    } else {\n      labelLayout = endTextLayout(opt.rotation, nameLocation, nameRotation || 0, extent);\n      axisNameAvailableWidth = opt.axisNameAvailableWidth;\n\n      if (axisNameAvailableWidth != null) {\n        axisNameAvailableWidth = Math.abs(axisNameAvailableWidth / Math.sin(labelLayout.rotation));\n        !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);\n      }\n    }\n\n    var textFont = textStyleModel.getFont();\n    var truncateOpt = axisModel.get('nameTruncate', true) || {};\n    var ellipsis = truncateOpt.ellipsis;\n    var maxWidth = retrieve(opt.nameTruncateMaxWidth, truncateOpt.maxWidth, axisNameAvailableWidth);\n    var textEl = new graphic.Text({\n      x: pos[0],\n      y: pos[1],\n      rotation: labelLayout.rotation,\n      silent: AxisBuilder.isLabelSilent(axisModel),\n      style: createTextStyle(textStyleModel, {\n        text: name,\n        font: textFont,\n        overflow: 'truncate',\n        width: maxWidth,\n        ellipsis: ellipsis,\n        fill: textStyleModel.getTextColor() || axisModel.get(['axisLine', 'lineStyle', 'color']),\n        align: textStyleModel.get('align') || labelLayout.textAlign,\n        verticalAlign: textStyleModel.get('verticalAlign') || labelLayout.textVerticalAlign\n      }),\n      z2: 1\n    });\n    graphic.setTooltipConfig({\n      el: textEl,\n      componentModel: axisModel,\n      itemName: name\n    });\n    textEl.__fullText = name; // Id for animation\n\n    textEl.anid = 'name';\n\n    if (axisModel.get('triggerEvent')) {\n      var eventData = AxisBuilder.makeAxisEventDataBase(axisModel);\n      eventData.targetType = 'axisName';\n      eventData.name = name;\n      getECData(textEl).eventData = eventData;\n    } // FIXME\n\n\n    transformGroup.add(textEl);\n    textEl.updateTransform();\n    group.add(textEl);\n    textEl.decomposeTransform();\n  }\n};\n\nfunction endTextLayout(rotation, textPosition, textRotate, extent) {\n  var rotationDiff = remRadian(textRotate - rotation);\n  var textAlign;\n  var textVerticalAlign;\n  var inverse = extent[0] > extent[1];\n  var onLeft = textPosition === 'start' && !inverse || textPosition !== 'start' && inverse;\n\n  if (isRadianAroundZero(rotationDiff - PI / 2)) {\n    textVerticalAlign = onLeft ? 'bottom' : 'top';\n    textAlign = 'center';\n  } else if (isRadianAroundZero(rotationDiff - PI * 1.5)) {\n    textVerticalAlign = onLeft ? 'top' : 'bottom';\n    textAlign = 'center';\n  } else {\n    textVerticalAlign = 'middle';\n\n    if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {\n      textAlign = onLeft ? 'left' : 'right';\n    } else {\n      textAlign = onLeft ? 'right' : 'left';\n    }\n  }\n\n  return {\n    rotation: rotationDiff,\n    textAlign: textAlign,\n    textVerticalAlign: textVerticalAlign\n  };\n}\n\nfunction fixMinMaxLabelShow(axisModel, labelEls, tickEls) {\n  if (shouldShowAllLabels(axisModel.axis)) {\n    return;\n  } // If min or max are user set, we need to check\n  // If the tick on min(max) are overlap on their neighbour tick\n  // If they are overlapped, we need to hide the min(max) tick label\n\n\n  var showMinLabel = axisModel.get(['axisLabel', 'showMinLabel']);\n  var showMaxLabel = axisModel.get(['axisLabel', 'showMaxLabel']); // FIXME\n  // Have not consider onBand yet, where tick els is more than label els.\n\n  labelEls = labelEls || [];\n  tickEls = tickEls || [];\n  var firstLabel = labelEls[0];\n  var nextLabel = labelEls[1];\n  var lastLabel = labelEls[labelEls.length - 1];\n  var prevLabel = labelEls[labelEls.length - 2];\n  var firstTick = tickEls[0];\n  var nextTick = tickEls[1];\n  var lastTick = tickEls[tickEls.length - 1];\n  var prevTick = tickEls[tickEls.length - 2];\n\n  if (showMinLabel === false) {\n    ignoreEl(firstLabel);\n    ignoreEl(firstTick);\n  } else if (isTwoLabelOverlapped(firstLabel, nextLabel)) {\n    if (showMinLabel) {\n      ignoreEl(nextLabel);\n      ignoreEl(nextTick);\n    } else {\n      ignoreEl(firstLabel);\n      ignoreEl(firstTick);\n    }\n  }\n\n  if (showMaxLabel === false) {\n    ignoreEl(lastLabel);\n    ignoreEl(lastTick);\n  } else if (isTwoLabelOverlapped(prevLabel, lastLabel)) {\n    if (showMaxLabel) {\n      ignoreEl(prevLabel);\n      ignoreEl(prevTick);\n    } else {\n      ignoreEl(lastLabel);\n      ignoreEl(lastTick);\n    }\n  }\n}\n\nfunction ignoreEl(el) {\n  el && (el.ignore = true);\n}\n\nfunction isTwoLabelOverlapped(current, next) {\n  // current and next has the same rotation.\n  var firstRect = current && current.getBoundingRect().clone();\n  var nextRect = next && next.getBoundingRect().clone();\n\n  if (!firstRect || !nextRect) {\n    return;\n  } // When checking intersect of two rotated labels, we use mRotationBack\n  // to avoid that boundingRect is enlarge when using `boundingRect.applyTransform`.\n\n\n  var mRotationBack = matrixUtil.identity([]);\n  matrixUtil.rotate(mRotationBack, mRotationBack, -current.rotation);\n  firstRect.applyTransform(matrixUtil.mul([], mRotationBack, current.getLocalTransform()));\n  nextRect.applyTransform(matrixUtil.mul([], mRotationBack, next.getLocalTransform()));\n  return firstRect.intersect(nextRect);\n}\n\nfunction isNameLocationCenter(nameLocation) {\n  return nameLocation === 'middle' || nameLocation === 'center';\n}\n\nfunction createTicks(ticksCoords, tickTransform, tickEndCoord, tickLineStyle, anidPrefix) {\n  var tickEls = [];\n  var pt1 = [];\n  var pt2 = [];\n\n  for (var i = 0; i < ticksCoords.length; i++) {\n    var tickCoord = ticksCoords[i].coord;\n    pt1[0] = tickCoord;\n    pt1[1] = 0;\n    pt2[0] = tickCoord;\n    pt2[1] = tickEndCoord;\n\n    if (tickTransform) {\n      v2ApplyTransform(pt1, pt1, tickTransform);\n      v2ApplyTransform(pt2, pt2, tickTransform);\n    } // Tick line, Not use group transform to have better line draw\n\n\n    var tickEl = new graphic.Line({\n      shape: {\n        x1: pt1[0],\n        y1: pt1[1],\n        x2: pt2[0],\n        y2: pt2[1]\n      },\n      style: tickLineStyle,\n      z2: 2,\n      autoBatch: true,\n      silent: true\n    });\n    graphic.subPixelOptimizeLine(tickEl.shape, tickEl.style.lineWidth);\n    tickEl.anid = anidPrefix + '_' + ticksCoords[i].tickValue;\n    tickEls.push(tickEl);\n  }\n\n  return tickEls;\n}\n\nfunction buildAxisMajorTicks(group, transformGroup, axisModel, opt) {\n  var axis = axisModel.axis;\n  var tickModel = axisModel.getModel('axisTick');\n  var shown = tickModel.get('show');\n\n  if (shown === 'auto' && opt.handleAutoShown) {\n    shown = opt.handleAutoShown('axisTick');\n  }\n\n  if (!shown || axis.scale.isBlank()) {\n    return;\n  }\n\n  var lineStyleModel = tickModel.getModel('lineStyle');\n  var tickEndCoord = opt.tickDirection * tickModel.get('length');\n  var ticksCoords = axis.getTicksCoords();\n  var ticksEls = createTicks(ticksCoords, transformGroup.transform, tickEndCoord, defaults(lineStyleModel.getLineStyle(), {\n    stroke: axisModel.get(['axisLine', 'lineStyle', 'color'])\n  }), 'ticks');\n\n  for (var i = 0; i < ticksEls.length; i++) {\n    group.add(ticksEls[i]);\n  }\n\n  return ticksEls;\n}\n\nfunction buildAxisMinorTicks(group, transformGroup, axisModel, tickDirection) {\n  var axis = axisModel.axis;\n  var minorTickModel = axisModel.getModel('minorTick');\n\n  if (!minorTickModel.get('show') || axis.scale.isBlank()) {\n    return;\n  }\n\n  var minorTicksCoords = axis.getMinorTicksCoords();\n\n  if (!minorTicksCoords.length) {\n    return;\n  }\n\n  var lineStyleModel = minorTickModel.getModel('lineStyle');\n  var tickEndCoord = tickDirection * minorTickModel.get('length');\n  var minorTickLineStyle = defaults(lineStyleModel.getLineStyle(), defaults(axisModel.getModel('axisTick').getLineStyle(), {\n    stroke: axisModel.get(['axisLine', 'lineStyle', 'color'])\n  }));\n\n  for (var i = 0; i < minorTicksCoords.length; i++) {\n    var minorTicksEls = createTicks(minorTicksCoords[i], transformGroup.transform, tickEndCoord, minorTickLineStyle, 'minorticks_' + i);\n\n    for (var k = 0; k < minorTicksEls.length; k++) {\n      group.add(minorTicksEls[k]);\n    }\n  }\n}\n\nfunction buildAxisLabel(group, transformGroup, axisModel, opt) {\n  var axis = axisModel.axis;\n  var show = retrieve(opt.axisLabelShow, axisModel.get(['axisLabel', 'show']));\n\n  if (!show || axis.scale.isBlank()) {\n    return;\n  }\n\n  var labelModel = axisModel.getModel('axisLabel');\n  var labelMargin = labelModel.get('margin');\n  var labels = axis.getViewLabels(); // Special label rotate.\n\n  var labelRotation = (retrieve(opt.labelRotate, labelModel.get('rotate')) || 0) * PI / 180;\n  var labelLayout = AxisBuilder.innerTextLayout(opt.rotation, labelRotation, opt.labelDirection);\n  var rawCategoryData = axisModel.getCategories && axisModel.getCategories(true);\n  var labelEls = [];\n  var silent = AxisBuilder.isLabelSilent(axisModel);\n  var triggerEvent = axisModel.get('triggerEvent');\n  each(labels, function (labelItem, index) {\n    var tickValue = axis.scale.type === 'ordinal' ? axis.scale.getRawOrdinalNumber(labelItem.tickValue) : labelItem.tickValue;\n    var formattedLabel = labelItem.formattedLabel;\n    var rawLabel = labelItem.rawLabel;\n    var itemLabelModel = labelModel;\n\n    if (rawCategoryData && rawCategoryData[tickValue]) {\n      var rawCategoryItem = rawCategoryData[tickValue];\n\n      if (isObject(rawCategoryItem) && rawCategoryItem.textStyle) {\n        itemLabelModel = new Model(rawCategoryItem.textStyle, labelModel, axisModel.ecModel);\n      }\n    }\n\n    var textColor = itemLabelModel.getTextColor() || axisModel.get(['axisLine', 'lineStyle', 'color']);\n    var tickCoord = axis.dataToCoord(tickValue);\n    var textEl = new graphic.Text({\n      x: tickCoord,\n      y: opt.labelOffset + opt.labelDirection * labelMargin,\n      rotation: labelLayout.rotation,\n      silent: silent,\n      z2: 10 + (labelItem.level || 0),\n      style: createTextStyle(itemLabelModel, {\n        text: formattedLabel,\n        align: itemLabelModel.getShallow('align', true) || labelLayout.textAlign,\n        verticalAlign: itemLabelModel.getShallow('verticalAlign', true) || itemLabelModel.getShallow('baseline', true) || labelLayout.textVerticalAlign,\n        fill: isFunction(textColor) ? textColor( // (1) In category axis with data zoom, tick is not the original\n        // index of axis.data. So tick should not be exposed to user\n        // in category axis.\n        // (2) Compatible with previous version, which always use formatted label as\n        // input. But in interval scale the formatted label is like '223,445', which\n        // maked user repalce ','. So we modify it to return original val but remain\n        // it as 'string' to avoid error in replacing.\n        axis.type === 'category' ? rawLabel : axis.type === 'value' ? tickValue + '' : tickValue, index) : textColor\n      })\n    });\n    textEl.anid = 'label_' + tickValue; // Pack data for mouse event\n\n    if (triggerEvent) {\n      var eventData = AxisBuilder.makeAxisEventDataBase(axisModel);\n      eventData.targetType = 'axisLabel';\n      eventData.value = rawLabel;\n      eventData.tickIndex = index;\n\n      if (axis.type === 'category') {\n        eventData.dataIndex = tickValue;\n      }\n\n      getECData(textEl).eventData = eventData;\n    } // FIXME\n\n\n    transformGroup.add(textEl);\n    textEl.updateTransform();\n    labelEls.push(textEl);\n    group.add(textEl);\n    textEl.decomposeTransform();\n  });\n  return labelEls;\n}\n\nexport default AxisBuilder;","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\";\nimport * as axisPointerModelHelper from '../axisPointer/modelHelper.js';\nimport ComponentView from '../../view/Component.js';\nvar axisPointerClazz = {};\n/**\n * Base class of AxisView.\n */\n\nvar AxisView =\n/** @class */\nfunction (_super) {\n  __extends(AxisView, _super);\n\n  function AxisView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = AxisView.type;\n    return _this;\n  }\n  /**\n   * @override\n   */\n\n\n  AxisView.prototype.render = function (axisModel, ecModel, api, payload) {\n    // FIXME\n    // This process should proformed after coordinate systems updated\n    // (axis scale updated), and should be performed each time update.\n    // So put it here temporarily, although it is not appropriate to\n    // put a model-writing procedure in `view`.\n    this.axisPointerClass && axisPointerModelHelper.fixValue(axisModel);\n\n    _super.prototype.render.apply(this, arguments);\n\n    this._doUpdateAxisPointerClass(axisModel, api, true);\n  };\n  /**\n   * Action handler.\n   */\n\n\n  AxisView.prototype.updateAxisPointer = function (axisModel, ecModel, api, payload) {\n    this._doUpdateAxisPointerClass(axisModel, api, false);\n  };\n  /**\n   * @override\n   */\n\n\n  AxisView.prototype.remove = function (ecModel, api) {\n    var axisPointer = this._axisPointer;\n    axisPointer && axisPointer.remove(api);\n  };\n  /**\n   * @override\n   */\n\n\n  AxisView.prototype.dispose = function (ecModel, api) {\n    this._disposeAxisPointer(api);\n\n    _super.prototype.dispose.apply(this, arguments);\n  };\n\n  AxisView.prototype._doUpdateAxisPointerClass = function (axisModel, api, forceRender) {\n    var Clazz = AxisView.getAxisPointerClass(this.axisPointerClass);\n\n    if (!Clazz) {\n      return;\n    }\n\n    var axisPointerModel = axisPointerModelHelper.getAxisPointerModel(axisModel);\n    axisPointerModel ? (this._axisPointer || (this._axisPointer = new Clazz())).render(axisModel, axisPointerModel, api, forceRender) : this._disposeAxisPointer(api);\n  };\n\n  AxisView.prototype._disposeAxisPointer = function (api) {\n    this._axisPointer && this._axisPointer.dispose(api);\n    this._axisPointer = null;\n  };\n\n  AxisView.registerAxisPointerClass = function (type, clazz) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (axisPointerClazz[type]) {\n        throw new Error('axisPointer ' + type + ' exists');\n      }\n    }\n\n    axisPointerClazz[type] = clazz;\n  };\n\n  ;\n\n  AxisView.getAxisPointerClass = function (type) {\n    return type && axisPointerClazz[type];\n  };\n\n  ;\n  AxisView.type = 'axis';\n  return AxisView;\n}(ComponentView);\n\nexport default AxisView;"],"names":["elementList","getAxisLineShape","polar","rExtent","angle","slice","reverse","start","coordToPoint","end","x1","y1","x2","y2","getRadiusIdx","getRadiusAxis","inverse","fixAngleOverlap","list","firstItem","lastItem","length","Math","abs","coord","pop","AngleAxisView","_super","_this","apply","this","arguments","type","axisPointerClass","__extends","prototype","render","angleAxisModel","ecModel","group","removeAll","get","angleAxis","axis","radiusExtent","getExtent","ticksAngles","getTicksCoords","minorTickAngles","getMinorTicksCoords","labels","zrUtil","getViewLabels","labelItem","scale","tickValue","getRawOrdinalNumber","dataToCoord","name","isBlank","angelAxisElementsBuilders","AxisView","axisLine","shape","lineStyleModel","getModel","rId","r0Id","graphic","cx","cy","r","style","getLineStyle","z2","silent","r0","fill","add","axisTick","tickModel","tickLen","radius","lines","tickAngleItem","stroke","minorTick","tickAngles","minorTickModel","i","k","push","axisLabel","rawCategoryData","getCategories","commonLabelModel","labelMargin","triggerEvent","idx","labelModel","p","labelTextAlign","labelTextVerticalAlign","rawCategoryItem","textStyle","Model","textEl","AxisBuilder","createTextStyle","x","y","getTextColor","text","formattedLabel","align","verticalAlign","eventData","targetType","value","rawLabel","getECData","splitLine","lineColors","lineCount","Array","splitLines","colorIndex","z","minorSplitLine","splitArea","areaStyleModel","areaColors","splitAreas","RADIAN","PI","prevAngle","min","r1","max","clockwise","len","startAngle","endAngle","getAreaStyle","axisModel","opt","defaults","labelOffset","nameDirection","tickDirection","labelDirection","handleAutoShown","transformGroup","position","rotation","updateTransform","_transformGroup","hasBuilder","builders","getGroup","innerTextLayout","axisRotation","textRotation","direction","textAlign","textVerticalAlign","rotationDiff","remRadian","isRadianAroundZero","makeAxisEventDataBase","componentType","mainType","componentIndex","isLabelSilent","tooltipOpt","show","shown","extent","matrix","transform","pt1","pt2","v2ApplyTransform","lineStyle","extend","lineCap","line","strokeContainThreshold","lineWidth","anid","arrows","arrowSize","isString","isNumber","arrowOffset","normalizeSymbolOffset","symbolWidth_1","symbolHeight_1","each","rotate","offset","sqrt","point","index","symbol","createSymbol","pt","attr","cos","sin","axisTickLabel","ticksEls","tickEndCoord","createTicks","buildAxisMajorTicks","labelEls","retrieve","axisLabelShow","labelRotation","labelRotate","labelLayout","itemLabelModel","isObject","textColor","tickCoord","level","getShallow","isFunction","tickIndex","dataIndex","decomposeTransform","buildAxisLabel","tickEls","shouldShowAllLabels","showMinLabel","showMaxLabel","firstLabel","nextLabel","lastLabel","prevLabel","firstTick","nextTick","lastTick","prevTick","ignoreEl","isTwoLabelOverlapped","fixMinMaxLabelShow","minorTicksCoords","minorTickLineStyle","minorTicksEls","buildAxisMinorTicks","labelList","prepareLayoutList","map","label","priority","defaultAttr","ignore","hideOverlap","axisName","axisNameAvailableWidth","nameLocation","textStyleModel","gap","gapSignal","pos","isNameLocationCenter","nameRotation","textPosition","textRotate","onLeft","endTextLayout","isFinite","textFont","getFont","truncateOpt","ellipsis","maxWidth","nameTruncateMaxWidth","font","overflow","width","el","componentModel","itemName","__fullText","current","next","firstRect","getBoundingRect","clone","nextRect","mRotationBack","matrixUtil","applyTransform","getLocalTransform","intersect","ticksCoords","tickTransform","tickLineStyle","anidPrefix","tickEl","autoBatch","axisPointerClazz","api","payload","axisPointerModelHelper","_doUpdateAxisPointerClass","updateAxisPointer","remove","axisPointer","_axisPointer","dispose","_disposeAxisPointer","forceRender","Clazz","getAxisPointerClass","axisPointerModel","registerAxisPointerClass","clazz","ComponentView"],"sourceRoot":""}
{"version":3,"file":"static/js/9375.ad3b29b5.js","mappings":"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","sources":["../node_modules/echarts/lib/component/marker/MarkAreaModel.js","../node_modules/echarts/lib/component/marker/MarkAreaView.js","../node_modules/echarts/lib/component/marker/MarkLineModel.js","../node_modules/echarts/lib/component/marker/MarkLineView.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\";\nimport MarkerModel from './MarkerModel.js';\n\nvar MarkAreaModel =\n/** @class */\nfunction (_super) {\n  __extends(MarkAreaModel, _super);\n\n  function MarkAreaModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = MarkAreaModel.type;\n    return _this;\n  }\n\n  MarkAreaModel.prototype.createMarkerModelFromSeries = function (markerOpt, masterMarkerModel, ecModel) {\n    return new MarkAreaModel(markerOpt, masterMarkerModel, ecModel);\n  };\n\n  MarkAreaModel.type = 'markArea';\n  MarkAreaModel.defaultOption = {\n    // zlevel: 0,\n    // PENDING\n    z: 1,\n    tooltip: {\n      trigger: 'item'\n    },\n    // markArea should fixed on the coordinate system\n    animation: false,\n    label: {\n      show: true,\n      position: 'top'\n    },\n    itemStyle: {\n      // color and borderColor default to use color from series\n      // color: 'auto'\n      // borderColor: 'auto'\n      borderWidth: 0\n    },\n    emphasis: {\n      label: {\n        show: true,\n        position: 'top'\n      }\n    }\n  };\n  return MarkAreaModel;\n}(MarkerModel);\n\nexport default MarkAreaModel;","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\"; // TODO Optimize on polar\n\nimport * as colorUtil from 'zrender/lib/tool/color.js';\nimport SeriesData from '../../data/SeriesData.js';\nimport * as numberUtil from '../../util/number.js';\nimport * as graphic from '../../util/graphic.js';\nimport { toggleHoverEmphasis, setStatesStylesFromModel } from '../../util/states.js';\nimport * as markerHelper from './markerHelper.js';\nimport MarkerView from './MarkerView.js';\nimport { retrieve, mergeAll, map, curry, filter, extend, isString } from 'zrender/lib/core/util.js';\nimport { isCoordinateSystemType } from '../../coord/CoordinateSystem.js';\nimport MarkerModel from './MarkerModel.js';\nimport { makeInner } from '../../util/model.js';\nimport { getVisualFromData } from '../../visual/helper.js';\nimport { setLabelStyle, getLabelStatesModels } from '../../label/labelStyle.js';\nimport { getECData } from '../../util/innerStore.js';\nimport { parseDataValue } from '../../data/helper/dataValueHelper.js';\nvar inner = makeInner();\n\nvar markAreaTransform = function (seriesModel, coordSys, maModel, item) {\n  var lt = markerHelper.dataTransform(seriesModel, item[0]);\n  var rb = markerHelper.dataTransform(seriesModel, item[1]); // FIXME make sure lt is less than rb\n\n  var ltCoord = lt.coord;\n  var rbCoord = rb.coord;\n  ltCoord[0] = retrieve(ltCoord[0], -Infinity);\n  ltCoord[1] = retrieve(ltCoord[1], -Infinity);\n  rbCoord[0] = retrieve(rbCoord[0], Infinity);\n  rbCoord[1] = retrieve(rbCoord[1], Infinity); // Merge option into one\n\n  var result = mergeAll([{}, lt, rb]);\n  result.coord = [lt.coord, rb.coord];\n  result.x0 = lt.x;\n  result.y0 = lt.y;\n  result.x1 = rb.x;\n  result.y1 = rb.y;\n  return result;\n};\n\nfunction isInfinity(val) {\n  return !isNaN(val) && !isFinite(val);\n} // If a markArea has one dim\n\n\nfunction ifMarkAreaHasOnlyDim(dimIndex, fromCoord, toCoord, coordSys) {\n  var otherDimIndex = 1 - dimIndex;\n  return isInfinity(fromCoord[otherDimIndex]) && isInfinity(toCoord[otherDimIndex]);\n}\n\nfunction markAreaFilter(coordSys, item) {\n  var fromCoord = item.coord[0];\n  var toCoord = item.coord[1];\n  var item0 = {\n    coord: fromCoord,\n    x: item.x0,\n    y: item.y0\n  };\n  var item1 = {\n    coord: toCoord,\n    x: item.x1,\n    y: item.y1\n  };\n\n  if (isCoordinateSystemType(coordSys, 'cartesian2d')) {\n    // In case\n    // {\n    //  markArea: {\n    //    data: [{ yAxis: 2 }]\n    //  }\n    // }\n    if (fromCoord && toCoord && (ifMarkAreaHasOnlyDim(1, fromCoord, toCoord, coordSys) || ifMarkAreaHasOnlyDim(0, fromCoord, toCoord, coordSys))) {\n      return true;\n    } //Directly returning true may also do the work,\n    //because markArea will not be shown automatically\n    //when it's not included in coordinate system.\n    //But filtering ahead can avoid keeping rendering markArea\n    //when there are too many of them.\n\n\n    return markerHelper.zoneFilter(coordSys, item0, item1);\n  }\n\n  return markerHelper.dataFilter(coordSys, item0) || markerHelper.dataFilter(coordSys, item1);\n} // dims can be ['x0', 'y0'], ['x1', 'y1'], ['x0', 'y1'], ['x1', 'y0']\n\n\nfunction getSingleMarkerEndPoint(data, idx, dims, seriesModel, api) {\n  var coordSys = seriesModel.coordinateSystem;\n  var itemModel = data.getItemModel(idx);\n  var point;\n  var xPx = numberUtil.parsePercent(itemModel.get(dims[0]), api.getWidth());\n  var yPx = numberUtil.parsePercent(itemModel.get(dims[1]), api.getHeight());\n\n  if (!isNaN(xPx) && !isNaN(yPx)) {\n    point = [xPx, yPx];\n  } else {\n    // Chart like bar may have there own marker positioning logic\n    if (seriesModel.getMarkerPosition) {\n      // Use the getMarkerPosition\n      point = seriesModel.getMarkerPosition(data.getValues(dims, idx));\n    } else {\n      var x = data.get(dims[0], idx);\n      var y = data.get(dims[1], idx);\n      var pt = [x, y];\n      coordSys.clampData && coordSys.clampData(pt, pt);\n      point = coordSys.dataToPoint(pt, true);\n    }\n\n    if (isCoordinateSystemType(coordSys, 'cartesian2d')) {\n      // TODO: TYPE ts@4.1 may still infer it as Axis instead of Axis2D. Not sure if it's a bug\n      var xAxis = coordSys.getAxis('x');\n      var yAxis = coordSys.getAxis('y');\n      var x = data.get(dims[0], idx);\n      var y = data.get(dims[1], idx);\n\n      if (isInfinity(x)) {\n        point[0] = xAxis.toGlobalCoord(xAxis.getExtent()[dims[0] === 'x0' ? 0 : 1]);\n      } else if (isInfinity(y)) {\n        point[1] = yAxis.toGlobalCoord(yAxis.getExtent()[dims[1] === 'y0' ? 0 : 1]);\n      }\n    } // Use x, y if has any\n\n\n    if (!isNaN(xPx)) {\n      point[0] = xPx;\n    }\n\n    if (!isNaN(yPx)) {\n      point[1] = yPx;\n    }\n  }\n\n  return point;\n}\n\nvar dimPermutations = [['x0', 'y0'], ['x1', 'y0'], ['x1', 'y1'], ['x0', 'y1']];\n\nvar MarkAreaView =\n/** @class */\nfunction (_super) {\n  __extends(MarkAreaView, _super);\n\n  function MarkAreaView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = MarkAreaView.type;\n    return _this;\n  }\n\n  MarkAreaView.prototype.updateTransform = function (markAreaModel, ecModel, api) {\n    ecModel.eachSeries(function (seriesModel) {\n      var maModel = MarkerModel.getMarkerModelFromSeries(seriesModel, 'markArea');\n\n      if (maModel) {\n        var areaData_1 = maModel.getData();\n        areaData_1.each(function (idx) {\n          var points = map(dimPermutations, function (dim) {\n            return getSingleMarkerEndPoint(areaData_1, idx, dim, seriesModel, api);\n          }); // Layout\n\n          areaData_1.setItemLayout(idx, points);\n          var el = areaData_1.getItemGraphicEl(idx);\n          el.setShape('points', points);\n        });\n      }\n    }, this);\n  };\n\n  MarkAreaView.prototype.renderSeries = function (seriesModel, maModel, ecModel, api) {\n    var coordSys = seriesModel.coordinateSystem;\n    var seriesId = seriesModel.id;\n    var seriesData = seriesModel.getData();\n    var areaGroupMap = this.markerGroupMap;\n    var polygonGroup = areaGroupMap.get(seriesId) || areaGroupMap.set(seriesId, {\n      group: new graphic.Group()\n    });\n    this.group.add(polygonGroup.group);\n    this.markKeep(polygonGroup);\n    var areaData = createList(coordSys, seriesModel, maModel); // Line data for tooltip and formatter\n\n    maModel.setData(areaData); // Update visual and layout of line\n\n    areaData.each(function (idx) {\n      // Layout\n      var points = map(dimPermutations, function (dim) {\n        return getSingleMarkerEndPoint(areaData, idx, dim, seriesModel, api);\n      });\n      var xAxisScale = coordSys.getAxis('x').scale;\n      var yAxisScale = coordSys.getAxis('y').scale;\n      var xAxisExtent = xAxisScale.getExtent();\n      var yAxisExtent = yAxisScale.getExtent();\n      var xPointExtent = [xAxisScale.parse(areaData.get('x0', idx)), xAxisScale.parse(areaData.get('x1', idx))];\n      var yPointExtent = [yAxisScale.parse(areaData.get('y0', idx)), yAxisScale.parse(areaData.get('y1', idx))];\n      numberUtil.asc(xPointExtent);\n      numberUtil.asc(yPointExtent);\n      var overlapped = !(xAxisExtent[0] > xPointExtent[1] || xAxisExtent[1] < xPointExtent[0] || yAxisExtent[0] > yPointExtent[1] || yAxisExtent[1] < yPointExtent[0]); // If none of the area is inside coordSys, allClipped is set to be true\n      // in layout so that label will not be displayed. See #12591\n\n      var allClipped = !overlapped;\n      areaData.setItemLayout(idx, {\n        points: points,\n        allClipped: allClipped\n      });\n      var style = areaData.getItemModel(idx).getModel('itemStyle').getItemStyle();\n      var color = getVisualFromData(seriesData, 'color');\n\n      if (!style.fill) {\n        style.fill = color;\n\n        if (isString(style.fill)) {\n          style.fill = colorUtil.modifyAlpha(style.fill, 0.4);\n        }\n      }\n\n      if (!style.stroke) {\n        style.stroke = color;\n      } // Visual\n\n\n      areaData.setItemVisual(idx, 'style', style);\n    });\n    areaData.diff(inner(polygonGroup).data).add(function (idx) {\n      var layout = areaData.getItemLayout(idx);\n\n      if (!layout.allClipped) {\n        var polygon = new graphic.Polygon({\n          shape: {\n            points: layout.points\n          }\n        });\n        areaData.setItemGraphicEl(idx, polygon);\n        polygonGroup.group.add(polygon);\n      }\n    }).update(function (newIdx, oldIdx) {\n      var polygon = inner(polygonGroup).data.getItemGraphicEl(oldIdx);\n      var layout = areaData.getItemLayout(newIdx);\n\n      if (!layout.allClipped) {\n        if (polygon) {\n          graphic.updateProps(polygon, {\n            shape: {\n              points: layout.points\n            }\n          }, maModel, newIdx);\n        } else {\n          polygon = new graphic.Polygon({\n            shape: {\n              points: layout.points\n            }\n          });\n        }\n\n        areaData.setItemGraphicEl(newIdx, polygon);\n        polygonGroup.group.add(polygon);\n      } else if (polygon) {\n        polygonGroup.group.remove(polygon);\n      }\n    }).remove(function (idx) {\n      var polygon = inner(polygonGroup).data.getItemGraphicEl(idx);\n      polygonGroup.group.remove(polygon);\n    }).execute();\n    areaData.eachItemGraphicEl(function (polygon, idx) {\n      var itemModel = areaData.getItemModel(idx);\n      var style = areaData.getItemVisual(idx, 'style');\n      polygon.useStyle(areaData.getItemVisual(idx, 'style'));\n      setLabelStyle(polygon, getLabelStatesModels(itemModel), {\n        labelFetcher: maModel,\n        labelDataIndex: idx,\n        defaultText: areaData.getName(idx) || '',\n        inheritColor: isString(style.fill) ? colorUtil.modifyAlpha(style.fill, 1) : '#000'\n      });\n      setStatesStylesFromModel(polygon, itemModel);\n      toggleHoverEmphasis(polygon, null, null, itemModel.get(['emphasis', 'disabled']));\n      getECData(polygon).dataModel = maModel;\n    });\n    inner(polygonGroup).data = areaData;\n    polygonGroup.group.silent = maModel.get('silent') || seriesModel.get('silent');\n  };\n\n  MarkAreaView.type = 'markArea';\n  return MarkAreaView;\n}(MarkerView);\n\nfunction createList(coordSys, seriesModel, maModel) {\n  var areaData;\n  var dataDims;\n  var dims = ['x0', 'y0', 'x1', 'y1'];\n\n  if (coordSys) {\n    var coordDimsInfos_1 = map(coordSys && coordSys.dimensions, function (coordDim) {\n      var data = seriesModel.getData();\n      var info = data.getDimensionInfo(data.mapDimension(coordDim)) || {}; // In map series data don't have lng and lat dimension. Fallback to same with coordSys\n\n      return extend(extend({}, info), {\n        name: coordDim,\n        // DON'T use ordinalMeta to parse and collect ordinal.\n        ordinalMeta: null\n      });\n    });\n    dataDims = map(dims, function (dim, idx) {\n      return {\n        name: dim,\n        type: coordDimsInfos_1[idx % 2].type\n      };\n    });\n    areaData = new SeriesData(dataDims, maModel);\n  } else {\n    dataDims = [{\n      name: 'value',\n      type: 'float'\n    }];\n    areaData = new SeriesData(dataDims, maModel);\n  }\n\n  var optData = map(maModel.get('data'), curry(markAreaTransform, seriesModel, coordSys, maModel));\n\n  if (coordSys) {\n    optData = filter(optData, curry(markAreaFilter, coordSys));\n  }\n\n  var dimValueGetter = coordSys ? function (item, dimName, dataIndex, dimIndex) {\n    // TODO should convert to ParsedValue?\n    var rawVal = item.coord[Math.floor(dimIndex / 2)][dimIndex % 2];\n    return parseDataValue(rawVal, dataDims[dimIndex]);\n  } : function (item, dimName, dataIndex, dimIndex) {\n    return parseDataValue(item.value, dataDims[dimIndex]);\n  };\n  areaData.initData(optData, null, dimValueGetter);\n  areaData.hasItemOption = true;\n  return areaData;\n}\n\nexport default MarkAreaView;","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\";\nimport MarkerModel from './MarkerModel.js';\n\nvar MarkLineModel =\n/** @class */\nfunction (_super) {\n  __extends(MarkLineModel, _super);\n\n  function MarkLineModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = MarkLineModel.type;\n    return _this;\n  }\n\n  MarkLineModel.prototype.createMarkerModelFromSeries = function (markerOpt, masterMarkerModel, ecModel) {\n    return new MarkLineModel(markerOpt, masterMarkerModel, ecModel);\n  };\n\n  MarkLineModel.type = 'markLine';\n  MarkLineModel.defaultOption = {\n    // zlevel: 0,\n    z: 5,\n    symbol: ['circle', 'arrow'],\n    symbolSize: [8, 16],\n    //symbolRotate: 0,\n    symbolOffset: 0,\n    precision: 2,\n    tooltip: {\n      trigger: 'item'\n    },\n    label: {\n      show: true,\n      position: 'end',\n      distance: 5\n    },\n    lineStyle: {\n      type: 'dashed'\n    },\n    emphasis: {\n      label: {\n        show: true\n      },\n      lineStyle: {\n        width: 3\n      }\n    },\n    animationEasing: 'linear'\n  };\n  return MarkLineModel;\n}(MarkerModel);\n\nexport default MarkLineModel;","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\";\nimport SeriesData from '../../data/SeriesData.js';\nimport * as numberUtil from '../../util/number.js';\nimport * as markerHelper from './markerHelper.js';\nimport LineDraw from '../../chart/helper/LineDraw.js';\nimport MarkerView from './MarkerView.js';\nimport { getStackedDimension } from '../../data/helper/dataStackHelper.js';\nimport { isCoordinateSystemType } from '../../coord/CoordinateSystem.js';\nimport { getECData } from '../../util/innerStore.js';\nimport MarkerModel from './MarkerModel.js';\nimport { isArray, retrieve, retrieve2, clone, extend, logError, merge, map, curry, filter, isNumber } from 'zrender/lib/core/util.js';\nimport { makeInner } from '../../util/model.js';\nimport { getVisualFromData } from '../../visual/helper.js';\nvar inner = makeInner();\n\nvar markLineTransform = function (seriesModel, coordSys, mlModel, item) {\n  var data = seriesModel.getData();\n  var itemArray;\n\n  if (!isArray(item)) {\n    // Special type markLine like 'min', 'max', 'average', 'median'\n    var mlType = item.type;\n\n    if (mlType === 'min' || mlType === 'max' || mlType === 'average' || mlType === 'median' // In case\n    // data: [{\n    //   yAxis: 10\n    // }]\n    || item.xAxis != null || item.yAxis != null) {\n      var valueAxis = void 0;\n      var value = void 0;\n\n      if (item.yAxis != null || item.xAxis != null) {\n        valueAxis = coordSys.getAxis(item.yAxis != null ? 'y' : 'x');\n        value = retrieve(item.yAxis, item.xAxis);\n      } else {\n        var axisInfo = markerHelper.getAxisInfo(item, data, coordSys, seriesModel);\n        valueAxis = axisInfo.valueAxis;\n        var valueDataDim = getStackedDimension(data, axisInfo.valueDataDim);\n        value = markerHelper.numCalculate(data, valueDataDim, mlType);\n      }\n\n      var valueIndex = valueAxis.dim === 'x' ? 0 : 1;\n      var baseIndex = 1 - valueIndex; // Normized to 2d data with start and end point\n\n      var mlFrom = clone(item);\n      var mlTo = {\n        coord: []\n      };\n      mlFrom.type = null;\n      mlFrom.coord = [];\n      mlFrom.coord[baseIndex] = -Infinity;\n      mlTo.coord[baseIndex] = Infinity;\n      var precision = mlModel.get('precision');\n\n      if (precision >= 0 && isNumber(value)) {\n        value = +value.toFixed(Math.min(precision, 20));\n      }\n\n      mlFrom.coord[valueIndex] = mlTo.coord[valueIndex] = value;\n      itemArray = [mlFrom, mlTo, {\n        type: mlType,\n        valueIndex: item.valueIndex,\n        // Force to use the value of calculated value.\n        value: value\n      }];\n    } else {\n      // Invalid data\n      if (process.env.NODE_ENV !== 'production') {\n        logError('Invalid markLine data.');\n      }\n\n      itemArray = [];\n    }\n  } else {\n    itemArray = item;\n  }\n\n  var normalizedItem = [markerHelper.dataTransform(seriesModel, itemArray[0]), markerHelper.dataTransform(seriesModel, itemArray[1]), extend({}, itemArray[2])]; // Avoid line data type is extended by from(to) data type\n\n  normalizedItem[2].type = normalizedItem[2].type || null; // Merge from option and to option into line option\n\n  merge(normalizedItem[2], normalizedItem[0]);\n  merge(normalizedItem[2], normalizedItem[1]);\n  return normalizedItem;\n};\n\nfunction isInfinity(val) {\n  return !isNaN(val) && !isFinite(val);\n} // If a markLine has one dim\n\n\nfunction ifMarkLineHasOnlyDim(dimIndex, fromCoord, toCoord, coordSys) {\n  var otherDimIndex = 1 - dimIndex;\n  var dimName = coordSys.dimensions[dimIndex];\n  return isInfinity(fromCoord[otherDimIndex]) && isInfinity(toCoord[otherDimIndex]) && fromCoord[dimIndex] === toCoord[dimIndex] && coordSys.getAxis(dimName).containData(fromCoord[dimIndex]);\n}\n\nfunction markLineFilter(coordSys, item) {\n  if (coordSys.type === 'cartesian2d') {\n    var fromCoord = item[0].coord;\n    var toCoord = item[1].coord; // In case\n    // {\n    //  markLine: {\n    //    data: [{ yAxis: 2 }]\n    //  }\n    // }\n\n    if (fromCoord && toCoord && (ifMarkLineHasOnlyDim(1, fromCoord, toCoord, coordSys) || ifMarkLineHasOnlyDim(0, fromCoord, toCoord, coordSys))) {\n      return true;\n    }\n  }\n\n  return markerHelper.dataFilter(coordSys, item[0]) && markerHelper.dataFilter(coordSys, item[1]);\n}\n\nfunction updateSingleMarkerEndLayout(data, idx, isFrom, seriesModel, api) {\n  var coordSys = seriesModel.coordinateSystem;\n  var itemModel = data.getItemModel(idx);\n  var point;\n  var xPx = numberUtil.parsePercent(itemModel.get('x'), api.getWidth());\n  var yPx = numberUtil.parsePercent(itemModel.get('y'), api.getHeight());\n\n  if (!isNaN(xPx) && !isNaN(yPx)) {\n    point = [xPx, yPx];\n  } else {\n    // Chart like bar may have there own marker positioning logic\n    if (seriesModel.getMarkerPosition) {\n      // Use the getMarkerPosition\n      point = seriesModel.getMarkerPosition(data.getValues(data.dimensions, idx));\n    } else {\n      var dims = coordSys.dimensions;\n      var x = data.get(dims[0], idx);\n      var y = data.get(dims[1], idx);\n      point = coordSys.dataToPoint([x, y]);\n    } // Expand line to the edge of grid if value on one axis is Inifnity\n    // In case\n    //  markLine: {\n    //    data: [{\n    //      yAxis: 2\n    //      // or\n    //      type: 'average'\n    //    }]\n    //  }\n\n\n    if (isCoordinateSystemType(coordSys, 'cartesian2d')) {\n      // TODO: TYPE ts@4.1 may still infer it as Axis instead of Axis2D. Not sure if it's a bug\n      var xAxis = coordSys.getAxis('x');\n      var yAxis = coordSys.getAxis('y');\n      var dims = coordSys.dimensions;\n\n      if (isInfinity(data.get(dims[0], idx))) {\n        point[0] = xAxis.toGlobalCoord(xAxis.getExtent()[isFrom ? 0 : 1]);\n      } else if (isInfinity(data.get(dims[1], idx))) {\n        point[1] = yAxis.toGlobalCoord(yAxis.getExtent()[isFrom ? 0 : 1]);\n      }\n    } // Use x, y if has any\n\n\n    if (!isNaN(xPx)) {\n      point[0] = xPx;\n    }\n\n    if (!isNaN(yPx)) {\n      point[1] = yPx;\n    }\n  }\n\n  data.setItemLayout(idx, point);\n}\n\nvar MarkLineView =\n/** @class */\nfunction (_super) {\n  __extends(MarkLineView, _super);\n\n  function MarkLineView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = MarkLineView.type;\n    return _this;\n  }\n\n  MarkLineView.prototype.updateTransform = function (markLineModel, ecModel, api) {\n    ecModel.eachSeries(function (seriesModel) {\n      var mlModel = MarkerModel.getMarkerModelFromSeries(seriesModel, 'markLine');\n\n      if (mlModel) {\n        var mlData_1 = mlModel.getData();\n        var fromData_1 = inner(mlModel).from;\n        var toData_1 = inner(mlModel).to; // Update visual and layout of from symbol and to symbol\n\n        fromData_1.each(function (idx) {\n          updateSingleMarkerEndLayout(fromData_1, idx, true, seriesModel, api);\n          updateSingleMarkerEndLayout(toData_1, idx, false, seriesModel, api);\n        }); // Update layout of line\n\n        mlData_1.each(function (idx) {\n          mlData_1.setItemLayout(idx, [fromData_1.getItemLayout(idx), toData_1.getItemLayout(idx)]);\n        });\n        this.markerGroupMap.get(seriesModel.id).updateLayout();\n      }\n    }, this);\n  };\n\n  MarkLineView.prototype.renderSeries = function (seriesModel, mlModel, ecModel, api) {\n    var coordSys = seriesModel.coordinateSystem;\n    var seriesId = seriesModel.id;\n    var seriesData = seriesModel.getData();\n    var lineDrawMap = this.markerGroupMap;\n    var lineDraw = lineDrawMap.get(seriesId) || lineDrawMap.set(seriesId, new LineDraw());\n    this.group.add(lineDraw.group);\n    var mlData = createList(coordSys, seriesModel, mlModel);\n    var fromData = mlData.from;\n    var toData = mlData.to;\n    var lineData = mlData.line;\n    inner(mlModel).from = fromData;\n    inner(mlModel).to = toData; // Line data for tooltip and formatter\n\n    mlModel.setData(lineData); // TODO\n    // Functionally, `symbolSize` & `symbolOffset` can also be 2D array now.\n    // But the related logic and type definition are not finished yet.\n    // Finish it if required\n\n    var symbolType = mlModel.get('symbol');\n    var symbolSize = mlModel.get('symbolSize');\n    var symbolRotate = mlModel.get('symbolRotate');\n    var symbolOffset = mlModel.get('symbolOffset'); // TODO: support callback function like markPoint\n\n    if (!isArray(symbolType)) {\n      symbolType = [symbolType, symbolType];\n    }\n\n    if (!isArray(symbolSize)) {\n      symbolSize = [symbolSize, symbolSize];\n    }\n\n    if (!isArray(symbolRotate)) {\n      symbolRotate = [symbolRotate, symbolRotate];\n    }\n\n    if (!isArray(symbolOffset)) {\n      symbolOffset = [symbolOffset, symbolOffset];\n    } // Update visual and layout of from symbol and to symbol\n\n\n    mlData.from.each(function (idx) {\n      updateDataVisualAndLayout(fromData, idx, true);\n      updateDataVisualAndLayout(toData, idx, false);\n    }); // Update visual and layout of line\n\n    lineData.each(function (idx) {\n      var lineStyle = lineData.getItemModel(idx).getModel('lineStyle').getLineStyle(); // lineData.setItemVisual(idx, {\n      //     color: lineColor || fromData.getItemVisual(idx, 'color')\n      // });\n\n      lineData.setItemLayout(idx, [fromData.getItemLayout(idx), toData.getItemLayout(idx)]);\n\n      if (lineStyle.stroke == null) {\n        lineStyle.stroke = fromData.getItemVisual(idx, 'style').fill;\n      }\n\n      lineData.setItemVisual(idx, {\n        fromSymbolKeepAspect: fromData.getItemVisual(idx, 'symbolKeepAspect'),\n        fromSymbolOffset: fromData.getItemVisual(idx, 'symbolOffset'),\n        fromSymbolRotate: fromData.getItemVisual(idx, 'symbolRotate'),\n        fromSymbolSize: fromData.getItemVisual(idx, 'symbolSize'),\n        fromSymbol: fromData.getItemVisual(idx, 'symbol'),\n        toSymbolKeepAspect: toData.getItemVisual(idx, 'symbolKeepAspect'),\n        toSymbolOffset: toData.getItemVisual(idx, 'symbolOffset'),\n        toSymbolRotate: toData.getItemVisual(idx, 'symbolRotate'),\n        toSymbolSize: toData.getItemVisual(idx, 'symbolSize'),\n        toSymbol: toData.getItemVisual(idx, 'symbol'),\n        style: lineStyle\n      });\n    });\n    lineDraw.updateData(lineData); // Set host model for tooltip\n    // FIXME\n\n    mlData.line.eachItemGraphicEl(function (el) {\n      getECData(el).dataModel = mlModel;\n      el.traverse(function (child) {\n        getECData(child).dataModel = mlModel;\n      });\n    });\n\n    function updateDataVisualAndLayout(data, idx, isFrom) {\n      var itemModel = data.getItemModel(idx);\n      updateSingleMarkerEndLayout(data, idx, isFrom, seriesModel, api);\n      var style = itemModel.getModel('itemStyle').getItemStyle();\n\n      if (style.fill == null) {\n        style.fill = getVisualFromData(seriesData, 'color');\n      }\n\n      data.setItemVisual(idx, {\n        symbolKeepAspect: itemModel.get('symbolKeepAspect'),\n        // `0` should be considered as a valid value, so use `retrieve2` instead of `||`\n        symbolOffset: retrieve2(itemModel.get('symbolOffset', true), symbolOffset[isFrom ? 0 : 1]),\n        symbolRotate: retrieve2(itemModel.get('symbolRotate', true), symbolRotate[isFrom ? 0 : 1]),\n        // TODO: when 2d array is supported, it should ignore parent\n        symbolSize: retrieve2(itemModel.get('symbolSize'), symbolSize[isFrom ? 0 : 1]),\n        symbol: retrieve2(itemModel.get('symbol', true), symbolType[isFrom ? 0 : 1]),\n        style: style\n      });\n    }\n\n    this.markKeep(lineDraw);\n    lineDraw.group.silent = mlModel.get('silent') || seriesModel.get('silent');\n  };\n\n  MarkLineView.type = 'markLine';\n  return MarkLineView;\n}(MarkerView);\n\nfunction createList(coordSys, seriesModel, mlModel) {\n  var coordDimsInfos;\n\n  if (coordSys) {\n    coordDimsInfos = map(coordSys && coordSys.dimensions, function (coordDim) {\n      var info = seriesModel.getData().getDimensionInfo(seriesModel.getData().mapDimension(coordDim)) || {}; // In map series data don't have lng and lat dimension. Fallback to same with coordSys\n\n      return extend(extend({}, info), {\n        name: coordDim,\n        // DON'T use ordinalMeta to parse and collect ordinal.\n        ordinalMeta: null\n      });\n    });\n  } else {\n    coordDimsInfos = [{\n      name: 'value',\n      type: 'float'\n    }];\n  }\n\n  var fromData = new SeriesData(coordDimsInfos, mlModel);\n  var toData = new SeriesData(coordDimsInfos, mlModel); // No dimensions\n\n  var lineData = new SeriesData([], mlModel);\n  var optData = map(mlModel.get('data'), curry(markLineTransform, seriesModel, coordSys, mlModel));\n\n  if (coordSys) {\n    optData = filter(optData, curry(markLineFilter, coordSys));\n  }\n\n  var dimValueGetter = markerHelper.createMarkerDimValueGetter(!!coordSys, coordDimsInfos);\n  fromData.initData(map(optData, function (item) {\n    return item[0];\n  }), null, dimValueGetter);\n  toData.initData(map(optData, function (item) {\n    return item[1];\n  }), null, dimValueGetter);\n  lineData.initData(map(optData, function (item) {\n    return item[2];\n  }));\n  lineData.hasItemOption = true;\n  return {\n    from: fromData,\n    to: toData,\n    line: lineData\n  };\n}\n\nexport default MarkLineView;"],"names":["MarkAreaModel","_super","_this","apply","this","arguments","type","__extends","prototype","createMarkerModelFromSeries","markerOpt","masterMarkerModel","ecModel","defaultOption","z","tooltip","trigger","animation","label","show","position","itemStyle","borderWidth","emphasis","MarkerModel","inner","makeInner","markAreaTransform","seriesModel","coordSys","maModel","item","lt","markerHelper","rb","ltCoord","coord","rbCoord","retrieve","Infinity","result","mergeAll","x0","x","y0","y","x1","y1","isInfinity","val","isNaN","isFinite","ifMarkAreaHasOnlyDim","dimIndex","fromCoord","toCoord","otherDimIndex","markAreaFilter","item0","item1","isCoordinateSystemType","getSingleMarkerEndPoint","data","idx","dims","api","point","coordinateSystem","itemModel","getItemModel","xPx","numberUtil","get","getWidth","yPx","getHeight","getMarkerPosition","getValues","pt","clampData","dataToPoint","xAxis","getAxis","yAxis","toGlobalCoord","getExtent","dimPermutations","MarkAreaView","updateTransform","markAreaModel","eachSeries","areaData_1","getData","each","points","map","dim","setItemLayout","getItemGraphicEl","setShape","renderSeries","seriesId","id","seriesData","areaGroupMap","markerGroupMap","polygonGroup","set","group","graphic","add","markKeep","areaData","dataDims","coordDimsInfos_1","dimensions","coordDim","info","getDimensionInfo","mapDimension","extend","name","ordinalMeta","SeriesData","optData","curry","filter","dimValueGetter","dimName","dataIndex","rawVal","Math","floor","parseDataValue","value","initData","hasItemOption","createList","setData","xAxisScale","scale","yAxisScale","xAxisExtent","yAxisExtent","xPointExtent","parse","yPointExtent","allClipped","style","getModel","getItemStyle","color","getVisualFromData","fill","isString","colorUtil","stroke","setItemVisual","diff","layout","getItemLayout","polygon","shape","setItemGraphicEl","update","newIdx","oldIdx","remove","execute","eachItemGraphicEl","getItemVisual","useStyle","setLabelStyle","getLabelStatesModels","labelFetcher","labelDataIndex","defaultText","getName","inheritColor","setStatesStylesFromModel","toggleHoverEmphasis","getECData","dataModel","silent","MarkerView","MarkLineModel","symbol","symbolSize","symbolOffset","precision","distance","lineStyle","width","animationEasing","markLineTransform","mlModel","itemArray","isArray","mlType","valueAxis","axisInfo","valueDataDim","getStackedDimension","valueIndex","baseIndex","mlFrom","clone","mlTo","isNumber","toFixed","min","normalizedItem","merge","ifMarkLineHasOnlyDim","containData","markLineFilter","updateSingleMarkerEndLayout","isFrom","MarkLineView","markLineModel","mlData_1","fromData_1","from","toData_1","to","updateLayout","lineDrawMap","lineDraw","LineDraw","mlData","coordDimsInfos","fromData","toData","lineData","line","symbolType","symbolRotate","updateDataVisualAndLayout","symbolKeepAspect","retrieve2","getLineStyle","fromSymbolKeepAspect","fromSymbolOffset","fromSymbolRotate","fromSymbolSize","fromSymbol","toSymbolKeepAspect","toSymbolOffset","toSymbolRotate","toSymbolSize","toSymbol","updateData","el","traverse","child"],"sourceRoot":""}
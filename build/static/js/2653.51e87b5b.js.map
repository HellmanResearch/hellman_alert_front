{"version":3,"file":"static/js/2653.51e87b5b.js","mappings":"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","sources":["../node_modules/echarts/lib/data/helper/SeriesDataSchema.js","../node_modules/echarts/lib/data/helper/createDimensions.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { createHashMap, isObject, retrieve2 } from 'zrender/lib/core/util.js';\nimport { makeInner } from '../../util/model.js';\nimport { shouldRetrieveDataByName } from '../Source.js';\nvar inner = makeInner();\nvar dimTypeShort = {\n  float: 'f',\n  int: 'i',\n  ordinal: 'o',\n  number: 'n',\n  time: 't'\n};\n/**\n * Represents the dimension requirement of a series.\n *\n * NOTICE:\n * When there are too many dimensions in dataset and many series, only the used dimensions\n * (i.e., used by coord sys and declared in `series.encode`) are add to `dimensionDefineList`.\n * But users may query data by other unused dimension names.\n * In this case, users can only query data if and only if they have defined dimension names\n * via ec option, so we provide `getDimensionIndexFromSource`, which only query them from\n * `source` dimensions.\n */\n\nvar SeriesDataSchema =\n/** @class */\nfunction () {\n  function SeriesDataSchema(opt) {\n    this.dimensions = opt.dimensions;\n    this._dimOmitted = opt.dimensionOmitted;\n    this.source = opt.source;\n    this._fullDimCount = opt.fullDimensionCount;\n\n    this._updateDimOmitted(opt.dimensionOmitted);\n  }\n\n  SeriesDataSchema.prototype.isDimensionOmitted = function () {\n    return this._dimOmitted;\n  };\n\n  SeriesDataSchema.prototype._updateDimOmitted = function (dimensionOmitted) {\n    this._dimOmitted = dimensionOmitted;\n\n    if (!dimensionOmitted) {\n      return;\n    }\n\n    if (!this._dimNameMap) {\n      this._dimNameMap = ensureSourceDimNameMap(this.source);\n    }\n  };\n  /**\n   * @caution Can only be used when `dimensionOmitted: true`.\n   *\n   * Get index by user defined dimension name (i.e., not internal generate name).\n   * That is, get index from `dimensionsDefine`.\n   * If no `dimensionsDefine`, or no name get, return -1.\n   */\n\n\n  SeriesDataSchema.prototype.getSourceDimensionIndex = function (dimName) {\n    return retrieve2(this._dimNameMap.get(dimName), -1);\n  };\n  /**\n   * @caution Can only be used when `dimensionOmitted: true`.\n   *\n   * Notice: may return `null`/`undefined` if user not specify dimension names.\n   */\n\n\n  SeriesDataSchema.prototype.getSourceDimension = function (dimIndex) {\n    var dimensionsDefine = this.source.dimensionsDefine;\n\n    if (dimensionsDefine) {\n      return dimensionsDefine[dimIndex];\n    }\n  };\n\n  SeriesDataSchema.prototype.makeStoreSchema = function () {\n    var dimCount = this._fullDimCount;\n    var willRetrieveDataByName = shouldRetrieveDataByName(this.source);\n    var makeHashStrict = !shouldOmitUnusedDimensions(dimCount); // If source don't have dimensions or series don't omit unsed dimensions.\n    // Generate from seriesDimList directly\n\n    var dimHash = '';\n    var dims = [];\n\n    for (var fullDimIdx = 0, seriesDimIdx = 0; fullDimIdx < dimCount; fullDimIdx++) {\n      var property = void 0;\n      var type = void 0;\n      var ordinalMeta = void 0;\n      var seriesDimDef = this.dimensions[seriesDimIdx]; // The list has been sorted by `storeDimIndex` asc.\n\n      if (seriesDimDef && seriesDimDef.storeDimIndex === fullDimIdx) {\n        property = willRetrieveDataByName ? seriesDimDef.name : null;\n        type = seriesDimDef.type;\n        ordinalMeta = seriesDimDef.ordinalMeta;\n        seriesDimIdx++;\n      } else {\n        var sourceDimDef = this.getSourceDimension(fullDimIdx);\n\n        if (sourceDimDef) {\n          property = willRetrieveDataByName ? sourceDimDef.name : null;\n          type = sourceDimDef.type;\n        }\n      }\n\n      dims.push({\n        property: property,\n        type: type,\n        ordinalMeta: ordinalMeta\n      }); // If retrieving data by index,\n      //   use <index, type, ordinalMeta> to determine whether data can be shared.\n      //   (Becuase in this case there might be no dimension name defined in dataset, but indices always exists).\n      //   (indices are always 0, 1, 2, ..., so we can ignore them to shorten the hash).\n      // Otherwise if retrieving data by property name (like `data: [{aa: 123, bb: 765}, ...]`),\n      //   use <property, type, ordinalMeta> in hash.\n\n      if (willRetrieveDataByName && property != null // For data stack, we have make sure each series has its own dim on this store.\n      // So we do not add property to hash to make sure they can share this store.\n      && (!seriesDimDef || !seriesDimDef.isCalculationCoord)) {\n        dimHash += makeHashStrict // Use escape character '`' in case that property name contains '$'.\n        ? property.replace(/\\`/g, '`1').replace(/\\$/g, '`2') // For better performance, when there are large dimensions, tolerant this defects that hardly meet.\n        : property;\n      }\n\n      dimHash += '$';\n      dimHash += dimTypeShort[type] || 'f';\n\n      if (ordinalMeta) {\n        dimHash += ordinalMeta.uid;\n      }\n\n      dimHash += '$';\n    } // Source from endpoint(usually series) will be read differently\n    // when seriesLayoutBy or startIndex(which is affected by sourceHeader) are different.\n    // So we use this three props as key.\n\n\n    var source = this.source;\n    var hash = [source.seriesLayoutBy, source.startIndex, dimHash].join('$$');\n    return {\n      dimensions: dims,\n      hash: hash\n    };\n  };\n\n  SeriesDataSchema.prototype.makeOutputDimensionNames = function () {\n    var result = [];\n\n    for (var fullDimIdx = 0, seriesDimIdx = 0; fullDimIdx < this._fullDimCount; fullDimIdx++) {\n      var name_1 = void 0;\n      var seriesDimDef = this.dimensions[seriesDimIdx]; // The list has been sorted by `storeDimIndex` asc.\n\n      if (seriesDimDef && seriesDimDef.storeDimIndex === fullDimIdx) {\n        if (!seriesDimDef.isCalculationCoord) {\n          name_1 = seriesDimDef.name;\n        }\n\n        seriesDimIdx++;\n      } else {\n        var sourceDimDef = this.getSourceDimension(fullDimIdx);\n\n        if (sourceDimDef) {\n          name_1 = sourceDimDef.name;\n        }\n      }\n\n      result.push(name_1);\n    }\n\n    return result;\n  };\n\n  SeriesDataSchema.prototype.appendCalculationDimension = function (dimDef) {\n    this.dimensions.push(dimDef);\n    dimDef.isCalculationCoord = true;\n    this._fullDimCount++; // If append dimension on a data store, consider the store\n    // might be shared by different series, series dimensions not\n    // really map to store dimensions.\n\n    this._updateDimOmitted(true);\n  };\n\n  return SeriesDataSchema;\n}();\n\nexport { SeriesDataSchema };\nexport function isSeriesDataSchema(schema) {\n  return schema instanceof SeriesDataSchema;\n}\nexport function createDimNameMap(dimsDef) {\n  var dataDimNameMap = createHashMap();\n\n  for (var i = 0; i < (dimsDef || []).length; i++) {\n    var dimDefItemRaw = dimsDef[i];\n    var userDimName = isObject(dimDefItemRaw) ? dimDefItemRaw.name : dimDefItemRaw;\n\n    if (userDimName != null && dataDimNameMap.get(userDimName) == null) {\n      dataDimNameMap.set(userDimName, i);\n    }\n  }\n\n  return dataDimNameMap;\n}\nexport function ensureSourceDimNameMap(source) {\n  var innerSource = inner(source);\n  return innerSource.dimNameMap || (innerSource.dimNameMap = createDimNameMap(source.dimensionsDefine));\n}\nexport function shouldOmitUnusedDimensions(dimCount) {\n  return dimCount > 30;\n}","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { VISUAL_DIMENSIONS } from '../../util/types.js';\nimport SeriesDimensionDefine from '../SeriesDimensionDefine.js';\nimport { createHashMap, defaults, each, extend, isObject, isString } from 'zrender/lib/core/util.js';\nimport { createSourceFromSeriesDataOption, isSourceInstance } from '../Source.js';\nimport { CtorInt32Array } from '../DataStore.js';\nimport { normalizeToArray } from '../../util/model.js';\nimport { BE_ORDINAL, guessOrdinal } from './sourceHelper.js';\nimport { createDimNameMap, ensureSourceDimNameMap, SeriesDataSchema, shouldOmitUnusedDimensions } from './SeriesDataSchema.js';\n/**\n * For outside usage compat (like echarts-gl are using it).\n */\n\nexport function createDimensions(source, opt) {\n  return prepareSeriesDataSchema(source, opt).dimensions;\n}\n/**\n * This method builds the relationship between:\n * + \"what the coord sys or series requires (see `coordDimensions`)\",\n * + \"what the user defines (in `encode` and `dimensions`, see `opt.dimensionsDefine` and `opt.encodeDefine`)\"\n * + \"what the data source provids (see `source`)\".\n *\n * Some guess strategy will be adapted if user does not define something.\n * If no 'value' dimension specified, the first no-named dimension will be\n * named as 'value'.\n *\n * @return The results are always sorted by `storeDimIndex` asc.\n */\n\nexport default function prepareSeriesDataSchema( // TODO: TYPE completeDimensions type\nsource, opt) {\n  if (!isSourceInstance(source)) {\n    source = createSourceFromSeriesDataOption(source);\n  }\n\n  opt = opt || {};\n  var sysDims = opt.coordDimensions || [];\n  var dimsDef = opt.dimensionsDefine || source.dimensionsDefine || [];\n  var coordDimNameMap = createHashMap();\n  var resultList = [];\n  var dimCount = getDimCount(source, sysDims, dimsDef, opt.dimensionsCount); // Try to ignore unsed dimensions if sharing a high dimension datastore\n  // 30 is an experience value.\n\n  var omitUnusedDimensions = opt.canOmitUnusedDimensions && shouldOmitUnusedDimensions(dimCount);\n  var isUsingSourceDimensionsDef = dimsDef === source.dimensionsDefine;\n  var dataDimNameMap = isUsingSourceDimensionsDef ? ensureSourceDimNameMap(source) : createDimNameMap(dimsDef);\n  var encodeDef = opt.encodeDefine;\n\n  if (!encodeDef && opt.encodeDefaulter) {\n    encodeDef = opt.encodeDefaulter(source, dimCount);\n  }\n\n  var encodeDefMap = createHashMap(encodeDef);\n  var indicesMap = new CtorInt32Array(dimCount);\n\n  for (var i = 0; i < indicesMap.length; i++) {\n    indicesMap[i] = -1;\n  }\n\n  function getResultItem(dimIdx) {\n    var idx = indicesMap[dimIdx];\n\n    if (idx < 0) {\n      var dimDefItemRaw = dimsDef[dimIdx];\n      var dimDefItem = isObject(dimDefItemRaw) ? dimDefItemRaw : {\n        name: dimDefItemRaw\n      };\n      var resultItem = new SeriesDimensionDefine();\n      var userDimName = dimDefItem.name;\n\n      if (userDimName != null && dataDimNameMap.get(userDimName) != null) {\n        // Only if `series.dimensions` is defined in option\n        // displayName, will be set, and dimension will be diplayed vertically in\n        // tooltip by default.\n        resultItem.name = resultItem.displayName = userDimName;\n      }\n\n      dimDefItem.type != null && (resultItem.type = dimDefItem.type);\n      dimDefItem.displayName != null && (resultItem.displayName = dimDefItem.displayName);\n      var newIdx = resultList.length;\n      indicesMap[dimIdx] = newIdx;\n      resultItem.storeDimIndex = dimIdx;\n      resultList.push(resultItem);\n      return resultItem;\n    }\n\n    return resultList[idx];\n  }\n\n  if (!omitUnusedDimensions) {\n    for (var i = 0; i < dimCount; i++) {\n      getResultItem(i);\n    }\n  } // Set `coordDim` and `coordDimIndex` by `encodeDefMap` and normalize `encodeDefMap`.\n\n\n  encodeDefMap.each(function (dataDimsRaw, coordDim) {\n    var dataDims = normalizeToArray(dataDimsRaw).slice(); // Note: It is allowed that `dataDims.length` is `0`, e.g., options is\n    // `{encode: {x: -1, y: 1}}`. Should not filter anything in\n    // this case.\n\n    if (dataDims.length === 1 && !isString(dataDims[0]) && dataDims[0] < 0) {\n      encodeDefMap.set(coordDim, false);\n      return;\n    }\n\n    var validDataDims = encodeDefMap.set(coordDim, []);\n    each(dataDims, function (resultDimIdxOrName, idx) {\n      // The input resultDimIdx can be dim name or index.\n      var resultDimIdx = isString(resultDimIdxOrName) ? dataDimNameMap.get(resultDimIdxOrName) : resultDimIdxOrName;\n\n      if (resultDimIdx != null && resultDimIdx < dimCount) {\n        validDataDims[idx] = resultDimIdx;\n        applyDim(getResultItem(resultDimIdx), coordDim, idx);\n      }\n    });\n  }); // Apply templetes and default order from `sysDims`.\n\n  var availDimIdx = 0;\n  each(sysDims, function (sysDimItemRaw) {\n    var coordDim;\n    var sysDimItemDimsDef;\n    var sysDimItemOtherDims;\n    var sysDimItem;\n\n    if (isString(sysDimItemRaw)) {\n      coordDim = sysDimItemRaw;\n      sysDimItem = {};\n    } else {\n      sysDimItem = sysDimItemRaw;\n      coordDim = sysDimItem.name;\n      var ordinalMeta = sysDimItem.ordinalMeta;\n      sysDimItem.ordinalMeta = null;\n      sysDimItem = extend({}, sysDimItem);\n      sysDimItem.ordinalMeta = ordinalMeta; // `coordDimIndex` should not be set directly.\n\n      sysDimItemDimsDef = sysDimItem.dimsDef;\n      sysDimItemOtherDims = sysDimItem.otherDims;\n      sysDimItem.name = sysDimItem.coordDim = sysDimItem.coordDimIndex = sysDimItem.dimsDef = sysDimItem.otherDims = null;\n    }\n\n    var dataDims = encodeDefMap.get(coordDim); // negative resultDimIdx means no need to mapping.\n\n    if (dataDims === false) {\n      return;\n    }\n\n    dataDims = normalizeToArray(dataDims); // dimensions provides default dim sequences.\n\n    if (!dataDims.length) {\n      for (var i = 0; i < (sysDimItemDimsDef && sysDimItemDimsDef.length || 1); i++) {\n        while (availDimIdx < dimCount && getResultItem(availDimIdx).coordDim != null) {\n          availDimIdx++;\n        }\n\n        availDimIdx < dimCount && dataDims.push(availDimIdx++);\n      }\n    } // Apply templates.\n\n\n    each(dataDims, function (resultDimIdx, coordDimIndex) {\n      var resultItem = getResultItem(resultDimIdx); // Coordinate system has a higher priority on dim type than source.\n\n      if (isUsingSourceDimensionsDef && sysDimItem.type != null) {\n        resultItem.type = sysDimItem.type;\n      }\n\n      applyDim(defaults(resultItem, sysDimItem), coordDim, coordDimIndex);\n\n      if (resultItem.name == null && sysDimItemDimsDef) {\n        var sysDimItemDimsDefItem = sysDimItemDimsDef[coordDimIndex];\n        !isObject(sysDimItemDimsDefItem) && (sysDimItemDimsDefItem = {\n          name: sysDimItemDimsDefItem\n        });\n        resultItem.name = resultItem.displayName = sysDimItemDimsDefItem.name;\n        resultItem.defaultTooltip = sysDimItemDimsDefItem.defaultTooltip;\n      } // FIXME refactor, currently only used in case: {otherDims: {tooltip: false}}\n\n\n      sysDimItemOtherDims && defaults(resultItem.otherDims, sysDimItemOtherDims);\n    });\n  });\n\n  function applyDim(resultItem, coordDim, coordDimIndex) {\n    if (VISUAL_DIMENSIONS.get(coordDim) != null) {\n      resultItem.otherDims[coordDim] = coordDimIndex;\n    } else {\n      resultItem.coordDim = coordDim;\n      resultItem.coordDimIndex = coordDimIndex;\n      coordDimNameMap.set(coordDim, true);\n    }\n  } // Make sure the first extra dim is 'value'.\n\n\n  var generateCoord = opt.generateCoord;\n  var generateCoordCount = opt.generateCoordCount;\n  var fromZero = generateCoordCount != null;\n  generateCoordCount = generateCoord ? generateCoordCount || 1 : 0;\n  var extra = generateCoord || 'value';\n\n  function ifNoNameFillWithCoordName(resultItem) {\n    if (resultItem.name == null) {\n      // Duplication will be removed in the next step.\n      resultItem.name = resultItem.coordDim;\n    }\n  } // Set dim `name` and other `coordDim` and other props.\n\n\n  if (!omitUnusedDimensions) {\n    for (var resultDimIdx = 0; resultDimIdx < dimCount; resultDimIdx++) {\n      var resultItem = getResultItem(resultDimIdx);\n      var coordDim = resultItem.coordDim;\n\n      if (coordDim == null) {\n        // TODO no need to generate coordDim for isExtraCoord?\n        resultItem.coordDim = genCoordDimName(extra, coordDimNameMap, fromZero);\n        resultItem.coordDimIndex = 0; // Series specified generateCoord is using out.\n\n        if (!generateCoord || generateCoordCount <= 0) {\n          resultItem.isExtraCoord = true;\n        }\n\n        generateCoordCount--;\n      }\n\n      ifNoNameFillWithCoordName(resultItem);\n\n      if (resultItem.type == null && (guessOrdinal(source, resultDimIdx) === BE_ORDINAL.Must // Consider the case:\n      // {\n      //    dataset: {source: [\n      //        ['2001', 123],\n      //        ['2002', 456],\n      //        ...\n      //        ['The others', 987],\n      //    ]},\n      //    series: {type: 'pie'}\n      // }\n      // The first colum should better be treated as a \"ordinal\" although it\n      // might not able to be detected as an \"ordinal\" by `guessOrdinal`.\n      || resultItem.isExtraCoord && (resultItem.otherDims.itemName != null || resultItem.otherDims.seriesName != null))) {\n        resultItem.type = 'ordinal';\n      }\n    }\n  } else {\n    each(resultList, function (resultItem) {\n      // PENDING: guessOrdinal or let user specify type: 'ordinal' manually?\n      ifNoNameFillWithCoordName(resultItem);\n    }); // Sort dimensions: there are some rule that use the last dim as label,\n    // and for some latter travel process easier.\n\n    resultList.sort(function (item0, item1) {\n      return item0.storeDimIndex - item1.storeDimIndex;\n    });\n  }\n\n  removeDuplication(resultList);\n  return new SeriesDataSchema({\n    source: source,\n    dimensions: resultList,\n    fullDimensionCount: dimCount,\n    dimensionOmitted: omitUnusedDimensions\n  });\n}\n\nfunction removeDuplication(result) {\n  var duplicationMap = createHashMap();\n\n  for (var i = 0; i < result.length; i++) {\n    var dim = result[i];\n    var dimOriginalName = dim.name;\n    var count = duplicationMap.get(dimOriginalName) || 0;\n\n    if (count > 0) {\n      // Starts from 0.\n      dim.name = dimOriginalName + (count - 1);\n    }\n\n    count++;\n    duplicationMap.set(dimOriginalName, count);\n  }\n} // ??? TODO\n// Originally detect dimCount by data[0]. Should we\n// optimize it to only by sysDims and dimensions and encode.\n// So only necessary dims will be initialized.\n// But\n// (1) custom series should be considered. where other dims\n// may be visited.\n// (2) sometimes user need to calcualte bubble size or use visualMap\n// on other dimensions besides coordSys needed.\n// So, dims that is not used by system, should be shared in data store?\n\n\nfunction getDimCount(source, sysDims, dimsDef, optDimCount) {\n  // Note that the result dimCount should not small than columns count\n  // of data, otherwise `dataDimNameMap` checking will be incorrect.\n  var dimCount = Math.max(source.dimensionsDetectedCount || 1, sysDims.length, dimsDef.length, optDimCount || 0);\n  each(sysDims, function (sysDimItem) {\n    var sysDimItemDimsDef;\n\n    if (isObject(sysDimItem) && (sysDimItemDimsDef = sysDimItem.dimsDef)) {\n      dimCount = Math.max(dimCount, sysDimItemDimsDef.length);\n    }\n  });\n  return dimCount;\n}\n\nfunction genCoordDimName(name, map, fromZero) {\n  var mapData = map.data;\n\n  if (fromZero || mapData.hasOwnProperty(name)) {\n    var i = 0;\n\n    while (mapData.hasOwnProperty(name + i)) {\n      i++;\n    }\n\n    name += i;\n  }\n\n  map.set(name, true);\n  return name;\n}"],"names":["inner","makeInner","dimTypeShort","float","int","ordinal","number","time","SeriesDataSchema","opt","this","dimensions","_dimOmitted","dimensionOmitted","source","_fullDimCount","fullDimensionCount","_updateDimOmitted","prototype","isDimensionOmitted","_dimNameMap","ensureSourceDimNameMap","getSourceDimensionIndex","dimName","retrieve2","get","getSourceDimension","dimIndex","dimensionsDefine","makeStoreSchema","dimCount","willRetrieveDataByName","shouldRetrieveDataByName","makeHashStrict","shouldOmitUnusedDimensions","dimHash","dims","fullDimIdx","seriesDimIdx","property","type","ordinalMeta","seriesDimDef","storeDimIndex","name","sourceDimDef","push","isCalculationCoord","replace","uid","hash","seriesLayoutBy","startIndex","join","makeOutputDimensionNames","result","name_1","appendCalculationDimension","dimDef","isSeriesDataSchema","schema","createDimNameMap","dimsDef","dataDimNameMap","createHashMap","i","length","dimDefItemRaw","userDimName","isObject","set","innerSource","dimNameMap","prepareSeriesDataSchema","isSourceInstance","createSourceFromSeriesDataOption","sysDims","coordDimensions","coordDimNameMap","resultList","optDimCount","Math","max","dimensionsDetectedCount","each","sysDimItem","sysDimItemDimsDef","getDimCount","dimensionsCount","omitUnusedDimensions","canOmitUnusedDimensions","isUsingSourceDimensionsDef","encodeDef","encodeDefine","encodeDefaulter","encodeDefMap","indicesMap","CtorInt32Array","getResultItem","dimIdx","idx","dimDefItem","resultItem","SeriesDimensionDefine","displayName","newIdx","dataDimsRaw","coordDim","dataDims","normalizeToArray","slice","isString","validDataDims","resultDimIdxOrName","resultDimIdx","applyDim","availDimIdx","coordDimIndex","VISUAL_DIMENSIONS","otherDims","sysDimItemRaw","sysDimItemOtherDims","extend","defaults","sysDimItemDimsDefItem","defaultTooltip","generateCoord","generateCoordCount","fromZero","extra","ifNoNameFillWithCoordName","sort","item0","item1","genCoordDimName","isExtraCoord","guessOrdinal","BE_ORDINAL","itemName","seriesName","duplicationMap","dim","dimOriginalName","count","removeDuplication","map","mapData","data","hasOwnProperty"],"sourceRoot":""}
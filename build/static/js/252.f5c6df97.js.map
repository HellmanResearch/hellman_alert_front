{"version":3,"file":"static/js/252.f5c6df97.js","mappings":"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","sources":["../node_modules/echarts/lib/coord/geo/GeoJSONResource.js","../node_modules/echarts/lib/coord/geo/GeoModel.js","../node_modules/echarts/lib/coord/geo/GeoSVGResource.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { each, isString, createHashMap, hasOwn } from 'zrender/lib/core/util.js';\nimport parseGeoJson from './parseGeoJson.js'; // Built-in GEO fixer.\n\nimport fixNanhai from './fix/nanhai.js';\nimport fixTextCoord from './fix/textCoord.js';\nimport fixDiaoyuIsland from './fix/diaoyuIsland.js';\nimport BoundingRect from 'zrender/lib/core/BoundingRect.js';\nvar DEFAULT_NAME_PROPERTY = 'name';\n\nvar GeoJSONResource =\n/** @class */\nfunction () {\n  function GeoJSONResource(mapName, geoJSON, specialAreas) {\n    this.type = 'geoJSON';\n    this._parsedMap = createHashMap();\n    this._mapName = mapName;\n    this._specialAreas = specialAreas; // PENDING: delay the parse to the first usage to rapid up the FMP?\n\n    this._geoJSON = parseInput(geoJSON);\n  }\n  /**\n   * @param nameMap can be null/undefined\n   * @param nameProperty can be null/undefined\n   */\n\n\n  GeoJSONResource.prototype.load = function (nameMap, nameProperty) {\n    nameProperty = nameProperty || DEFAULT_NAME_PROPERTY;\n\n    var parsed = this._parsedMap.get(nameProperty);\n\n    if (!parsed) {\n      var rawRegions = this._parseToRegions(nameProperty);\n\n      parsed = this._parsedMap.set(nameProperty, {\n        regions: rawRegions,\n        boundingRect: calculateBoundingRect(rawRegions)\n      });\n    }\n\n    var regionsMap = createHashMap();\n    var finalRegions = [];\n    each(parsed.regions, function (region) {\n      var regionName = region.name; // Try use the alias in geoNameMap\n\n      if (nameMap && hasOwn(nameMap, regionName)) {\n        region = region.cloneShallow(regionName = nameMap[regionName]);\n      }\n\n      finalRegions.push(region);\n      regionsMap.set(regionName, region);\n    });\n    return {\n      regions: finalRegions,\n      boundingRect: parsed.boundingRect || new BoundingRect(0, 0, 0, 0),\n      regionsMap: regionsMap\n    };\n  };\n\n  GeoJSONResource.prototype._parseToRegions = function (nameProperty) {\n    var mapName = this._mapName;\n    var geoJSON = this._geoJSON;\n    var rawRegions; // https://jsperf.com/try-catch-performance-overhead\n\n    try {\n      rawRegions = geoJSON ? parseGeoJson(geoJSON, nameProperty) : [];\n    } catch (e) {\n      throw new Error('Invalid geoJson format\\n' + e.message);\n    }\n\n    fixNanhai(mapName, rawRegions);\n    each(rawRegions, function (region) {\n      var regionName = region.name;\n      fixTextCoord(mapName, region);\n      fixDiaoyuIsland(mapName, region); // Some area like Alaska in USA map needs to be tansformed\n      // to look better\n\n      var specialArea = this._specialAreas && this._specialAreas[regionName];\n\n      if (specialArea) {\n        region.transformTo(specialArea.left, specialArea.top, specialArea.width, specialArea.height);\n      }\n    }, this);\n    return rawRegions;\n  };\n  /**\n   * Only for exporting to users.\n   * **MUST NOT** used internally.\n   */\n\n\n  GeoJSONResource.prototype.getMapForUser = function () {\n    return {\n      // For backward compatibility, use geoJson\n      // PENDING: it has been returning them without clone.\n      // do we need to avoid outsite modification?\n      geoJson: this._geoJSON,\n      geoJSON: this._geoJSON,\n      specialAreas: this._specialAreas\n    };\n  };\n\n  return GeoJSONResource;\n}();\n\nexport { GeoJSONResource };\n\nfunction calculateBoundingRect(regions) {\n  var rect;\n\n  for (var i = 0; i < regions.length; i++) {\n    var regionRect = regions[i].getBoundingRect();\n    rect = rect || regionRect.clone();\n    rect.union(regionRect);\n  }\n\n  return rect;\n}\n\nfunction parseInput(source) {\n  return !isString(source) ? source : typeof JSON !== 'undefined' && JSON.parse ? JSON.parse(source) : new Function('return (' + source + ');')();\n}","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\";\nimport * as zrUtil from 'zrender/lib/core/util.js';\nimport * as modelUtil from '../../util/model.js';\nimport ComponentModel from '../../model/Component.js';\nimport Model from '../../model/Model.js';\nimport geoCreator from './geoCreator.js';\nimport geoSourceManager from './geoSourceManager.js';\n;\n\nvar GeoModel =\n/** @class */\nfunction (_super) {\n  __extends(GeoModel, _super);\n\n  function GeoModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = GeoModel.type;\n    return _this;\n  }\n\n  GeoModel.prototype.init = function (option, parentModel, ecModel) {\n    var source = geoSourceManager.getGeoResource(option.map);\n\n    if (source && source.type === 'geoJSON') {\n      var itemStyle = option.itemStyle = option.itemStyle || {};\n\n      if (!('color' in itemStyle)) {\n        itemStyle.color = '#eee';\n      }\n    }\n\n    this.mergeDefaultAndTheme(option, ecModel); // Default label emphasis `show`\n\n    modelUtil.defaultEmphasis(option, 'label', ['show']);\n  };\n\n  GeoModel.prototype.optionUpdated = function () {\n    var _this = this;\n\n    var option = this.option;\n    option.regions = geoCreator.getFilledRegions(option.regions, option.map, option.nameMap, option.nameProperty);\n    var selectedMap = {};\n    this._optionModelMap = zrUtil.reduce(option.regions || [], function (optionModelMap, regionOpt) {\n      var regionName = regionOpt.name;\n\n      if (regionName) {\n        optionModelMap.set(regionName, new Model(regionOpt, _this, _this.ecModel));\n\n        if (regionOpt.selected) {\n          selectedMap[regionName] = true;\n        }\n      }\n\n      return optionModelMap;\n    }, zrUtil.createHashMap());\n\n    if (!option.selectedMap) {\n      option.selectedMap = selectedMap;\n    }\n  };\n  /**\n   * Get model of region.\n   */\n\n\n  GeoModel.prototype.getRegionModel = function (name) {\n    return this._optionModelMap.get(name) || new Model(null, this, this.ecModel);\n  };\n  /**\n   * Format label\n   * @param name Region name\n   */\n\n\n  GeoModel.prototype.getFormattedLabel = function (name, status) {\n    var regionModel = this.getRegionModel(name);\n    var formatter = status === 'normal' ? regionModel.get(['label', 'formatter']) : regionModel.get(['emphasis', 'label', 'formatter']);\n    var params = {\n      name: name\n    };\n\n    if (zrUtil.isFunction(formatter)) {\n      params.status = status;\n      return formatter(params);\n    } else if (zrUtil.isString(formatter)) {\n      return formatter.replace('{a}', name != null ? name : '');\n    }\n  };\n\n  GeoModel.prototype.setZoom = function (zoom) {\n    this.option.zoom = zoom;\n  };\n\n  GeoModel.prototype.setCenter = function (center) {\n    this.option.center = center;\n  }; // PENGING If selectedMode is null ?\n\n\n  GeoModel.prototype.select = function (name) {\n    var option = this.option;\n    var selectedMode = option.selectedMode;\n\n    if (!selectedMode) {\n      return;\n    }\n\n    if (selectedMode !== 'multiple') {\n      option.selectedMap = null;\n    }\n\n    var selectedMap = option.selectedMap || (option.selectedMap = {});\n    selectedMap[name] = true;\n  };\n\n  GeoModel.prototype.unSelect = function (name) {\n    var selectedMap = this.option.selectedMap;\n\n    if (selectedMap) {\n      selectedMap[name] = false;\n    }\n  };\n\n  GeoModel.prototype.toggleSelected = function (name) {\n    this[this.isSelected(name) ? 'unSelect' : 'select'](name);\n  };\n\n  GeoModel.prototype.isSelected = function (name) {\n    var selectedMap = this.option.selectedMap;\n    return !!(selectedMap && selectedMap[name]);\n  };\n\n  GeoModel.type = 'geo';\n  GeoModel.layoutMode = 'box';\n  GeoModel.defaultOption = {\n    // zlevel: 0,\n    z: 0,\n    show: true,\n    left: 'center',\n    top: 'center',\n    // Default value:\n    // for geoSVG source: 1,\n    // for geoJSON source: 0.75.\n    aspectScale: null,\n    ///// Layout with center and size\n    // If you wan't to put map in a fixed size box with right aspect ratio\n    // This two properties may more conveninet\n    // layoutCenter: [50%, 50%]\n    // layoutSize: 100\n    silent: false,\n    // Map type\n    map: '',\n    // Define left-top, right-bottom coords to control view\n    // For example, [ [180, 90], [-180, -90] ]\n    boundingCoords: null,\n    // Default on center of map\n    center: null,\n    zoom: 1,\n    scaleLimit: null,\n    // selectedMode: false\n    label: {\n      show: false,\n      color: '#000'\n    },\n    itemStyle: {\n      borderWidth: 0.5,\n      borderColor: '#444' // Default color:\n      // + geoJSON: #eee\n      // + geoSVG: null (use SVG original `fill`)\n      // color: '#eee'\n\n    },\n    emphasis: {\n      label: {\n        show: true,\n        color: 'rgb(100,0,0)'\n      },\n      itemStyle: {\n        color: 'rgba(255,215,0,0.8)'\n      }\n    },\n    select: {\n      label: {\n        show: true,\n        color: 'rgb(100,0,0)'\n      },\n      itemStyle: {\n        color: 'rgba(255,215,0,0.8)'\n      }\n    },\n    regions: [] // tooltip: {\n    //     show: false\n    // }\n\n  };\n  return GeoModel;\n}(ComponentModel);\n\nexport default GeoModel;","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { parseSVG, makeViewBoxTransform } from 'zrender/lib/tool/parseSVG.js';\nimport Group from 'zrender/lib/graphic/Group.js';\nimport Rect from 'zrender/lib/graphic/shape/Rect.js';\nimport { assert, createHashMap, each } from 'zrender/lib/core/util.js';\nimport BoundingRect from 'zrender/lib/core/BoundingRect.js';\nimport { parseXML } from 'zrender/lib/tool/parseXML.js';\nimport { GeoSVGRegion } from './Region.js';\n/**\n * \"region available\" means that: enable users to set attribute `name=\"xxx\"` on those tags\n * to make it be a region.\n * 1. region styles and its label styles can be defined in echarts opton:\n * ```js\n * geo: {\n *     regions: [{\n *         name: 'xxx',\n *         itemStyle: { ... },\n *         label: { ... }\n *     }, {\n *         ...\n *     },\n *     ...]\n * };\n * ```\n * 2. name can be duplicated in different SVG tag. All of the tags with the same name share\n * a region option. For exampel if there are two <path> representing two lung lobes. They have\n * no common parents but both of them need to display label \"lung\" inside.\n */\n\nvar REGION_AVAILABLE_SVG_TAG_MAP = createHashMap(['rect', 'circle', 'line', 'ellipse', 'polygon', 'polyline', 'path', // <text> <tspan> are also enabled becuase some SVG might paint text itself,\n// but still need to trigger events or tooltip.\n'text', 'tspan', // <g> is also enabled because this case: if multiple tags share one name\n// and need label displayed, every tags will display the name, which is not\n// expected. So we can put them into a <g name=\"xxx\">. Thereby only one label\n// displayed and located based on the bounding rect of the <g>.\n'g']);\n\nvar GeoSVGResource =\n/** @class */\nfunction () {\n  function GeoSVGResource(mapName, svg) {\n    this.type = 'geoSVG'; // All used graphics. key: hostKey, value: root\n\n    this._usedGraphicMap = createHashMap(); // All unused graphics.\n\n    this._freedGraphics = [];\n    this._mapName = mapName; // Only perform parse to XML object here, which might be time\n    // consiming for large SVG.\n    // Although convert XML to zrender element is also time consiming,\n    // if we do it here, the clone of zrender elements has to be\n    // required. So we do it once for each geo instance, util real\n    // performance issues call for optimizing it.\n\n    this._parsedXML = parseXML(svg);\n  }\n\n  GeoSVGResource.prototype.load = function ()\n  /* nameMap: NameMap */\n  {\n    // In the \"load\" stage, graphic need to be built to\n    // get boundingRect for geo coordinate system.\n    var firstGraphic = this._firstGraphic; // Create the return data structure only when first graphic created.\n    // Because they will be used in geo coordinate system update stage,\n    // and `regions` will be mounted at `geo` coordinate system,\n    // in which there is no \"view\" info, so that it should better not to\n    // make references to graphic elements.\n\n    if (!firstGraphic) {\n      firstGraphic = this._firstGraphic = this._buildGraphic(this._parsedXML);\n\n      this._freedGraphics.push(firstGraphic);\n\n      this._boundingRect = this._firstGraphic.boundingRect.clone(); // PENDING: `nameMap` will not be supported until some real requirement come.\n      // if (nameMap) {\n      //     named = applyNameMap(named, nameMap);\n      // }\n\n      var _a = createRegions(firstGraphic.named),\n          regions = _a.regions,\n          regionsMap = _a.regionsMap;\n\n      this._regions = regions;\n      this._regionsMap = regionsMap;\n    }\n\n    return {\n      boundingRect: this._boundingRect,\n      regions: this._regions,\n      regionsMap: this._regionsMap\n    };\n  };\n\n  GeoSVGResource.prototype._buildGraphic = function (svgXML) {\n    var result;\n    var rootFromParse;\n\n    try {\n      result = svgXML && parseSVG(svgXML, {\n        ignoreViewBox: true,\n        ignoreRootClip: true\n      }) || {};\n      rootFromParse = result.root;\n      assert(rootFromParse != null);\n    } catch (e) {\n      throw new Error('Invalid svg format\\n' + e.message);\n    } // Note: we keep the covenant that the root has no transform. So always add an extra root.\n\n\n    var root = new Group();\n    root.add(rootFromParse);\n    root.isGeoSVGGraphicRoot = true; // [THE_RULE_OF_VIEWPORT_AND_VIEWBOX]\n    //\n    // Consider: `<svg width=\"...\" height=\"...\" viewBox=\"...\">`\n    // - the `width/height` we call it `svgWidth/svgHeight` for short.\n    // - `(0, 0, svgWidth, svgHeight)` defines the viewport of the SVG, or say,\n    //   \"viewport boundingRect\", or `boundingRect` for short.\n    // - `viewBox` defines the transform from the real content ot the viewport.\n    //   `viewBox` has the same unit as the content of SVG.\n    //   If `viewBox` exists, a transform is defined, so the unit of `svgWidth/svgHeight` become\n    //   different from the content of SVG. Otherwise, they are the same.\n    //\n    // If both `svgWidth/svgHeight/viewBox` are specified in a SVG file, the transform rule will be:\n    // 0. `boundingRect` is `(0, 0, svgWidth, svgHeight)`. Set it to Geo['_rect'] (View['_rect']).\n    // 1. Make a transform from `viewBox` to `boundingRect`.\n    //    Note: only suport `preserveAspectRatio 'xMidYMid'` here. That is, this transform will preserve\n    //    the aspect ratio.\n    // 2. Make a transform from boundingRect to Geo['_viewRect'] (View['_viewRect'])\n    //    (`Geo`/`View` will do this job).\n    //    Note: this transform might not preserve aspect radio, which depending on how users specify\n    //    viewRect in echarts option (e.g., `geo.left/top/width/height` will not preserve aspect ratio,\n    //    but `geo.layoutCenter/layoutSize` will preserve aspect ratio).\n    //\n    // If `svgWidth/svgHeight` not specified, we use `viewBox` as the `boundingRect` to make the SVG\n    // layout look good.\n    //\n    // If neither `svgWidth/svgHeight` nor `viewBox` are not specified, we calculate the boundingRect\n    // of the SVG content and use them to make SVG layout look good.\n\n    var svgWidth = result.width;\n    var svgHeight = result.height;\n    var viewBoxRect = result.viewBoxRect;\n    var boundingRect = this._boundingRect;\n\n    if (!boundingRect) {\n      var bRectX = void 0;\n      var bRectY = void 0;\n      var bRectWidth = void 0;\n      var bRectHeight = void 0;\n\n      if (svgWidth != null) {\n        bRectX = 0;\n        bRectWidth = svgWidth;\n      } else if (viewBoxRect) {\n        bRectX = viewBoxRect.x;\n        bRectWidth = viewBoxRect.width;\n      }\n\n      if (svgHeight != null) {\n        bRectY = 0;\n        bRectHeight = svgHeight;\n      } else if (viewBoxRect) {\n        bRectY = viewBoxRect.y;\n        bRectHeight = viewBoxRect.height;\n      } // If both viewBox and svgWidth/svgHeight not specified,\n      // we have to determine how to layout those element to make them look good.\n\n\n      if (bRectX == null || bRectY == null) {\n        var calculatedBoundingRect = rootFromParse.getBoundingRect();\n\n        if (bRectX == null) {\n          bRectX = calculatedBoundingRect.x;\n          bRectWidth = calculatedBoundingRect.width;\n        }\n\n        if (bRectY == null) {\n          bRectY = calculatedBoundingRect.y;\n          bRectHeight = calculatedBoundingRect.height;\n        }\n      }\n\n      boundingRect = this._boundingRect = new BoundingRect(bRectX, bRectY, bRectWidth, bRectHeight);\n    }\n\n    if (viewBoxRect) {\n      var viewBoxTransform = makeViewBoxTransform(viewBoxRect, boundingRect); // Only support `preserveAspectRatio 'xMidYMid'`\n\n      rootFromParse.scaleX = rootFromParse.scaleY = viewBoxTransform.scale;\n      rootFromParse.x = viewBoxTransform.x;\n      rootFromParse.y = viewBoxTransform.y;\n    } // SVG needs to clip based on `viewBox`. And some SVG files really rely on this feature.\n    // They do not strictly confine all of the content inside a display rect, but deliberately\n    // use a `viewBox` to define a displayable rect.\n    // PENDING:\n    // The drawback of the `setClipPath` here is: the region label (genereted by echarts) near the\n    // edge might also be clipped, because region labels are put as `textContent` of the SVG path.\n\n\n    root.setClipPath(new Rect({\n      shape: boundingRect.plain()\n    }));\n    var named = [];\n    each(result.named, function (namedItem) {\n      if (REGION_AVAILABLE_SVG_TAG_MAP.get(namedItem.svgNodeTagLower) != null) {\n        named.push(namedItem);\n        setSilent(namedItem.el);\n      }\n    });\n    return {\n      root: root,\n      boundingRect: boundingRect,\n      named: named\n    };\n  };\n  /**\n   * Consider:\n   * (1) One graphic element can not be shared by different `geoView` running simultaneously.\n   *     Notice, also need to consider multiple echarts instances share a `mapRecord`.\n   * (2) Converting SVG to graphic elements is time consuming.\n   * (3) In the current architecture, `load` should be called frequently to get boundingRect,\n   *     and it is called without view info.\n   * So we maintain graphic elements in this module, and enables `view` to use/return these\n   * graphics from/to the pool with it's uid.\n   */\n\n\n  GeoSVGResource.prototype.useGraphic = function (hostKey\n  /*, nameMap: NameMap */\n  ) {\n    var usedRootMap = this._usedGraphicMap;\n    var svgGraphic = usedRootMap.get(hostKey);\n\n    if (svgGraphic) {\n      return svgGraphic;\n    }\n\n    svgGraphic = this._freedGraphics.pop() // use the first boundingRect to avoid duplicated boundingRect calculation.\n    || this._buildGraphic(this._parsedXML);\n    usedRootMap.set(hostKey, svgGraphic); // PENDING: `nameMap` will not be supported until some real requirement come.\n    // `nameMap` can only be obtained from echarts option.\n    // The original `named` must not be modified.\n    // if (nameMap) {\n    //     svgGraphic = extend({}, svgGraphic);\n    //     svgGraphic.named = applyNameMap(svgGraphic.named, nameMap);\n    // }\n\n    return svgGraphic;\n  };\n\n  GeoSVGResource.prototype.freeGraphic = function (hostKey) {\n    var usedRootMap = this._usedGraphicMap;\n    var svgGraphic = usedRootMap.get(hostKey);\n\n    if (svgGraphic) {\n      usedRootMap.removeKey(hostKey);\n\n      this._freedGraphics.push(svgGraphic);\n    }\n  };\n\n  return GeoSVGResource;\n}();\n\nexport { GeoSVGResource };\n\nfunction setSilent(el) {\n  // Only named element has silent: false, other elements should\n  // act as background and has no user interaction.\n  el.silent = false; // text|tspan will be converted to group.\n\n  if (el.isGroup) {\n    el.traverse(function (child) {\n      child.silent = false;\n    });\n  }\n}\n\nfunction createRegions(named) {\n  var regions = [];\n  var regionsMap = createHashMap(); // Create resions only for the first graphic.\n\n  each(named, function (namedItem) {\n    // Region has feature to calculate center for tooltip or other features.\n    // If there is a <g name=\"xxx\">, the center should be the center of the\n    // bounding rect of the g.\n    if (namedItem.namedFrom != null) {\n      return;\n    }\n\n    var region = new GeoSVGRegion(namedItem.name, namedItem.el); // PENDING: if `nameMap` supported, this region can not be mounted on\n    // `this`, but can only be created each time `load()` called.\n\n    regions.push(region); // PENDING: if multiple tag named with the same name, only one will be\n    // found by `_regionsMap`. `_regionsMap` is used to find a coordinate\n    // by name. We use `region.getCenter()` as the coordinate.\n\n    regionsMap.set(namedItem.name, region);\n  });\n  return {\n    regions: regions,\n    regionsMap: regionsMap\n  };\n} // PENDING: `nameMap` will not be supported until some real requirement come.\n// /**\n//  * Use the alias in geoNameMap.\n//  * The input `named` must not be modified.\n//  */\n// function applyNameMap(\n//     named: GeoSVGGraphicRecord['named'],\n//     nameMap: NameMap\n// ): GeoSVGGraphicRecord['named'] {\n//     const result = [] as GeoSVGGraphicRecord['named'];\n//     for (let i = 0; i < named.length; i++) {\n//         let regionGraphic = named[i];\n//         const name = regionGraphic.name;\n//         if (nameMap && nameMap.hasOwnProperty(name)) {\n//             regionGraphic = extend({}, regionGraphic);\n//             regionGraphic.name = name;\n//         }\n//         result.push(regionGraphic);\n//     }\n//     return result;\n// }"],"names":["GeoJSONResource","mapName","geoJSON","specialAreas","source","this","type","_parsedMap","createHashMap","_mapName","_specialAreas","_geoJSON","isString","JSON","parse","Function","prototype","load","nameMap","nameProperty","parsed","get","rawRegions","_parseToRegions","set","regions","boundingRect","calculateBoundingRect","regionsMap","finalRegions","each","region","regionName","name","hasOwn","cloneShallow","push","BoundingRect","parseGeoJson","e","Error","message","fixNanhai","fixTextCoord","fixDiaoyuIsland","specialArea","transformTo","left","top","width","height","getMapForUser","geoJson","rect","i","length","regionRect","getBoundingRect","clone","union","GeoModel","_super","_this","apply","arguments","__extends","init","option","parentModel","ecModel","geoSourceManager","map","itemStyle","color","mergeDefaultAndTheme","modelUtil","optionUpdated","geoCreator","selectedMap","_optionModelMap","zrUtil","optionModelMap","regionOpt","Model","selected","getRegionModel","getFormattedLabel","status","regionModel","formatter","params","replace","setZoom","zoom","setCenter","center","select","selectedMode","unSelect","toggleSelected","isSelected","layoutMode","defaultOption","z","show","aspectScale","silent","boundingCoords","scaleLimit","label","borderWidth","borderColor","emphasis","ComponentModel","REGION_AVAILABLE_SVG_TAG_MAP","GeoSVGResource","svg","_usedGraphicMap","_freedGraphics","_parsedXML","parseXML","firstGraphic","_firstGraphic","_buildGraphic","_boundingRect","_a","named","namedItem","namedFrom","GeoSVGRegion","el","createRegions","_regions","_regionsMap","svgXML","result","rootFromParse","parseSVG","ignoreViewBox","ignoreRootClip","root","assert","Group","add","isGeoSVGGraphicRoot","svgWidth","svgHeight","viewBoxRect","bRectX","bRectY","bRectWidth","bRectHeight","x","y","calculatedBoundingRect","viewBoxTransform","makeViewBoxTransform","scaleX","scaleY","scale","setClipPath","Rect","shape","plain","svgNodeTagLower","isGroup","traverse","child","useGraphic","hostKey","usedRootMap","svgGraphic","pop","freeGraphic","removeKey"],"sourceRoot":""}
{"version":3,"file":"static/js/2466.1b04ab1e.js","mappings":"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","sources":["../node_modules/echarts/lib/data/helper/dataProvider.js","../node_modules/echarts/lib/data/helper/dataStackHelper.js","../node_modules/echarts/lib/data/helper/dataValueHelper.js","../node_modules/echarts/lib/data/helper/dimensionHelper.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar _a, _b, _c; // TODO\n// ??? refactor? check the outer usage of data provider.\n// merge with defaultDimValueGetter?\n\n\nimport { isTypedArray, extend, assert, each, isObject, bind } from 'zrender/lib/core/util.js';\nimport { getDataItemValue } from '../../util/model.js';\nimport { createSourceFromSeriesDataOption, isSourceInstance } from '../Source.js';\nimport { SOURCE_FORMAT_ORIGINAL, SOURCE_FORMAT_OBJECT_ROWS, SOURCE_FORMAT_KEYED_COLUMNS, SOURCE_FORMAT_TYPED_ARRAY, SOURCE_FORMAT_ARRAY_ROWS, SERIES_LAYOUT_BY_COLUMN, SERIES_LAYOUT_BY_ROW } from '../../util/types.js';\nvar providerMethods;\nvar mountMethods;\n/**\n * If normal array used, mutable chunk size is supported.\n * If typed array used, chunk size must be fixed.\n */\n\nvar DefaultDataProvider =\n/** @class */\nfunction () {\n  function DefaultDataProvider(sourceParam, dimSize) {\n    // let source: Source;\n    var source = !isSourceInstance(sourceParam) ? createSourceFromSeriesDataOption(sourceParam) : sourceParam; // declare source is Source;\n\n    this._source = source;\n    var data = this._data = source.data; // Typed array. TODO IE10+?\n\n    if (source.sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (dimSize == null) {\n          throw new Error('Typed array data must specify dimension size');\n        }\n      }\n\n      this._offset = 0;\n      this._dimSize = dimSize;\n      this._data = data;\n    }\n\n    mountMethods(this, data, source);\n  }\n\n  DefaultDataProvider.prototype.getSource = function () {\n    return this._source;\n  };\n\n  DefaultDataProvider.prototype.count = function () {\n    return 0;\n  };\n\n  DefaultDataProvider.prototype.getItem = function (idx, out) {\n    return;\n  };\n\n  DefaultDataProvider.prototype.appendData = function (newData) {};\n\n  DefaultDataProvider.prototype.clean = function () {};\n\n  DefaultDataProvider.protoInitialize = function () {\n    // PENDING: To avoid potential incompat (e.g., prototype\n    // is visited somewhere), still init them on prototype.\n    var proto = DefaultDataProvider.prototype;\n    proto.pure = false;\n    proto.persistent = true;\n  }();\n\n  DefaultDataProvider.internalField = function () {\n    var _a;\n\n    mountMethods = function (provider, data, source) {\n      var sourceFormat = source.sourceFormat;\n      var seriesLayoutBy = source.seriesLayoutBy;\n      var startIndex = source.startIndex;\n      var dimsDef = source.dimensionsDefine;\n      var methods = providerMethods[getMethodMapKey(sourceFormat, seriesLayoutBy)];\n\n      if (process.env.NODE_ENV !== 'production') {\n        assert(methods, 'Invalide sourceFormat: ' + sourceFormat);\n      }\n\n      extend(provider, methods);\n\n      if (sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {\n        provider.getItem = getItemForTypedArray;\n        provider.count = countForTypedArray;\n        provider.fillStorage = fillStorageForTypedArray;\n      } else {\n        var rawItemGetter = getRawSourceItemGetter(sourceFormat, seriesLayoutBy);\n        provider.getItem = bind(rawItemGetter, null, data, startIndex, dimsDef);\n        var rawCounter = getRawSourceDataCounter(sourceFormat, seriesLayoutBy);\n        provider.count = bind(rawCounter, null, data, startIndex, dimsDef);\n      }\n    };\n\n    var getItemForTypedArray = function (idx, out) {\n      idx = idx - this._offset;\n      out = out || [];\n      var data = this._data;\n      var dimSize = this._dimSize;\n      var offset = dimSize * idx;\n\n      for (var i = 0; i < dimSize; i++) {\n        out[i] = data[offset + i];\n      }\n\n      return out;\n    };\n\n    var fillStorageForTypedArray = function (start, end, storage, extent) {\n      var data = this._data;\n      var dimSize = this._dimSize;\n\n      for (var dim = 0; dim < dimSize; dim++) {\n        var dimExtent = extent[dim];\n        var min = dimExtent[0] == null ? Infinity : dimExtent[0];\n        var max = dimExtent[1] == null ? -Infinity : dimExtent[1];\n        var count = end - start;\n        var arr = storage[dim];\n\n        for (var i = 0; i < count; i++) {\n          // appendData with TypedArray will always do replace in provider.\n          var val = data[i * dimSize + dim];\n          arr[start + i] = val;\n          val < min && (min = val);\n          val > max && (max = val);\n        }\n\n        dimExtent[0] = min;\n        dimExtent[1] = max;\n      }\n    };\n\n    var countForTypedArray = function () {\n      return this._data ? this._data.length / this._dimSize : 0;\n    };\n\n    providerMethods = (_a = {}, _a[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_COLUMN] = {\n      pure: true,\n      appendData: appendDataSimply\n    }, _a[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_ROW] = {\n      pure: true,\n      appendData: function () {\n        throw new Error('Do not support appendData when set seriesLayoutBy: \"row\".');\n      }\n    }, _a[SOURCE_FORMAT_OBJECT_ROWS] = {\n      pure: true,\n      appendData: appendDataSimply\n    }, _a[SOURCE_FORMAT_KEYED_COLUMNS] = {\n      pure: true,\n      appendData: function (newData) {\n        var data = this._data;\n        each(newData, function (newCol, key) {\n          var oldCol = data[key] || (data[key] = []);\n\n          for (var i = 0; i < (newCol || []).length; i++) {\n            oldCol.push(newCol[i]);\n          }\n        });\n      }\n    }, _a[SOURCE_FORMAT_ORIGINAL] = {\n      appendData: appendDataSimply\n    }, _a[SOURCE_FORMAT_TYPED_ARRAY] = {\n      persistent: false,\n      pure: true,\n      appendData: function (newData) {\n        if (process.env.NODE_ENV !== 'production') {\n          assert(isTypedArray(newData), 'Added data must be TypedArray if data in initialization is TypedArray');\n        }\n\n        this._data = newData;\n      },\n      // Clean self if data is already used.\n      clean: function () {\n        // PENDING\n        this._offset += this.count();\n        this._data = null;\n      }\n    }, _a);\n\n    function appendDataSimply(newData) {\n      for (var i = 0; i < newData.length; i++) {\n        this._data.push(newData[i]);\n      }\n    }\n  }();\n\n  return DefaultDataProvider;\n}();\n\nexport { DefaultDataProvider };\n\nvar getItemSimply = function (rawData, startIndex, dimsDef, idx) {\n  return rawData[idx];\n};\n\nvar rawSourceItemGetterMap = (_a = {}, _a[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_COLUMN] = function (rawData, startIndex, dimsDef, idx) {\n  return rawData[idx + startIndex];\n}, _a[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_ROW] = function (rawData, startIndex, dimsDef, idx, out) {\n  idx += startIndex;\n  var item = out || [];\n  var data = rawData;\n\n  for (var i = 0; i < data.length; i++) {\n    var row = data[i];\n    item[i] = row ? row[idx] : null;\n  }\n\n  return item;\n}, _a[SOURCE_FORMAT_OBJECT_ROWS] = getItemSimply, _a[SOURCE_FORMAT_KEYED_COLUMNS] = function (rawData, startIndex, dimsDef, idx, out) {\n  var item = out || [];\n\n  for (var i = 0; i < dimsDef.length; i++) {\n    var dimName = dimsDef[i].name;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (dimName == null) {\n        throw new Error();\n      }\n    }\n\n    var col = rawData[dimName];\n    item[i] = col ? col[idx] : null;\n  }\n\n  return item;\n}, _a[SOURCE_FORMAT_ORIGINAL] = getItemSimply, _a);\nexport function getRawSourceItemGetter(sourceFormat, seriesLayoutBy) {\n  var method = rawSourceItemGetterMap[getMethodMapKey(sourceFormat, seriesLayoutBy)];\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert(method, 'Do not support get item on \"' + sourceFormat + '\", \"' + seriesLayoutBy + '\".');\n  }\n\n  return method;\n}\n\nvar countSimply = function (rawData, startIndex, dimsDef) {\n  return rawData.length;\n};\n\nvar rawSourceDataCounterMap = (_b = {}, _b[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_COLUMN] = function (rawData, startIndex, dimsDef) {\n  return Math.max(0, rawData.length - startIndex);\n}, _b[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_ROW] = function (rawData, startIndex, dimsDef) {\n  var row = rawData[0];\n  return row ? Math.max(0, row.length - startIndex) : 0;\n}, _b[SOURCE_FORMAT_OBJECT_ROWS] = countSimply, _b[SOURCE_FORMAT_KEYED_COLUMNS] = function (rawData, startIndex, dimsDef) {\n  var dimName = dimsDef[0].name;\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (dimName == null) {\n      throw new Error();\n    }\n  }\n\n  var col = rawData[dimName];\n  return col ? col.length : 0;\n}, _b[SOURCE_FORMAT_ORIGINAL] = countSimply, _b);\nexport function getRawSourceDataCounter(sourceFormat, seriesLayoutBy) {\n  var method = rawSourceDataCounterMap[getMethodMapKey(sourceFormat, seriesLayoutBy)];\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert(method, 'Do not suppport count on \"' + sourceFormat + '\", \"' + seriesLayoutBy + '\".');\n  }\n\n  return method;\n}\n\nvar getRawValueSimply = function (dataItem, dimIndex, property) {\n  return dataItem[dimIndex];\n};\n\nvar rawSourceValueGetterMap = (_c = {}, _c[SOURCE_FORMAT_ARRAY_ROWS] = getRawValueSimply, _c[SOURCE_FORMAT_OBJECT_ROWS] = function (dataItem, dimIndex, property) {\n  return dataItem[property];\n}, _c[SOURCE_FORMAT_KEYED_COLUMNS] = getRawValueSimply, _c[SOURCE_FORMAT_ORIGINAL] = function (dataItem, dimIndex, property) {\n  // FIXME: In some case (markpoint in geo (geo-map.html)),\n  // dataItem is {coord: [...]}\n  var value = getDataItemValue(dataItem);\n  return !(value instanceof Array) ? value : value[dimIndex];\n}, _c[SOURCE_FORMAT_TYPED_ARRAY] = getRawValueSimply, _c);\nexport function getRawSourceValueGetter(sourceFormat) {\n  var method = rawSourceValueGetterMap[sourceFormat];\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert(method, 'Do not suppport get value on \"' + sourceFormat + '\".');\n  }\n\n  return method;\n}\n\nfunction getMethodMapKey(sourceFormat, seriesLayoutBy) {\n  return sourceFormat === SOURCE_FORMAT_ARRAY_ROWS ? sourceFormat + '_' + seriesLayoutBy : sourceFormat;\n} // ??? FIXME can these logic be more neat: getRawValue, getRawDataItem,\n// Consider persistent.\n// Caution: why use raw value to display on label or tooltip?\n// A reason is to avoid format. For example time value we do not know\n// how to format is expected. More over, if stack is used, calculated\n// value may be 0.91000000001, which have brings trouble to display.\n// TODO: consider how to treat null/undefined/NaN when display?\n\n\nexport function retrieveRawValue(data, dataIndex, // If dimIndex is null/undefined, return OptionDataItem.\n// Otherwise, return OptionDataValue.\ndim) {\n  if (!data) {\n    return;\n  } // Consider data may be not persistent.\n\n\n  var dataItem = data.getRawDataItem(dataIndex);\n\n  if (dataItem == null) {\n    return;\n  }\n\n  var store = data.getStore();\n  var sourceFormat = store.getSource().sourceFormat;\n\n  if (dim != null) {\n    var dimIndex = data.getDimensionIndex(dim);\n    var property = store.getDimensionProperty(dimIndex);\n    return getRawSourceValueGetter(sourceFormat)(dataItem, dimIndex, property);\n  } else {\n    var result = dataItem;\n\n    if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {\n      result = getDataItemValue(dataItem);\n    }\n\n    return result;\n  }\n}\n/**\n * Compatible with some cases (in pie, map) like:\n * data: [{name: 'xx', value: 5, selected: true}, ...]\n * where only sourceFormat is 'original' and 'objectRows' supported.\n *\n * // TODO\n * Supported detail options in data item when using 'arrayRows'.\n *\n * @param data\n * @param dataIndex\n * @param attr like 'selected'\n */\n\nexport function retrieveRawAttr(data, dataIndex, attr) {\n  if (!data) {\n    return;\n  }\n\n  var sourceFormat = data.getStore().getSource().sourceFormat;\n\n  if (sourceFormat !== SOURCE_FORMAT_ORIGINAL && sourceFormat !== SOURCE_FORMAT_OBJECT_ROWS) {\n    return;\n  }\n\n  var dataItem = data.getRawDataItem(dataIndex);\n\n  if (sourceFormat === SOURCE_FORMAT_ORIGINAL && !isObject(dataItem)) {\n    dataItem = null;\n  }\n\n  if (dataItem) {\n    return dataItem[attr];\n  }\n}","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { each, isString } from 'zrender/lib/core/util.js';\nimport { isSeriesDataSchema } from './SeriesDataSchema.js';\n/**\n * Note that it is too complicated to support 3d stack by value\n * (have to create two-dimension inverted index), so in 3d case\n * we just support that stacked by index.\n *\n * @param seriesModel\n * @param dimensionsInput The same as the input of <module:echarts/data/SeriesData>.\n *        The input will be modified.\n * @param opt\n * @param opt.stackedCoordDimension Specify a coord dimension if needed.\n * @param opt.byIndex=false\n * @return calculationInfo\n * {\n *     stackedDimension: string\n *     stackedByDimension: string\n *     isStackedByIndex: boolean\n *     stackedOverDimension: string\n *     stackResultDimension: string\n * }\n */\n\nexport function enableDataStack(seriesModel, dimensionsInput, opt) {\n  opt = opt || {};\n  var byIndex = opt.byIndex;\n  var stackedCoordDimension = opt.stackedCoordDimension;\n  var dimensionDefineList;\n  var schema;\n  var store;\n\n  if (isLegacyDimensionsInput(dimensionsInput)) {\n    dimensionDefineList = dimensionsInput;\n  } else {\n    schema = dimensionsInput.schema;\n    dimensionDefineList = schema.dimensions;\n    store = dimensionsInput.store;\n  } // Compatibal: when `stack` is set as '', do not stack.\n\n\n  var mayStack = !!(seriesModel && seriesModel.get('stack'));\n  var stackedByDimInfo;\n  var stackedDimInfo;\n  var stackResultDimension;\n  var stackedOverDimension;\n  each(dimensionDefineList, function (dimensionInfo, index) {\n    if (isString(dimensionInfo)) {\n      dimensionDefineList[index] = dimensionInfo = {\n        name: dimensionInfo\n      };\n    }\n\n    if (mayStack && !dimensionInfo.isExtraCoord) {\n      // Find the first ordinal dimension as the stackedByDimInfo.\n      if (!byIndex && !stackedByDimInfo && dimensionInfo.ordinalMeta) {\n        stackedByDimInfo = dimensionInfo;\n      } // Find the first stackable dimension as the stackedDimInfo.\n\n\n      if (!stackedDimInfo && dimensionInfo.type !== 'ordinal' && dimensionInfo.type !== 'time' && (!stackedCoordDimension || stackedCoordDimension === dimensionInfo.coordDim)) {\n        stackedDimInfo = dimensionInfo;\n      }\n    }\n  });\n\n  if (stackedDimInfo && !byIndex && !stackedByDimInfo) {\n    // Compatible with previous design, value axis (time axis) only stack by index.\n    // It may make sense if the user provides elaborately constructed data.\n    byIndex = true;\n  } // Add stack dimension, they can be both calculated by coordinate system in `unionExtent`.\n  // That put stack logic in List is for using conveniently in echarts extensions, but it\n  // might not be a good way.\n\n\n  if (stackedDimInfo) {\n    // Use a weird name that not duplicated with other names.\n    // Also need to use seriesModel.id as postfix because different\n    // series may share same data store. The stack dimension needs to be distinguished.\n    stackResultDimension = '__\\0ecstackresult_' + seriesModel.id;\n    stackedOverDimension = '__\\0ecstackedover_' + seriesModel.id; // Create inverted index to fast query index by value.\n\n    if (stackedByDimInfo) {\n      stackedByDimInfo.createInvertedIndices = true;\n    }\n\n    var stackedDimCoordDim_1 = stackedDimInfo.coordDim;\n    var stackedDimType = stackedDimInfo.type;\n    var stackedDimCoordIndex_1 = 0;\n    each(dimensionDefineList, function (dimensionInfo) {\n      if (dimensionInfo.coordDim === stackedDimCoordDim_1) {\n        stackedDimCoordIndex_1++;\n      }\n    });\n    var stackedOverDimensionDefine = {\n      name: stackResultDimension,\n      coordDim: stackedDimCoordDim_1,\n      coordDimIndex: stackedDimCoordIndex_1,\n      type: stackedDimType,\n      isExtraCoord: true,\n      isCalculationCoord: true,\n      storeDimIndex: dimensionDefineList.length\n    };\n    var stackResultDimensionDefine = {\n      name: stackedOverDimension,\n      // This dimension contains stack base (generally, 0), so do not set it as\n      // `stackedDimCoordDim` to avoid extent calculation, consider log scale.\n      coordDim: stackedOverDimension,\n      coordDimIndex: stackedDimCoordIndex_1 + 1,\n      type: stackedDimType,\n      isExtraCoord: true,\n      isCalculationCoord: true,\n      storeDimIndex: dimensionDefineList.length + 1\n    };\n\n    if (schema) {\n      if (store) {\n        stackedOverDimensionDefine.storeDimIndex = store.ensureCalculationDimension(stackedOverDimension, stackedDimType);\n        stackResultDimensionDefine.storeDimIndex = store.ensureCalculationDimension(stackResultDimension, stackedDimType);\n      }\n\n      schema.appendCalculationDimension(stackedOverDimensionDefine);\n      schema.appendCalculationDimension(stackResultDimensionDefine);\n    } else {\n      dimensionDefineList.push(stackedOverDimensionDefine);\n      dimensionDefineList.push(stackResultDimensionDefine);\n    }\n  }\n\n  return {\n    stackedDimension: stackedDimInfo && stackedDimInfo.name,\n    stackedByDimension: stackedByDimInfo && stackedByDimInfo.name,\n    isStackedByIndex: byIndex,\n    stackedOverDimension: stackedOverDimension,\n    stackResultDimension: stackResultDimension\n  };\n}\n\nfunction isLegacyDimensionsInput(dimensionsInput) {\n  return !isSeriesDataSchema(dimensionsInput.schema);\n}\n\nexport function isDimensionStacked(data, stackedDim) {\n  // Each single series only maps to one pair of axis. So we do not need to\n  // check stackByDim, whatever stacked by a dimension or stacked by index.\n  return !!stackedDim && stackedDim === data.getCalculationInfo('stackedDimension');\n}\nexport function getStackedDimension(data, targetDim) {\n  return isDimensionStacked(data, targetDim) ? data.getCalculationInfo('stackResultDimension') : targetDim;\n}","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { parseDate, numericToNumber } from '../../util/number.js';\nimport { createHashMap, trim, hasOwn, isString, isNumber } from 'zrender/lib/core/util.js';\nimport { throwError } from '../../util/log.js';\n/**\n * Convert raw the value in to inner value in List.\n *\n * [Performance sensitive]\n *\n * [Caution]: this is the key logic of user value parser.\n * For backward compatibiliy, do not modify it until have to!\n */\n\nexport function parseDataValue(value, // For high performance, do not omit the second param.\nopt) {\n  // Performance sensitive.\n  var dimType = opt && opt.type;\n\n  if (dimType === 'ordinal') {\n    // If given value is a category string\n    return value;\n  }\n\n  if (dimType === 'time' // spead up when using timestamp\n  && !isNumber(value) && value != null && value !== '-') {\n    value = +parseDate(value);\n  } // dimType defaults 'number'.\n  // If dimType is not ordinal and value is null or undefined or NaN or '-',\n  // parse to NaN.\n  // number-like string (like ' 123 ') can be converted to a number.\n  // where null/undefined or other string will be converted to NaN.\n\n\n  return value == null || value === '' ? NaN // If string (like '-'), using '+' parse to NaN\n  // If object, also parse to NaN\n  : +value;\n}\n;\nvar valueParserMap = createHashMap({\n  'number': function (val) {\n    // Do not use `numericToNumber` here. We have by defualt `numericToNumber`.\n    // Here the number parser can have loose rule:\n    // enable to cut suffix: \"120px\" => 120, \"14%\" => 14.\n    return parseFloat(val);\n  },\n  'time': function (val) {\n    // return timestamp.\n    return +parseDate(val);\n  },\n  'trim': function (val) {\n    return isString(val) ? trim(val) : val;\n  }\n});\nexport function getRawValueParser(type) {\n  return valueParserMap.get(type);\n}\nvar ORDER_COMPARISON_OP_MAP = {\n  lt: function (lval, rval) {\n    return lval < rval;\n  },\n  lte: function (lval, rval) {\n    return lval <= rval;\n  },\n  gt: function (lval, rval) {\n    return lval > rval;\n  },\n  gte: function (lval, rval) {\n    return lval >= rval;\n  }\n};\n\nvar FilterOrderComparator =\n/** @class */\nfunction () {\n  function FilterOrderComparator(op, rval) {\n    if (!isNumber(rval)) {\n      var errMsg = '';\n\n      if (process.env.NODE_ENV !== 'production') {\n        errMsg = 'rvalue of \"<\", \">\", \"<=\", \">=\" can only be number in filter.';\n      }\n\n      throwError(errMsg);\n    }\n\n    this._opFn = ORDER_COMPARISON_OP_MAP[op];\n    this._rvalFloat = numericToNumber(rval);\n  } // Performance sensitive.\n\n\n  FilterOrderComparator.prototype.evaluate = function (lval) {\n    // Most cases is 'number', and typeof maybe 10 times faseter than parseFloat.\n    return isNumber(lval) ? this._opFn(lval, this._rvalFloat) : this._opFn(numericToNumber(lval), this._rvalFloat);\n  };\n\n  return FilterOrderComparator;\n}();\n\nvar SortOrderComparator =\n/** @class */\nfunction () {\n  /**\n   * @param order by defualt: 'asc'\n   * @param incomparable by defualt: Always on the tail.\n   *        That is, if 'asc' => 'max', if 'desc' => 'min'\n   *        See the definition of \"incomparable\" in [SORT_COMPARISON_RULE]\n   */\n  function SortOrderComparator(order, incomparable) {\n    var isDesc = order === 'desc';\n    this._resultLT = isDesc ? 1 : -1;\n\n    if (incomparable == null) {\n      incomparable = isDesc ? 'min' : 'max';\n    }\n\n    this._incomparable = incomparable === 'min' ? -Infinity : Infinity;\n  } // See [SORT_COMPARISON_RULE].\n  // Performance sensitive.\n\n\n  SortOrderComparator.prototype.evaluate = function (lval, rval) {\n    // Most cases is 'number', and typeof maybe 10 times faseter than parseFloat.\n    var lvalFloat = isNumber(lval) ? lval : numericToNumber(lval);\n    var rvalFloat = isNumber(rval) ? rval : numericToNumber(rval);\n    var lvalNotNumeric = isNaN(lvalFloat);\n    var rvalNotNumeric = isNaN(rvalFloat);\n\n    if (lvalNotNumeric) {\n      lvalFloat = this._incomparable;\n    }\n\n    if (rvalNotNumeric) {\n      rvalFloat = this._incomparable;\n    }\n\n    if (lvalNotNumeric && rvalNotNumeric) {\n      var lvalIsStr = isString(lval);\n      var rvalIsStr = isString(rval);\n\n      if (lvalIsStr) {\n        lvalFloat = rvalIsStr ? lval : 0;\n      }\n\n      if (rvalIsStr) {\n        rvalFloat = lvalIsStr ? rval : 0;\n      }\n    }\n\n    return lvalFloat < rvalFloat ? this._resultLT : lvalFloat > rvalFloat ? -this._resultLT : 0;\n  };\n\n  return SortOrderComparator;\n}();\n\nexport { SortOrderComparator };\n\nvar FilterEqualityComparator =\n/** @class */\nfunction () {\n  function FilterEqualityComparator(isEq, rval) {\n    this._rval = rval;\n    this._isEQ = isEq;\n    this._rvalTypeof = typeof rval;\n    this._rvalFloat = numericToNumber(rval);\n  } // Performance sensitive.\n\n\n  FilterEqualityComparator.prototype.evaluate = function (lval) {\n    var eqResult = lval === this._rval;\n\n    if (!eqResult) {\n      var lvalTypeof = typeof lval;\n\n      if (lvalTypeof !== this._rvalTypeof && (lvalTypeof === 'number' || this._rvalTypeof === 'number')) {\n        eqResult = numericToNumber(lval) === this._rvalFloat;\n      }\n    }\n\n    return this._isEQ ? eqResult : !eqResult;\n  };\n\n  return FilterEqualityComparator;\n}();\n/**\n * [FILTER_COMPARISON_RULE]\n * `lt`|`lte`|`gt`|`gte`:\n * + rval must be a number. And lval will be converted to number (`numericToNumber`) to compare.\n * `eq`:\n * + If same type, compare with `===`.\n * + If there is one number, convert to number (`numericToNumber`) to compare.\n * + Else return `false`.\n * `ne`:\n * + Not `eq`.\n *\n *\n * [SORT_COMPARISON_RULE]\n * All the values are grouped into three categories:\n * + \"numeric\" (number and numeric string)\n * + \"non-numeric-string\" (string that excluding numeric string)\n * + \"others\"\n * \"numeric\" vs \"numeric\": values are ordered by number order.\n * \"non-numeric-string\" vs \"non-numeric-string\": values are ordered by ES spec (#sec-abstract-relational-comparison).\n * \"others\" vs \"others\": do not change order (always return 0).\n * \"numeric\" vs \"non-numeric-string\": \"non-numeric-string\" is treated as \"incomparable\".\n * \"number\" vs \"others\": \"others\" is treated as \"incomparable\".\n * \"non-numeric-string\" vs \"others\": \"others\" is treated as \"incomparable\".\n * \"incomparable\" will be seen as -Infinity or Infinity (depends on the settings).\n * MEMO:\n *   non-numeric string sort make sence when need to put the items with the same tag together.\n *   But if we support string sort, we still need to avoid the misleading like `'2' > '12'`,\n *   So we treat \"numeric-string\" sorted by number order rather than string comparison.\n *\n *\n * [CHECK_LIST_OF_THE_RULE_DESIGN]\n * + Do not support string comparison until required. And also need to\n *   void the misleading of \"2\" > \"12\".\n * + Should avoid the misleading case:\n *   `\" 22 \" gte \"22\"` is `true` but `\" 22 \" eq \"22\"` is `false`.\n * + JS bad case should be avoided: null <= 0, [] <= 0, ' ' <= 0, ...\n * + Only \"numeric\" can be converted to comparable number, otherwise converted to NaN.\n *   See `util/number.ts#numericToNumber`.\n *\n * @return If `op` is not `RelationalOperator`, return null;\n */\n\n\nexport function createFilterComparator(op, rval) {\n  return op === 'eq' || op === 'ne' ? new FilterEqualityComparator(op === 'eq', rval) : hasOwn(ORDER_COMPARISON_OP_MAP, op) ? new FilterOrderComparator(op, rval) : null;\n}","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { each, createHashMap, assert, map } from 'zrender/lib/core/util.js';\nimport { VISUAL_DIMENSIONS } from '../../util/types.js';\n\nvar DimensionUserOuput =\n/** @class */\nfunction () {\n  function DimensionUserOuput(encode, dimRequest) {\n    this._encode = encode;\n    this._schema = dimRequest;\n  }\n\n  DimensionUserOuput.prototype.get = function () {\n    return {\n      // Do not generate full dimension name until fist used.\n      fullDimensions: this._getFullDimensionNames(),\n      encode: this._encode\n    };\n  };\n  /**\n   * Get all data store dimension names.\n   * Theoretically a series data store is defined both by series and used dataset (if any).\n   * If some dimensions are omitted for performance reason in `this.dimensions`,\n   * the dimension name may not be auto-generated if user does not specify a dimension name.\n   * In this case, the dimension name is `null`/`undefined`.\n   */\n\n\n  DimensionUserOuput.prototype._getFullDimensionNames = function () {\n    if (!this._cachedDimNames) {\n      this._cachedDimNames = this._schema ? this._schema.makeOutputDimensionNames() : [];\n    }\n\n    return this._cachedDimNames;\n  };\n\n  return DimensionUserOuput;\n}();\n\n;\nexport function summarizeDimensions(data, schema) {\n  var summary = {};\n  var encode = summary.encode = {};\n  var notExtraCoordDimMap = createHashMap();\n  var defaultedLabel = [];\n  var defaultedTooltip = [];\n  var userOutputEncode = {};\n  each(data.dimensions, function (dimName) {\n    var dimItem = data.getDimensionInfo(dimName);\n    var coordDim = dimItem.coordDim;\n\n    if (coordDim) {\n      if (process.env.NODE_ENV !== 'production') {\n        assert(VISUAL_DIMENSIONS.get(coordDim) == null);\n      }\n\n      var coordDimIndex = dimItem.coordDimIndex;\n      getOrCreateEncodeArr(encode, coordDim)[coordDimIndex] = dimName;\n\n      if (!dimItem.isExtraCoord) {\n        notExtraCoordDimMap.set(coordDim, 1); // Use the last coord dim (and label friendly) as default label,\n        // because when dataset is used, it is hard to guess which dimension\n        // can be value dimension. If both show x, y on label is not look good,\n        // and conventionally y axis is focused more.\n\n        if (mayLabelDimType(dimItem.type)) {\n          defaultedLabel[0] = dimName;\n        } // User output encode do not contain generated coords.\n        // And it only has index. User can use index to retrieve value from the raw item array.\n\n\n        getOrCreateEncodeArr(userOutputEncode, coordDim)[coordDimIndex] = data.getDimensionIndex(dimItem.name);\n      }\n\n      if (dimItem.defaultTooltip) {\n        defaultedTooltip.push(dimName);\n      }\n    }\n\n    VISUAL_DIMENSIONS.each(function (v, otherDim) {\n      var encodeArr = getOrCreateEncodeArr(encode, otherDim);\n      var dimIndex = dimItem.otherDims[otherDim];\n\n      if (dimIndex != null && dimIndex !== false) {\n        encodeArr[dimIndex] = dimItem.name;\n      }\n    });\n  });\n  var dataDimsOnCoord = [];\n  var encodeFirstDimNotExtra = {};\n  notExtraCoordDimMap.each(function (v, coordDim) {\n    var dimArr = encode[coordDim];\n    encodeFirstDimNotExtra[coordDim] = dimArr[0]; // Not necessary to remove duplicate, because a data\n    // dim canot on more than one coordDim.\n\n    dataDimsOnCoord = dataDimsOnCoord.concat(dimArr);\n  });\n  summary.dataDimsOnCoord = dataDimsOnCoord;\n  summary.dataDimIndicesOnCoord = map(dataDimsOnCoord, function (dimName) {\n    return data.getDimensionInfo(dimName).storeDimIndex;\n  });\n  summary.encodeFirstDimNotExtra = encodeFirstDimNotExtra;\n  var encodeLabel = encode.label; // FIXME `encode.label` is not recommanded, because formatter can not be set\n  // in this way. Use label.formatter instead. May be remove this approach someday.\n\n  if (encodeLabel && encodeLabel.length) {\n    defaultedLabel = encodeLabel.slice();\n  }\n\n  var encodeTooltip = encode.tooltip;\n\n  if (encodeTooltip && encodeTooltip.length) {\n    defaultedTooltip = encodeTooltip.slice();\n  } else if (!defaultedTooltip.length) {\n    defaultedTooltip = defaultedLabel.slice();\n  }\n\n  encode.defaultedLabel = defaultedLabel;\n  encode.defaultedTooltip = defaultedTooltip;\n  summary.userOutput = new DimensionUserOuput(userOutputEncode, schema);\n  return summary;\n}\n\nfunction getOrCreateEncodeArr(encode, dim) {\n  if (!encode.hasOwnProperty(dim)) {\n    encode[dim] = [];\n  }\n\n  return encode[dim];\n} // FIXME:TS should be type `AxisType`\n\n\nexport function getDimensionTypeByAxis(axisType) {\n  return axisType === 'category' ? 'ordinal' : axisType === 'time' ? 'time' : 'float';\n}\n\nfunction mayLabelDimType(dimType) {\n  // In most cases, ordinal and time do not suitable for label.\n  // Ordinal info can be displayed on axis. Time is too long.\n  return !(dimType === 'ordinal' || dimType === 'time');\n} // function findTheLastDimMayLabel(data) {\n//     // Get last value dim\n//     let dimensions = data.dimensions.slice();\n//     let valueType;\n//     let valueDim;\n//     while (dimensions.length && (\n//         valueDim = dimensions.pop(),\n//         valueType = data.getDimensionInfo(valueDim).type,\n//         valueType === 'ordinal' || valueType === 'time'\n//     )) {} // jshint ignore:line\n//     return valueDim;\n// }"],"names":["_a","_b","_c","providerMethods","mountMethods","DefaultDataProvider","sourceParam","dimSize","source","isSourceInstance","createSourceFromSeriesDataOption","this","_source","data","_data","sourceFormat","SOURCE_FORMAT_TYPED_ARRAY","_offset","_dimSize","prototype","getSource","count","getItem","idx","out","appendData","newData","clean","protoInitialize","proto","pure","persistent","internalField","provider","seriesLayoutBy","startIndex","dimsDef","dimensionsDefine","methods","getMethodMapKey","extend","getItemForTypedArray","countForTypedArray","fillStorage","fillStorageForTypedArray","rawItemGetter","getRawSourceItemGetter","bind","rawCounter","getRawSourceDataCounter","offset","i","start","end","storage","extent","dim","dimExtent","min","Infinity","max","arr","val","length","appendDataSimply","push","SOURCE_FORMAT_ARRAY_ROWS","SERIES_LAYOUT_BY_COLUMN","SERIES_LAYOUT_BY_ROW","Error","SOURCE_FORMAT_OBJECT_ROWS","SOURCE_FORMAT_KEYED_COLUMNS","each","newCol","key","oldCol","SOURCE_FORMAT_ORIGINAL","getItemSimply","rawData","rawSourceItemGetterMap","item","row","process","col","name","countSimply","rawSourceDataCounterMap","Math","getRawValueSimply","dataItem","dimIndex","property","rawSourceValueGetterMap","value","getDataItemValue","Array","getRawSourceValueGetter","retrieveRawValue","dataIndex","getRawDataItem","store","getStore","getDimensionIndex","getDimensionProperty","result","enableDataStack","seriesModel","dimensionsInput","opt","dimensionDefineList","schema","byIndex","stackedCoordDimension","isSeriesDataSchema","isLegacyDimensionsInput","dimensions","stackedByDimInfo","stackedDimInfo","stackResultDimension","stackedOverDimension","mayStack","get","dimensionInfo","index","isString","isExtraCoord","ordinalMeta","type","coordDim","id","createInvertedIndices","stackedDimCoordDim_1","stackedDimType","stackedDimCoordIndex_1","stackedOverDimensionDefine","coordDimIndex","isCalculationCoord","storeDimIndex","stackResultDimensionDefine","ensureCalculationDimension","appendCalculationDimension","stackedDimension","stackedByDimension","isStackedByIndex","isDimensionStacked","stackedDim","getCalculationInfo","getStackedDimension","targetDim","parseDataValue","dimType","isNumber","parseDate","NaN","valueParserMap","createHashMap","parseFloat","trim","getRawValueParser","ORDER_COMPARISON_OP_MAP","lt","lval","rval","lte","gt","gte","FilterOrderComparator","op","throwError","_opFn","_rvalFloat","numericToNumber","evaluate","SortOrderComparator","order","incomparable","isDesc","_resultLT","_incomparable","lvalFloat","rvalFloat","lvalNotNumeric","isNaN","rvalNotNumeric","lvalIsStr","rvalIsStr","FilterEqualityComparator","isEq","_rval","_isEQ","_rvalTypeof","eqResult","lvalTypeof","createFilterComparator","hasOwn","DimensionUserOuput","encode","dimRequest","_encode","_schema","fullDimensions","_getFullDimensionNames","_cachedDimNames","makeOutputDimensionNames","summarizeDimensions","summary","notExtraCoordDimMap","defaultedLabel","defaultedTooltip","userOutputEncode","dimName","dimItem","getDimensionInfo","getOrCreateEncodeArr","set","defaultTooltip","VISUAL_DIMENSIONS","v","otherDim","encodeArr","otherDims","dataDimsOnCoord","encodeFirstDimNotExtra","dimArr","concat","dataDimIndicesOnCoord","map","encodeLabel","label","slice","encodeTooltip","tooltip","userOutput","hasOwnProperty","getDimensionTypeByAxis","axisType"],"sourceRoot":""}
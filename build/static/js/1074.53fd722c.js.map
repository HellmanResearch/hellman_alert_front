{"version":3,"file":"static/js/1074.53fd722c.js","mappings":"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","sources":["../node_modules/echarts/lib/animation/morphTransitionHelper.js","../node_modules/echarts/lib/animation/universalTransition.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { separateMorph, combineMorph, morphPath, isCombineMorphing } from 'zrender/lib/tool/morphPath.js';\nimport { Path } from '../util/graphic.js';\nimport { defaults, isArray } from 'zrender/lib/core/util.js';\nimport { getAnimationConfig } from './basicTransition.js';\nimport { clonePath } from 'zrender/lib/tool/path.js';\n\nfunction isMultiple(elements) {\n  return isArray(elements[0]);\n}\n\nfunction prepareMorphBatches(one, many) {\n  var batches = [];\n  var batchCount = one.length;\n\n  for (var i = 0; i < batchCount; i++) {\n    batches.push({\n      one: one[i],\n      many: []\n    });\n  }\n\n  for (var i = 0; i < many.length; i++) {\n    var len = many[i].length;\n    var k = void 0;\n\n    for (k = 0; k < len; k++) {\n      batches[k % batchCount].many.push(many[i][k]);\n    }\n  }\n\n  var off = 0; // If one has more paths than each one of many. average them.\n\n  for (var i = batchCount - 1; i >= 0; i--) {\n    if (!batches[i].many.length) {\n      var moveFrom = batches[off].many;\n\n      if (moveFrom.length <= 1) {\n        // Not enough\n        // Start from the first one.\n        if (off) {\n          off = 0;\n        } else {\n          return batches;\n        }\n      }\n\n      var len = moveFrom.length;\n      var mid = Math.ceil(len / 2);\n      batches[i].many = moveFrom.slice(mid, len);\n      batches[off].many = moveFrom.slice(0, mid);\n      off++;\n    }\n  }\n\n  return batches;\n}\n\nvar pathDividers = {\n  clone: function (params) {\n    var ret = []; // Fitting the alpha\n\n    var approxOpacity = 1 - Math.pow(1 - params.path.style.opacity, 1 / params.count);\n\n    for (var i = 0; i < params.count; i++) {\n      var cloned = clonePath(params.path);\n      cloned.setStyle('opacity', approxOpacity);\n      ret.push(cloned);\n    }\n\n    return ret;\n  },\n  // Use the default divider\n  split: null\n};\nexport function applyMorphAnimation(from, to, divideShape, seriesModel, dataIndex, animateOtherProps) {\n  if (!from.length || !to.length) {\n    return;\n  }\n\n  var updateAnimationCfg = getAnimationConfig('update', seriesModel, dataIndex);\n\n  if (!(updateAnimationCfg && updateAnimationCfg.duration > 0)) {\n    return;\n  }\n\n  var animationDelay = seriesModel.getModel('universalTransition').get('delay');\n  var animationCfg = Object.assign({\n    // Need to setToFinal so the further calculation based on the style can be correct.\n    // Like emphasis color.\n    setToFinal: true\n  }, updateAnimationCfg);\n  var many;\n  var one;\n\n  if (isMultiple(from)) {\n    // manyToOne\n    many = from;\n    one = to;\n  }\n\n  if (isMultiple(to)) {\n    // oneToMany\n    many = to;\n    one = from;\n  }\n\n  function morphOneBatch(batch, fromIsMany, animateIndex, animateCount, forceManyOne) {\n    var batchMany = batch.many;\n    var batchOne = batch.one;\n\n    if (batchMany.length === 1 && !forceManyOne) {\n      // Is one to one\n      var batchFrom = fromIsMany ? batchMany[0] : batchOne;\n      var batchTo = fromIsMany ? batchOne : batchMany[0];\n\n      if (isCombineMorphing(batchFrom)) {\n        // Keep doing combine animation.\n        morphOneBatch({\n          many: [batchFrom],\n          one: batchTo\n        }, true, animateIndex, animateCount, true);\n      } else {\n        var individualAnimationCfg = animationDelay ? defaults({\n          delay: animationDelay(animateIndex, animateCount)\n        }, animationCfg) : animationCfg;\n        morphPath(batchFrom, batchTo, individualAnimationCfg);\n        animateOtherProps(batchFrom, batchTo, batchFrom, batchTo, individualAnimationCfg);\n      }\n    } else {\n      var separateAnimationCfg = defaults({\n        dividePath: pathDividers[divideShape],\n        individualDelay: animationDelay && function (idx, count, fromPath, toPath) {\n          return animationDelay(idx + animateIndex, animateCount);\n        }\n      }, animationCfg);\n\n      var _a = fromIsMany ? combineMorph(batchMany, batchOne, separateAnimationCfg) : separateMorph(batchOne, batchMany, separateAnimationCfg),\n          fromIndividuals = _a.fromIndividuals,\n          toIndividuals = _a.toIndividuals;\n\n      var count = fromIndividuals.length;\n\n      for (var k = 0; k < count; k++) {\n        var individualAnimationCfg = animationDelay ? defaults({\n          delay: animationDelay(k, count)\n        }, animationCfg) : animationCfg;\n        animateOtherProps(fromIndividuals[k], toIndividuals[k], fromIsMany ? batchMany[k] : batch.one, fromIsMany ? batch.one : batchMany[k], individualAnimationCfg);\n      }\n    }\n  }\n\n  var fromIsMany = many ? many === from // Is one to one. If the path number not match. also needs do merge and separate morphing.\n  : from.length > to.length;\n  var morphBatches = many ? prepareMorphBatches(one, many) : prepareMorphBatches(fromIsMany ? to : from, [fromIsMany ? from : to]);\n  var animateCount = 0;\n\n  for (var i = 0; i < morphBatches.length; i++) {\n    animateCount += morphBatches[i].many.length;\n  }\n\n  var animateIndex = 0;\n\n  for (var i = 0; i < morphBatches.length; i++) {\n    morphOneBatch(morphBatches[i], fromIsMany, animateIndex, animateCount);\n    animateIndex += morphBatches[i].many.length;\n  }\n}\nexport function getPathList(elements) {\n  if (!elements) {\n    return [];\n  }\n\n  if (isArray(elements)) {\n    var pathList_1 = [];\n\n    for (var i = 0; i < elements.length; i++) {\n      pathList_1.push(getPathList(elements[i]));\n    }\n\n    return pathList_1;\n  }\n\n  var pathList = [];\n  elements.traverse(function (el) {\n    if (el instanceof Path && !el.disableMorphing && !el.invisible && !el.ignore) {\n      pathList.push(el);\n    }\n  });\n  return pathList;\n}","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// Universal transitions that can animate between any shapes(series) and any properties in any amounts.\nimport { SERIES_UNIVERSAL_TRANSITION_PROP } from '../model/Series.js';\nimport { createHashMap, each, map, filter, isArray, extend } from 'zrender/lib/core/util.js';\nimport { applyMorphAnimation, getPathList } from './morphTransitionHelper.js';\nimport Path from 'zrender/lib/graphic/Path.js';\nimport { initProps } from '../util/graphic.js';\nimport DataDiffer from '../data/DataDiffer.js';\nimport { makeInner, normalizeToArray } from '../util/model.js';\nimport { warn } from '../util/log.js';\nimport { getAnimationConfig, getOldStyle } from './basicTransition.js';\nimport Displayable from 'zrender/lib/graphic/Displayable.js';\nvar DATA_COUNT_THRESHOLD = 1e4;\n;\nvar getUniversalTransitionGlobalStore = makeInner();\n\nfunction getGroupIdDimension(data) {\n  var dimensions = data.dimensions;\n\n  for (var i = 0; i < dimensions.length; i++) {\n    var dimInfo = data.getDimensionInfo(dimensions[i]);\n\n    if (dimInfo && dimInfo.otherDims.itemGroupId === 0) {\n      return dimensions[i];\n    }\n  }\n}\n\nfunction flattenDataDiffItems(list) {\n  var items = [];\n  each(list, function (seriesInfo) {\n    var data = seriesInfo.data;\n\n    if (data.count() > DATA_COUNT_THRESHOLD) {\n      if (process.env.NODE_ENV !== 'production') {\n        warn('Universal transition is disabled on large data > 10k.');\n      }\n\n      return;\n    }\n\n    var indices = data.getIndices();\n    var groupDim = getGroupIdDimension(data);\n\n    for (var dataIndex = 0; dataIndex < indices.length; dataIndex++) {\n      items.push({\n        data: data,\n        dim: seriesInfo.dim || groupDim,\n        divide: seriesInfo.divide,\n        dataIndex: dataIndex\n      });\n    }\n  });\n  return items;\n}\n\nfunction fadeInElement(newEl, newSeries, newIndex) {\n  newEl.traverse(function (el) {\n    if (el instanceof Path) {\n      // TODO use fade in animation for target element.\n      initProps(el, {\n        style: {\n          opacity: 0\n        }\n      }, newSeries, {\n        dataIndex: newIndex,\n        isFrom: true\n      });\n    }\n  });\n}\n\nfunction removeEl(el) {\n  if (el.parent) {\n    // Bake parent transform to element.\n    // So it can still have proper transform to transition after it's removed.\n    var computedTransform = el.getComputedTransform();\n    el.setLocalTransform(computedTransform);\n    el.parent.remove(el);\n  }\n}\n\nfunction stopAnimation(el) {\n  el.stopAnimation();\n\n  if (el.isGroup) {\n    el.traverse(function (child) {\n      child.stopAnimation();\n    });\n  }\n}\n\nfunction animateElementStyles(el, dataIndex, seriesModel) {\n  var animationConfig = getAnimationConfig('update', seriesModel, dataIndex);\n  animationConfig && el.traverse(function (child) {\n    if (child instanceof Displayable) {\n      var oldStyle = getOldStyle(child);\n\n      if (oldStyle) {\n        child.animateFrom({\n          style: oldStyle\n        }, animationConfig);\n      }\n    }\n  });\n}\n\nfunction isAllIdSame(oldDiffItems, newDiffItems) {\n  var len = oldDiffItems.length;\n\n  if (len !== newDiffItems.length) {\n    return false;\n  }\n\n  for (var i = 0; i < len; i++) {\n    var oldItem = oldDiffItems[i];\n    var newItem = newDiffItems[i];\n\n    if (oldItem.data.getId(oldItem.dataIndex) !== newItem.data.getId(newItem.dataIndex)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction transitionBetween(oldList, newList, api) {\n  var oldDiffItems = flattenDataDiffItems(oldList);\n  var newDiffItems = flattenDataDiffItems(newList);\n\n  function updateMorphingPathProps(from, to, rawFrom, rawTo, animationCfg) {\n    if (rawFrom || from) {\n      to.animateFrom({\n        style: rawFrom && rawFrom !== from ? // dividingMethod like clone may override the style(opacity)\n        // So extend it to raw style.\n        extend(extend({}, rawFrom.style), from.style) : from.style\n      }, animationCfg);\n    }\n  }\n\n  function findKeyDim(items) {\n    for (var i = 0; i < items.length; i++) {\n      if (items[i].dim) {\n        return items[i].dim;\n      }\n    }\n  }\n\n  var oldKeyDim = findKeyDim(oldDiffItems);\n  var newKeyDim = findKeyDim(newDiffItems);\n  var hasMorphAnimation = false;\n\n  function createKeyGetter(isOld, onlyGetId) {\n    return function (diffItem) {\n      var data = diffItem.data;\n      var dataIndex = diffItem.dataIndex; // TODO if specified dim\n\n      if (onlyGetId) {\n        return data.getId(dataIndex);\n      } // Use group id as transition key by default.\n      // So we can achieve multiple to multiple animation like drilldown / up naturally.\n      // If group id not exits. Use id instead. If so, only one to one transition will be applied.\n\n\n      var dataGroupId = data.hostModel && data.hostModel.get('dataGroupId'); // If specified key dimension(itemGroupId by default). Use this same dimension from other data.\n      // PENDING: If only use key dimension of newData.\n\n      var keyDim = isOld ? oldKeyDim || newKeyDim : newKeyDim || oldKeyDim;\n      var dimInfo = keyDim && data.getDimensionInfo(keyDim);\n      var dimOrdinalMeta = dimInfo && dimInfo.ordinalMeta;\n\n      if (dimInfo) {\n        // Get from encode.itemGroupId.\n        var key = data.get(dimInfo.name, dataIndex);\n\n        if (dimOrdinalMeta) {\n          return dimOrdinalMeta.categories[key] || key + '';\n        }\n\n        return key + '';\n      } // Get groupId from raw item. { groupId: '' }\n\n\n      var itemVal = data.getRawDataItem(dataIndex);\n\n      if (itemVal && itemVal.groupId) {\n        return itemVal.groupId + '';\n      }\n\n      return dataGroupId || data.getId(dataIndex);\n    };\n  } // Use id if it's very likely to be an one to one animation\n  // It's more robust than groupId\n  // TODO Check if key dimension is specified.\n\n\n  var useId = isAllIdSame(oldDiffItems, newDiffItems);\n  var isElementStillInChart = {};\n\n  if (!useId) {\n    // We may have different diff strategy with basicTransition if we use other dimension as key.\n    // If so, we can't simply check if oldEl is same with newEl. We need a map to check if oldEl is still being used in the new chart.\n    // We can't use the elements that already being morphed. Let it keep it's original basic transition.\n    for (var i = 0; i < newDiffItems.length; i++) {\n      var newItem = newDiffItems[i];\n      var el = newItem.data.getItemGraphicEl(newItem.dataIndex);\n\n      if (el) {\n        isElementStillInChart[el.id] = true;\n      }\n    }\n  }\n\n  function updateOneToOne(newIndex, oldIndex) {\n    var oldItem = oldDiffItems[oldIndex];\n    var newItem = newDiffItems[newIndex];\n    var newSeries = newItem.data.hostModel; // TODO Mark this elements is morphed and don't morph them anymore\n\n    var oldEl = oldItem.data.getItemGraphicEl(oldItem.dataIndex);\n    var newEl = newItem.data.getItemGraphicEl(newItem.dataIndex); // Can't handle same elements.\n\n    if (oldEl === newEl) {\n      newEl && animateElementStyles(newEl, newItem.dataIndex, newSeries);\n      return;\n    }\n\n    if ( // We can't use the elements that already being morphed\n    oldEl && isElementStillInChart[oldEl.id]) {\n      return;\n    }\n\n    if (newEl) {\n      // TODO: If keep animating the group in case\n      // some of the elements don't want to be morphed.\n      // TODO Label?\n      stopAnimation(newEl);\n\n      if (oldEl) {\n        stopAnimation(oldEl); // If old element is doing leaving animation. stop it and remove it immediately.\n\n        removeEl(oldEl);\n        hasMorphAnimation = true;\n        applyMorphAnimation(getPathList(oldEl), getPathList(newEl), newItem.divide, newSeries, newIndex, updateMorphingPathProps);\n      } else {\n        fadeInElement(newEl, newSeries, newIndex);\n      }\n    } // else keep oldEl leaving animation.\n\n  }\n\n  new DataDiffer(oldDiffItems, newDiffItems, createKeyGetter(true, useId), createKeyGetter(false, useId), null, 'multiple').update(updateOneToOne).updateManyToOne(function (newIndex, oldIndices) {\n    var newItem = newDiffItems[newIndex];\n    var newData = newItem.data;\n    var newSeries = newData.hostModel;\n    var newEl = newData.getItemGraphicEl(newItem.dataIndex);\n    var oldElsList = filter(map(oldIndices, function (idx) {\n      return oldDiffItems[idx].data.getItemGraphicEl(oldDiffItems[idx].dataIndex);\n    }), function (oldEl) {\n      return oldEl && oldEl !== newEl && !isElementStillInChart[oldEl.id];\n    });\n\n    if (newEl) {\n      stopAnimation(newEl);\n\n      if (oldElsList.length) {\n        // If old element is doing leaving animation. stop it and remove it immediately.\n        each(oldElsList, function (oldEl) {\n          stopAnimation(oldEl);\n          removeEl(oldEl);\n        });\n        hasMorphAnimation = true;\n        applyMorphAnimation(getPathList(oldElsList), getPathList(newEl), newItem.divide, newSeries, newIndex, updateMorphingPathProps);\n      } else {\n        fadeInElement(newEl, newSeries, newItem.dataIndex);\n      }\n    } // else keep oldEl leaving animation.\n\n  }).updateOneToMany(function (newIndices, oldIndex) {\n    var oldItem = oldDiffItems[oldIndex];\n    var oldEl = oldItem.data.getItemGraphicEl(oldItem.dataIndex); // We can't use the elements that already being morphed\n\n    if (oldEl && isElementStillInChart[oldEl.id]) {\n      return;\n    }\n\n    var newElsList = filter(map(newIndices, function (idx) {\n      return newDiffItems[idx].data.getItemGraphicEl(newDiffItems[idx].dataIndex);\n    }), function (el) {\n      return el && el !== oldEl;\n    });\n    var newSeris = newDiffItems[newIndices[0]].data.hostModel;\n\n    if (newElsList.length) {\n      each(newElsList, function (newEl) {\n        return stopAnimation(newEl);\n      });\n\n      if (oldEl) {\n        stopAnimation(oldEl); // If old element is doing leaving animation. stop it and remove it immediately.\n\n        removeEl(oldEl);\n        hasMorphAnimation = true;\n        applyMorphAnimation(getPathList(oldEl), getPathList(newElsList), oldItem.divide, // Use divide on old.\n        newSeris, newIndices[0], updateMorphingPathProps);\n      } else {\n        each(newElsList, function (newEl) {\n          return fadeInElement(newEl, newSeris, newIndices[0]);\n        });\n      }\n    } // else keep oldEl leaving animation.\n\n  }).updateManyToMany(function (newIndices, oldIndices) {\n    // If two data are same and both have groupId.\n    // Normally they should be diff by id.\n    new DataDiffer(oldIndices, newIndices, function (rawIdx) {\n      return oldDiffItems[rawIdx].data.getId(oldDiffItems[rawIdx].dataIndex);\n    }, function (rawIdx) {\n      return newDiffItems[rawIdx].data.getId(newDiffItems[rawIdx].dataIndex);\n    }).update(function (newIndex, oldIndex) {\n      // Use the original index\n      updateOneToOne(newIndices[newIndex], oldIndices[oldIndex]);\n    }).execute();\n  }).execute();\n\n  if (hasMorphAnimation) {\n    each(newList, function (_a) {\n      var data = _a.data;\n      var seriesModel = data.hostModel;\n      var view = seriesModel && api.getViewOfSeriesModel(seriesModel);\n      var animationCfg = getAnimationConfig('update', seriesModel, 0); // use 0 index.\n\n      if (view && seriesModel.isAnimationEnabled() && animationCfg && animationCfg.duration > 0) {\n        view.group.traverse(function (el) {\n          if (el instanceof Path && !el.animators.length) {\n            // We can't accept there still exists element that has no animation\n            // if universalTransition is enabled\n            el.animateFrom({\n              style: {\n                opacity: 0\n              }\n            }, animationCfg);\n          }\n        });\n      }\n    });\n  }\n}\n\nfunction getSeriesTransitionKey(series) {\n  var seriesKey = series.getModel('universalTransition').get('seriesKey');\n\n  if (!seriesKey) {\n    // Use series id by default.\n    return series.id;\n  }\n\n  return seriesKey;\n}\n\nfunction convertArraySeriesKeyToString(seriesKey) {\n  if (isArray(seriesKey)) {\n    // Order independent.\n    return seriesKey.sort().join(',');\n  }\n\n  return seriesKey;\n}\n\nfunction getDivideShapeFromData(data) {\n  if (data.hostModel) {\n    return data.hostModel.getModel('universalTransition').get('divideShape');\n  }\n}\n\nfunction findTransitionSeriesBatches(globalStore, params) {\n  var updateBatches = createHashMap();\n  var oldDataMap = createHashMap(); // Map that only store key in array seriesKey.\n  // Which is used to query the old data when transition from one to multiple series.\n\n  var oldDataMapForSplit = createHashMap();\n  each(globalStore.oldSeries, function (series, idx) {\n    var oldData = globalStore.oldData[idx];\n    var transitionKey = getSeriesTransitionKey(series);\n    var transitionKeyStr = convertArraySeriesKeyToString(transitionKey);\n    oldDataMap.set(transitionKeyStr, oldData);\n\n    if (isArray(transitionKey)) {\n      // Same key can't in different array seriesKey.\n      each(transitionKey, function (key) {\n        oldDataMapForSplit.set(key, {\n          data: oldData,\n          key: transitionKeyStr\n        });\n      });\n    }\n  });\n\n  function checkTransitionSeriesKeyDuplicated(transitionKeyStr) {\n    if (updateBatches.get(transitionKeyStr)) {\n      warn(\"Duplicated seriesKey in universalTransition \" + transitionKeyStr);\n    }\n  }\n\n  each(params.updatedSeries, function (series) {\n    if (series.isUniversalTransitionEnabled() && series.isAnimationEnabled()) {\n      var newData = series.getData();\n      var transitionKey = getSeriesTransitionKey(series);\n      var transitionKeyStr = convertArraySeriesKeyToString(transitionKey); // Only transition between series with same id.\n\n      var oldData = oldDataMap.get(transitionKeyStr); // string transition key is the best match.\n\n      if (oldData) {\n        if (process.env.NODE_ENV !== 'production') {\n          checkTransitionSeriesKeyDuplicated(transitionKeyStr);\n        } // TODO check if data is same?\n\n\n        updateBatches.set(transitionKeyStr, {\n          oldSeries: [{\n            divide: getDivideShapeFromData(oldData),\n            data: oldData\n          }],\n          newSeries: [{\n            divide: getDivideShapeFromData(newData),\n            data: newData\n          }]\n        });\n      } else {\n        // Transition from multiple series.\n        if (isArray(transitionKey)) {\n          if (process.env.NODE_ENV !== 'production') {\n            checkTransitionSeriesKeyDuplicated(transitionKeyStr);\n          }\n\n          var oldSeries_1 = [];\n          each(transitionKey, function (key) {\n            var oldData = oldDataMap.get(key);\n\n            if (oldData) {\n              oldSeries_1.push({\n                divide: getDivideShapeFromData(oldData),\n                data: oldData\n              });\n            }\n          });\n\n          if (oldSeries_1.length) {\n            updateBatches.set(transitionKeyStr, {\n              oldSeries: oldSeries_1,\n              newSeries: [{\n                data: newData,\n                divide: getDivideShapeFromData(newData)\n              }]\n            });\n          }\n        } else {\n          // Try transition to multiple series.\n          var oldData_1 = oldDataMapForSplit.get(transitionKey);\n\n          if (oldData_1) {\n            var batch = updateBatches.get(oldData_1.key);\n\n            if (!batch) {\n              batch = {\n                oldSeries: [{\n                  data: oldData_1.data,\n                  divide: getDivideShapeFromData(oldData_1.data)\n                }],\n                newSeries: []\n              };\n              updateBatches.set(oldData_1.key, batch);\n            }\n\n            batch.newSeries.push({\n              data: newData,\n              divide: getDivideShapeFromData(newData)\n            });\n          }\n        }\n      }\n    }\n  });\n  return updateBatches;\n}\n\nfunction querySeries(series, finder) {\n  for (var i = 0; i < series.length; i++) {\n    var found = finder.seriesIndex != null && finder.seriesIndex === series[i].seriesIndex || finder.seriesId != null && finder.seriesId === series[i].id;\n\n    if (found) {\n      return i;\n    }\n  }\n}\n\nfunction transitionSeriesFromOpt(transitionOpt, globalStore, params, api) {\n  var from = [];\n  var to = [];\n  each(normalizeToArray(transitionOpt.from), function (finder) {\n    var idx = querySeries(globalStore.oldSeries, finder);\n\n    if (idx >= 0) {\n      from.push({\n        data: globalStore.oldData[idx],\n        // TODO can specify divideShape in transition.\n        divide: getDivideShapeFromData(globalStore.oldData[idx]),\n        dim: finder.dimension\n      });\n    }\n  });\n  each(normalizeToArray(transitionOpt.to), function (finder) {\n    var idx = querySeries(params.updatedSeries, finder);\n\n    if (idx >= 0) {\n      var data = params.updatedSeries[idx].getData();\n      to.push({\n        data: data,\n        divide: getDivideShapeFromData(data),\n        dim: finder.dimension\n      });\n    }\n  });\n\n  if (from.length > 0 && to.length > 0) {\n    transitionBetween(from, to, api);\n  }\n}\n\nexport function installUniversalTransition(registers) {\n  registers.registerUpdateLifecycle('series:beforeupdate', function (ecMOdel, api, params) {\n    each(normalizeToArray(params.seriesTransition), function (transOpt) {\n      each(normalizeToArray(transOpt.to), function (finder) {\n        var series = params.updatedSeries;\n\n        for (var i = 0; i < series.length; i++) {\n          if (finder.seriesIndex != null && finder.seriesIndex === series[i].seriesIndex || finder.seriesId != null && finder.seriesId === series[i].id) {\n            series[i][SERIES_UNIVERSAL_TRANSITION_PROP] = true;\n          }\n        }\n      });\n    });\n  });\n  registers.registerUpdateLifecycle('series:transition', function (ecModel, api, params) {\n    // TODO api provide an namespace that can save stuff per instance\n    var globalStore = getUniversalTransitionGlobalStore(api); // TODO multiple to multiple series.\n\n    if (globalStore.oldSeries && params.updatedSeries && params.optionChanged) {\n      // Use give transition config if its' give;\n      var transitionOpt = params.seriesTransition;\n\n      if (transitionOpt) {\n        each(normalizeToArray(transitionOpt), function (opt) {\n          transitionSeriesFromOpt(opt, globalStore, params, api);\n        });\n      } else {\n        // Else guess from series based on transition series key.\n        var updateBatches_1 = findTransitionSeriesBatches(globalStore, params);\n        each(updateBatches_1.keys(), function (key) {\n          var batch = updateBatches_1.get(key);\n          transitionBetween(batch.oldSeries, batch.newSeries, api);\n        });\n      } // Reset\n\n\n      each(params.updatedSeries, function (series) {\n        // Reset;\n        if (series[SERIES_UNIVERSAL_TRANSITION_PROP]) {\n          series[SERIES_UNIVERSAL_TRANSITION_PROP] = false;\n        }\n      });\n    } // Save all series of current update. Not only the updated one.\n\n\n    var allSeries = ecModel.getSeries();\n    var savedSeries = globalStore.oldSeries = [];\n    var savedData = globalStore.oldData = [];\n\n    for (var i = 0; i < allSeries.length; i++) {\n      var data = allSeries[i].getData(); // Only save the data that can have transition.\n      // Avoid large data costing too much extra memory\n\n      if (data.count() < DATA_COUNT_THRESHOLD) {\n        savedSeries.push(allSeries[i]);\n        savedData.push(data);\n      }\n    }\n  });\n}"],"names":["isMultiple","elements","isArray","prepareMorphBatches","one","many","batches","batchCount","length","i","push","len","k","off","moveFrom","mid","Math","ceil","slice","pathDividers","clone","params","ret","approxOpacity","pow","path","style","opacity","count","cloned","clonePath","setStyle","split","applyMorphAnimation","from","to","divideShape","seriesModel","dataIndex","animateOtherProps","updateAnimationCfg","getAnimationConfig","duration","animationDelay","getModel","get","animationCfg","Object","assign","setToFinal","fromIsMany","morphBatches","animateCount","animateIndex","morphOneBatch","batch","forceManyOne","batchMany","batchOne","separateAnimationCfg","defaults","dividePath","individualDelay","idx","fromPath","toPath","_a","combineMorph","separateMorph","fromIndividuals","toIndividuals","individualAnimationCfg","delay","batchFrom","batchTo","isCombineMorphing","morphPath","getPathList","pathList_1","pathList","traverse","el","Path","disableMorphing","invisible","ignore","getUniversalTransitionGlobalStore","makeInner","flattenDataDiffItems","list","items","each","seriesInfo","data","indices","getIndices","groupDim","dimensions","dimInfo","getDimensionInfo","otherDims","itemGroupId","getGroupIdDimension","dim","divide","fadeInElement","newEl","newSeries","newIndex","initProps","isFrom","removeEl","parent","computedTransform","getComputedTransform","setLocalTransform","remove","stopAnimation","isGroup","child","transitionBetween","oldList","newList","api","oldDiffItems","newDiffItems","updateMorphingPathProps","rawFrom","rawTo","animateFrom","extend","findKeyDim","oldKeyDim","newKeyDim","hasMorphAnimation","createKeyGetter","isOld","onlyGetId","diffItem","getId","dataGroupId","hostModel","keyDim","dimOrdinalMeta","ordinalMeta","key","name","categories","itemVal","getRawDataItem","groupId","useId","oldItem","newItem","isAllIdSame","isElementStillInChart","getItemGraphicEl","id","updateOneToOne","oldIndex","oldEl","animationConfig","Displayable","oldStyle","getOldStyle","animateElementStyles","DataDiffer","update","updateManyToOne","oldIndices","newData","oldElsList","filter","map","updateOneToMany","newIndices","newElsList","newSeris","updateManyToMany","rawIdx","execute","view","getViewOfSeriesModel","isAnimationEnabled","group","animators","getSeriesTransitionKey","series","convertArraySeriesKeyToString","seriesKey","sort","join","getDivideShapeFromData","querySeries","finder","seriesIndex","seriesId","installUniversalTransition","registers","registerUpdateLifecycle","ecMOdel","normalizeToArray","seriesTransition","transOpt","updatedSeries","SERIES_UNIVERSAL_TRANSITION_PROP","ecModel","globalStore","oldSeries","optionChanged","transitionOpt","opt","oldData","dimension","getData","transitionSeriesFromOpt","updateBatches_1","updateBatches","createHashMap","oldDataMap","oldDataMapForSplit","transitionKey","transitionKeyStr","set","isUniversalTransitionEnabled","oldSeries_1","oldData_1","findTransitionSeriesBatches","keys","allSeries","getSeries","savedSeries","savedData"],"sourceRoot":""}
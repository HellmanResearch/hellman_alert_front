{"version":3,"file":"static/js/7065.b5e42fc2.js","mappings":"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","sources":["../node_modules/echarts/lib/component/dataZoom/AxisProxy.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport * as zrUtil from 'zrender/lib/core/util.js';\nimport * as numberUtil from '../../util/number.js';\nimport sliderMove from '../helper/sliderMove.js';\nimport { unionAxisExtentFromData } from '../../coord/axisHelper.js';\nimport { ensureScaleRawExtentInfo } from '../../coord/scaleRawExtentInfo.js';\nimport { getAxisMainType, isCoordSupported } from './helper.js';\nimport { SINGLE_REFERRING } from '../../util/model.js';\nvar each = zrUtil.each;\nvar asc = numberUtil.asc;\n/**\n * Operate single axis.\n * One axis can only operated by one axis operator.\n * Different dataZoomModels may be defined to operate the same axis.\n * (i.e. 'inside' data zoom and 'slider' data zoom components)\n * So dataZoomModels share one axisProxy in that case.\n */\n\nvar AxisProxy =\n/** @class */\nfunction () {\n  function AxisProxy(dimName, axisIndex, dataZoomModel, ecModel) {\n    this._dimName = dimName;\n    this._axisIndex = axisIndex;\n    this.ecModel = ecModel;\n    this._dataZoomModel = dataZoomModel; // /**\n    //  * @readOnly\n    //  * @private\n    //  */\n    // this.hasSeriesStacked;\n  }\n  /**\n   * Whether the axisProxy is hosted by dataZoomModel.\n   */\n\n\n  AxisProxy.prototype.hostedBy = function (dataZoomModel) {\n    return this._dataZoomModel === dataZoomModel;\n  };\n  /**\n   * @return Value can only be NaN or finite value.\n   */\n\n\n  AxisProxy.prototype.getDataValueWindow = function () {\n    return this._valueWindow.slice();\n  };\n  /**\n   * @return {Array.<number>}\n   */\n\n\n  AxisProxy.prototype.getDataPercentWindow = function () {\n    return this._percentWindow.slice();\n  };\n\n  AxisProxy.prototype.getTargetSeriesModels = function () {\n    var seriesModels = [];\n    this.ecModel.eachSeries(function (seriesModel) {\n      if (isCoordSupported(seriesModel)) {\n        var axisMainType = getAxisMainType(this._dimName);\n        var axisModel = seriesModel.getReferringComponents(axisMainType, SINGLE_REFERRING).models[0];\n\n        if (axisModel && this._axisIndex === axisModel.componentIndex) {\n          seriesModels.push(seriesModel);\n        }\n      }\n    }, this);\n    return seriesModels;\n  };\n\n  AxisProxy.prototype.getAxisModel = function () {\n    return this.ecModel.getComponent(this._dimName + 'Axis', this._axisIndex);\n  };\n\n  AxisProxy.prototype.getMinMaxSpan = function () {\n    return zrUtil.clone(this._minMaxSpan);\n  };\n  /**\n   * Only calculate by given range and this._dataExtent, do not change anything.\n   */\n\n\n  AxisProxy.prototype.calculateDataWindow = function (opt) {\n    var dataExtent = this._dataExtent;\n    var axisModel = this.getAxisModel();\n    var scale = axisModel.axis.scale;\n\n    var rangePropMode = this._dataZoomModel.getRangePropMode();\n\n    var percentExtent = [0, 100];\n    var percentWindow = [];\n    var valueWindow = [];\n    var hasPropModeValue;\n    each(['start', 'end'], function (prop, idx) {\n      var boundPercent = opt[prop];\n      var boundValue = opt[prop + 'Value']; // Notice: dataZoom is based either on `percentProp` ('start', 'end') or\n      // on `valueProp` ('startValue', 'endValue'). (They are based on the data extent\n      // but not min/max of axis, which will be calculated by data window then).\n      // The former one is suitable for cases that a dataZoom component controls multiple\n      // axes with different unit or extent, and the latter one is suitable for accurate\n      // zoom by pixel (e.g., in dataZoomSelect).\n      // we use `getRangePropMode()` to mark which prop is used. `rangePropMode` is updated\n      // only when setOption or dispatchAction, otherwise it remains its original value.\n      // (Why not only record `percentProp` and always map to `valueProp`? Because\n      // the map `valueProp` -> `percentProp` -> `valueProp` probably not the original\n      // `valueProp`. consider two axes constrolled by one dataZoom. They have different\n      // data extent. All of values that are overflow the `dataExtent` will be calculated\n      // to percent '100%').\n\n      if (rangePropMode[idx] === 'percent') {\n        boundPercent == null && (boundPercent = percentExtent[idx]); // Use scale.parse to math round for category or time axis.\n\n        boundValue = scale.parse(numberUtil.linearMap(boundPercent, percentExtent, dataExtent));\n      } else {\n        hasPropModeValue = true;\n        boundValue = boundValue == null ? dataExtent[idx] : scale.parse(boundValue); // Calculating `percent` from `value` may be not accurate, because\n        // This calculation can not be inversed, because all of values that\n        // are overflow the `dataExtent` will be calculated to percent '100%'\n\n        boundPercent = numberUtil.linearMap(boundValue, dataExtent, percentExtent);\n      } // valueWindow[idx] = round(boundValue);\n      // percentWindow[idx] = round(boundPercent);\n\n\n      valueWindow[idx] = boundValue;\n      percentWindow[idx] = boundPercent;\n    });\n    asc(valueWindow);\n    asc(percentWindow); // The windows from user calling of `dispatchAction` might be out of the extent,\n    // or do not obey the `min/maxSpan`, `min/maxValueSpan`. But we dont restrict window\n    // by `zoomLock` here, because we see `zoomLock` just as a interaction constraint,\n    // where API is able to initialize/modify the window size even though `zoomLock`\n    // specified.\n\n    var spans = this._minMaxSpan;\n    hasPropModeValue ? restrictSet(valueWindow, percentWindow, dataExtent, percentExtent, false) : restrictSet(percentWindow, valueWindow, percentExtent, dataExtent, true);\n\n    function restrictSet(fromWindow, toWindow, fromExtent, toExtent, toValue) {\n      var suffix = toValue ? 'Span' : 'ValueSpan';\n      sliderMove(0, fromWindow, fromExtent, 'all', spans['min' + suffix], spans['max' + suffix]);\n\n      for (var i = 0; i < 2; i++) {\n        toWindow[i] = numberUtil.linearMap(fromWindow[i], fromExtent, toExtent, true);\n        toValue && (toWindow[i] = scale.parse(toWindow[i]));\n      }\n    }\n\n    return {\n      valueWindow: valueWindow,\n      percentWindow: percentWindow\n    };\n  };\n  /**\n   * Notice: reset should not be called before series.restoreData() called,\n   * so it is recommanded to be called in \"process stage\" but not \"model init\n   * stage\".\n   */\n\n\n  AxisProxy.prototype.reset = function (dataZoomModel) {\n    if (dataZoomModel !== this._dataZoomModel) {\n      return;\n    }\n\n    var targetSeries = this.getTargetSeriesModels(); // Culculate data window and data extent, and record them.\n\n    this._dataExtent = calculateDataExtent(this, this._dimName, targetSeries); // `calculateDataWindow` uses min/maxSpan.\n\n    this._updateMinMaxSpan();\n\n    var dataWindow = this.calculateDataWindow(dataZoomModel.settledOption);\n    this._valueWindow = dataWindow.valueWindow;\n    this._percentWindow = dataWindow.percentWindow; // Update axis setting then.\n\n    this._setAxisModel();\n  };\n\n  AxisProxy.prototype.filterData = function (dataZoomModel, api) {\n    if (dataZoomModel !== this._dataZoomModel) {\n      return;\n    }\n\n    var axisDim = this._dimName;\n    var seriesModels = this.getTargetSeriesModels();\n    var filterMode = dataZoomModel.get('filterMode');\n    var valueWindow = this._valueWindow;\n\n    if (filterMode === 'none') {\n      return;\n    } // FIXME\n    // Toolbox may has dataZoom injected. And if there are stacked bar chart\n    // with NaN data, NaN will be filtered and stack will be wrong.\n    // So we need to force the mode to be set empty.\n    // In fect, it is not a big deal that do not support filterMode-'filter'\n    // when using toolbox#dataZoom, utill tooltip#dataZoom support \"single axis\n    // selection\" some day, which might need \"adapt to data extent on the\n    // otherAxis\", which is disabled by filterMode-'empty'.\n    // But currently, stack has been fixed to based on value but not index,\n    // so this is not an issue any more.\n    // let otherAxisModel = this.getOtherAxisModel();\n    // if (dataZoomModel.get('$fromToolbox')\n    //     && otherAxisModel\n    //     && otherAxisModel.hasSeriesStacked\n    // ) {\n    //     filterMode = 'empty';\n    // }\n    // TODO\n    // filterMode 'weakFilter' and 'empty' is not optimized for huge data yet.\n\n\n    each(seriesModels, function (seriesModel) {\n      var seriesData = seriesModel.getData();\n      var dataDims = seriesData.mapDimensionsAll(axisDim);\n\n      if (!dataDims.length) {\n        return;\n      }\n\n      if (filterMode === 'weakFilter') {\n        var store_1 = seriesData.getStore();\n        var dataDimIndices_1 = zrUtil.map(dataDims, function (dim) {\n          return seriesData.getDimensionIndex(dim);\n        }, seriesData);\n        seriesData.filterSelf(function (dataIndex) {\n          var leftOut;\n          var rightOut;\n          var hasValue;\n\n          for (var i = 0; i < dataDims.length; i++) {\n            var value = store_1.get(dataDimIndices_1[i], dataIndex);\n            var thisHasValue = !isNaN(value);\n            var thisLeftOut = value < valueWindow[0];\n            var thisRightOut = value > valueWindow[1];\n\n            if (thisHasValue && !thisLeftOut && !thisRightOut) {\n              return true;\n            }\n\n            thisHasValue && (hasValue = true);\n            thisLeftOut && (leftOut = true);\n            thisRightOut && (rightOut = true);\n          } // If both left out and right out, do not filter.\n\n\n          return hasValue && leftOut && rightOut;\n        });\n      } else {\n        each(dataDims, function (dim) {\n          if (filterMode === 'empty') {\n            seriesModel.setData(seriesData = seriesData.map(dim, function (value) {\n              return !isInWindow(value) ? NaN : value;\n            }));\n          } else {\n            var range = {};\n            range[dim] = valueWindow; // console.time('select');\n\n            seriesData.selectRange(range); // console.timeEnd('select');\n          }\n        });\n      }\n\n      each(dataDims, function (dim) {\n        seriesData.setApproximateExtent(valueWindow, dim);\n      });\n    });\n\n    function isInWindow(value) {\n      return value >= valueWindow[0] && value <= valueWindow[1];\n    }\n  };\n\n  AxisProxy.prototype._updateMinMaxSpan = function () {\n    var minMaxSpan = this._minMaxSpan = {};\n    var dataZoomModel = this._dataZoomModel;\n    var dataExtent = this._dataExtent;\n    each(['min', 'max'], function (minMax) {\n      var percentSpan = dataZoomModel.get(minMax + 'Span');\n      var valueSpan = dataZoomModel.get(minMax + 'ValueSpan');\n      valueSpan != null && (valueSpan = this.getAxisModel().axis.scale.parse(valueSpan)); // minValueSpan and maxValueSpan has higher priority than minSpan and maxSpan\n\n      if (valueSpan != null) {\n        percentSpan = numberUtil.linearMap(dataExtent[0] + valueSpan, dataExtent, [0, 100], true);\n      } else if (percentSpan != null) {\n        valueSpan = numberUtil.linearMap(percentSpan, [0, 100], dataExtent, true) - dataExtent[0];\n      }\n\n      minMaxSpan[minMax + 'Span'] = percentSpan;\n      minMaxSpan[minMax + 'ValueSpan'] = valueSpan;\n    }, this);\n  };\n\n  AxisProxy.prototype._setAxisModel = function () {\n    var axisModel = this.getAxisModel();\n    var percentWindow = this._percentWindow;\n    var valueWindow = this._valueWindow;\n\n    if (!percentWindow) {\n      return;\n    } // [0, 500]: arbitrary value, guess axis extent.\n\n\n    var precision = numberUtil.getPixelPrecision(valueWindow, [0, 500]);\n    precision = Math.min(precision, 20); // For value axis, if min/max/scale are not set, we just use the extent obtained\n    // by series data, which may be a little different from the extent calculated by\n    // `axisHelper.getScaleExtent`. But the different just affects the experience a\n    // little when zooming. So it will not be fixed until some users require it strongly.\n\n    var rawExtentInfo = axisModel.axis.scale.rawExtentInfo;\n\n    if (percentWindow[0] !== 0) {\n      rawExtentInfo.setDeterminedMinMax('min', +valueWindow[0].toFixed(precision));\n    }\n\n    if (percentWindow[1] !== 100) {\n      rawExtentInfo.setDeterminedMinMax('max', +valueWindow[1].toFixed(precision));\n    }\n\n    rawExtentInfo.freeze();\n  };\n\n  return AxisProxy;\n}();\n\nfunction calculateDataExtent(axisProxy, axisDim, seriesModels) {\n  var dataExtent = [Infinity, -Infinity];\n  each(seriesModels, function (seriesModel) {\n    unionAxisExtentFromData(dataExtent, seriesModel.getData(), axisDim);\n  }); // It is important to get \"consistent\" extent when more then one axes is\n  // controlled by a `dataZoom`, otherwise those axes will not be synchronized\n  // when zooming. But it is difficult to know what is \"consistent\", considering\n  // axes have different type or even different meanings (For example, two\n  // time axes are used to compare data of the same date in different years).\n  // So basically dataZoom just obtains extent by series.data (in category axis\n  // extent can be obtained from axis.data).\n  // Nevertheless, user can set min/max/scale on axes to make extent of axes\n  // consistent.\n\n  var axisModel = axisProxy.getAxisModel();\n  var rawExtentResult = ensureScaleRawExtentInfo(axisModel.axis.scale, axisModel, dataExtent).calculate();\n  return [rawExtentResult.min, rawExtentResult.max];\n}\n\nexport default AxisProxy;"],"names":["each","zrUtil","asc","numberUtil","AxisProxy","dimName","axisIndex","dataZoomModel","ecModel","this","_dimName","_axisIndex","_dataZoomModel","prototype","hostedBy","getDataValueWindow","_valueWindow","slice","getDataPercentWindow","_percentWindow","getTargetSeriesModels","seriesModels","eachSeries","seriesModel","isCoordSupported","axisMainType","getAxisMainType","axisModel","getReferringComponents","SINGLE_REFERRING","models","componentIndex","push","getAxisModel","getComponent","getMinMaxSpan","_minMaxSpan","calculateDataWindow","opt","hasPropModeValue","dataExtent","_dataExtent","scale","axis","rangePropMode","getRangePropMode","percentExtent","percentWindow","valueWindow","prop","idx","boundPercent","boundValue","parse","spans","restrictSet","fromWindow","toWindow","fromExtent","toExtent","toValue","suffix","sliderMove","i","reset","targetSeries","axisProxy","axisDim","Infinity","unionAxisExtentFromData","getData","rawExtentResult","ensureScaleRawExtentInfo","calculate","min","max","calculateDataExtent","_updateMinMaxSpan","dataWindow","settledOption","_setAxisModel","filterData","api","filterMode","get","seriesData","dataDims","mapDimensionsAll","length","store_1","getStore","dataDimIndices_1","dim","getDimensionIndex","filterSelf","dataIndex","leftOut","rightOut","hasValue","value","thisHasValue","isNaN","thisLeftOut","thisRightOut","setData","map","isInWindow","NaN","range","selectRange","setApproximateExtent","minMaxSpan","minMax","percentSpan","valueSpan","precision","Math","rawExtentInfo","setDeterminedMinMax","toFixed","freeze"],"sourceRoot":""}
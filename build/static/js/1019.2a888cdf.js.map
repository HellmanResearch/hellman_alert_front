{"version":3,"file":"static/js/1019.2a888cdf.js","mappings":"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","sources":["../node_modules/echarts/lib/core/ExtensionAPI.js","../node_modules/echarts/lib/core/Scheduler.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport * as zrUtil from 'zrender/lib/core/util.js';\nvar availableMethods = ['getDom', 'getZr', 'getWidth', 'getHeight', 'getDevicePixelRatio', 'dispatchAction', 'isSSR', 'isDisposed', 'on', 'off', 'getDataURL', 'getConnectedDataURL', // 'getModel',\n'getOption', // 'getViewOfComponentModel',\n// 'getViewOfSeriesModel',\n'getId', 'updateLabelLayout'];\n\nvar ExtensionAPI =\n/** @class */\nfunction () {\n  function ExtensionAPI(ecInstance) {\n    zrUtil.each(availableMethods, function (methodName) {\n      this[methodName] = zrUtil.bind(ecInstance[methodName], ecInstance);\n    }, this);\n  }\n\n  return ExtensionAPI;\n}();\n\nexport default ExtensionAPI;","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { each, map, isFunction, createHashMap, noop, assert } from 'zrender/lib/core/util.js';\nimport { createTask } from './task.js';\nimport { getUID } from '../util/component.js';\nimport GlobalModel from '../model/Global.js';\nimport ExtensionAPI from './ExtensionAPI.js';\nimport { normalizeToArray } from '../util/model.js';\n;\n\nvar Scheduler =\n/** @class */\nfunction () {\n  function Scheduler(ecInstance, api, dataProcessorHandlers, visualHandlers) {\n    // key: handlerUID\n    this._stageTaskMap = createHashMap();\n    this.ecInstance = ecInstance;\n    this.api = api; // Fix current processors in case that in some rear cases that\n    // processors might be registered after echarts instance created.\n    // Register processors incrementally for a echarts instance is\n    // not supported by this stream architecture.\n\n    dataProcessorHandlers = this._dataProcessorHandlers = dataProcessorHandlers.slice();\n    visualHandlers = this._visualHandlers = visualHandlers.slice();\n    this._allHandlers = dataProcessorHandlers.concat(visualHandlers);\n  }\n\n  Scheduler.prototype.restoreData = function (ecModel, payload) {\n    // TODO: Only restore needed series and components, but not all components.\n    // Currently `restoreData` of all of the series and component will be called.\n    // But some independent components like `title`, `legend`, `graphic`, `toolbox`,\n    // `tooltip`, `axisPointer`, etc, do not need series refresh when `setOption`,\n    // and some components like coordinate system, axes, dataZoom, visualMap only\n    // need their target series refresh.\n    // (1) If we are implementing this feature some day, we should consider these cases:\n    // if a data processor depends on a component (e.g., dataZoomProcessor depends\n    // on the settings of `dataZoom`), it should be re-performed if the component\n    // is modified by `setOption`.\n    // (2) If a processor depends on sevral series, speicified by its `getTargetSeries`,\n    // it should be re-performed when the result array of `getTargetSeries` changed.\n    // We use `dependencies` to cover these issues.\n    // (3) How to update target series when coordinate system related components modified.\n    // TODO: simply the dirty mechanism? Check whether only the case here can set tasks dirty,\n    // and this case all of the tasks will be set as dirty.\n    ecModel.restoreData(payload); // Theoretically an overall task not only depends on each of its target series, but also\n    // depends on all of the series.\n    // The overall task is not in pipeline, and `ecModel.restoreData` only set pipeline tasks\n    // dirty. If `getTargetSeries` of an overall task returns nothing, we should also ensure\n    // that the overall task is set as dirty and to be performed, otherwise it probably cause\n    // state chaos. So we have to set dirty of all of the overall tasks manually, otherwise it\n    // probably cause state chaos (consider `dataZoomProcessor`).\n\n    this._stageTaskMap.each(function (taskRecord) {\n      var overallTask = taskRecord.overallTask;\n      overallTask && overallTask.dirty();\n    });\n  }; // If seriesModel provided, incremental threshold is check by series data.\n\n\n  Scheduler.prototype.getPerformArgs = function (task, isBlock) {\n    // For overall task\n    if (!task.__pipeline) {\n      return;\n    }\n\n    var pipeline = this._pipelineMap.get(task.__pipeline.id);\n\n    var pCtx = pipeline.context;\n    var incremental = !isBlock && pipeline.progressiveEnabled && (!pCtx || pCtx.progressiveRender) && task.__idxInPipeline > pipeline.blockIndex;\n    var step = incremental ? pipeline.step : null;\n    var modDataCount = pCtx && pCtx.modDataCount;\n    var modBy = modDataCount != null ? Math.ceil(modDataCount / step) : null;\n    return {\n      step: step,\n      modBy: modBy,\n      modDataCount: modDataCount\n    };\n  };\n\n  Scheduler.prototype.getPipeline = function (pipelineId) {\n    return this._pipelineMap.get(pipelineId);\n  };\n  /**\n   * Current, progressive rendering starts from visual and layout.\n   * Always detect render mode in the same stage, avoiding that incorrect\n   * detection caused by data filtering.\n   * Caution:\n   * `updateStreamModes` use `seriesModel.getData()`.\n   */\n\n\n  Scheduler.prototype.updateStreamModes = function (seriesModel, view) {\n    var pipeline = this._pipelineMap.get(seriesModel.uid);\n\n    var data = seriesModel.getData();\n    var dataLen = data.count(); // `progressiveRender` means that can render progressively in each\n    // animation frame. Note that some types of series do not provide\n    // `view.incrementalPrepareRender` but support `chart.appendData`. We\n    // use the term `incremental` but not `progressive` to describe the\n    // case that `chart.appendData`.\n\n    var progressiveRender = pipeline.progressiveEnabled && view.incrementalPrepareRender && dataLen >= pipeline.threshold;\n    var large = seriesModel.get('large') && dataLen >= seriesModel.get('largeThreshold'); // TODO: modDataCount should not updated if `appendData`, otherwise cause whole repaint.\n    // see `test/candlestick-large3.html`\n\n    var modDataCount = seriesModel.get('progressiveChunkMode') === 'mod' ? dataLen : null;\n    seriesModel.pipelineContext = pipeline.context = {\n      progressiveRender: progressiveRender,\n      modDataCount: modDataCount,\n      large: large\n    };\n  };\n\n  Scheduler.prototype.restorePipelines = function (ecModel) {\n    var scheduler = this;\n    var pipelineMap = scheduler._pipelineMap = createHashMap();\n    ecModel.eachSeries(function (seriesModel) {\n      var progressive = seriesModel.getProgressive();\n      var pipelineId = seriesModel.uid;\n      pipelineMap.set(pipelineId, {\n        id: pipelineId,\n        head: null,\n        tail: null,\n        threshold: seriesModel.getProgressiveThreshold(),\n        progressiveEnabled: progressive && !(seriesModel.preventIncremental && seriesModel.preventIncremental()),\n        blockIndex: -1,\n        step: Math.round(progressive || 700),\n        count: 0\n      });\n\n      scheduler._pipe(seriesModel, seriesModel.dataTask);\n    });\n  };\n\n  Scheduler.prototype.prepareStageTasks = function () {\n    var stageTaskMap = this._stageTaskMap;\n    var ecModel = this.api.getModel();\n    var api = this.api;\n    each(this._allHandlers, function (handler) {\n      var record = stageTaskMap.get(handler.uid) || stageTaskMap.set(handler.uid, {});\n      var errMsg = '';\n\n      if (process.env.NODE_ENV !== 'production') {\n        // Currently do not need to support to sepecify them both.\n        errMsg = '\"reset\" and \"overallReset\" must not be both specified.';\n      }\n\n      assert(!(handler.reset && handler.overallReset), errMsg);\n      handler.reset && this._createSeriesStageTask(handler, record, ecModel, api);\n      handler.overallReset && this._createOverallStageTask(handler, record, ecModel, api);\n    }, this);\n  };\n\n  Scheduler.prototype.prepareView = function (view, model, ecModel, api) {\n    var renderTask = view.renderTask;\n    var context = renderTask.context;\n    context.model = model;\n    context.ecModel = ecModel;\n    context.api = api;\n    renderTask.__block = !view.incrementalPrepareRender;\n\n    this._pipe(model, renderTask);\n  };\n\n  Scheduler.prototype.performDataProcessorTasks = function (ecModel, payload) {\n    // If we do not use `block` here, it should be considered when to update modes.\n    this._performStageTasks(this._dataProcessorHandlers, ecModel, payload, {\n      block: true\n    });\n  };\n\n  Scheduler.prototype.performVisualTasks = function (ecModel, payload, opt) {\n    this._performStageTasks(this._visualHandlers, ecModel, payload, opt);\n  };\n\n  Scheduler.prototype._performStageTasks = function (stageHandlers, ecModel, payload, opt) {\n    opt = opt || {};\n    var unfinished = false;\n    var scheduler = this;\n    each(stageHandlers, function (stageHandler, idx) {\n      if (opt.visualType && opt.visualType !== stageHandler.visualType) {\n        return;\n      }\n\n      var stageHandlerRecord = scheduler._stageTaskMap.get(stageHandler.uid);\n\n      var seriesTaskMap = stageHandlerRecord.seriesTaskMap;\n      var overallTask = stageHandlerRecord.overallTask;\n\n      if (overallTask) {\n        var overallNeedDirty_1;\n        var agentStubMap = overallTask.agentStubMap;\n        agentStubMap.each(function (stub) {\n          if (needSetDirty(opt, stub)) {\n            stub.dirty();\n            overallNeedDirty_1 = true;\n          }\n        });\n        overallNeedDirty_1 && overallTask.dirty();\n        scheduler.updatePayload(overallTask, payload);\n        var performArgs_1 = scheduler.getPerformArgs(overallTask, opt.block); // Execute stubs firstly, which may set the overall task dirty,\n        // then execute the overall task. And stub will call seriesModel.setData,\n        // which ensures that in the overallTask seriesModel.getData() will not\n        // return incorrect data.\n\n        agentStubMap.each(function (stub) {\n          stub.perform(performArgs_1);\n        });\n\n        if (overallTask.perform(performArgs_1)) {\n          unfinished = true;\n        }\n      } else if (seriesTaskMap) {\n        seriesTaskMap.each(function (task, pipelineId) {\n          if (needSetDirty(opt, task)) {\n            task.dirty();\n          }\n\n          var performArgs = scheduler.getPerformArgs(task, opt.block); // FIXME\n          // if intending to decalare `performRawSeries` in handlers, only\n          // stream-independent (specifically, data item independent) operations can be\n          // performed. Because is a series is filtered, most of the tasks will not\n          // be performed. A stream-dependent operation probably cause wrong biz logic.\n          // Perhaps we should not provide a separate callback for this case instead\n          // of providing the config `performRawSeries`. The stream-dependent operaions\n          // and stream-independent operations should better not be mixed.\n\n          performArgs.skip = !stageHandler.performRawSeries && ecModel.isSeriesFiltered(task.context.model);\n          scheduler.updatePayload(task, payload);\n\n          if (task.perform(performArgs)) {\n            unfinished = true;\n          }\n        });\n      }\n    });\n\n    function needSetDirty(opt, task) {\n      return opt.setDirty && (!opt.dirtyMap || opt.dirtyMap.get(task.__pipeline.id));\n    }\n\n    this.unfinished = unfinished || this.unfinished;\n  };\n\n  Scheduler.prototype.performSeriesTasks = function (ecModel) {\n    var unfinished;\n    ecModel.eachSeries(function (seriesModel) {\n      // Progress to the end for dataInit and dataRestore.\n      unfinished = seriesModel.dataTask.perform() || unfinished;\n    });\n    this.unfinished = unfinished || this.unfinished;\n  };\n\n  Scheduler.prototype.plan = function () {\n    // Travel pipelines, check block.\n    this._pipelineMap.each(function (pipeline) {\n      var task = pipeline.tail;\n\n      do {\n        if (task.__block) {\n          pipeline.blockIndex = task.__idxInPipeline;\n          break;\n        }\n\n        task = task.getUpstream();\n      } while (task);\n    });\n  };\n\n  Scheduler.prototype.updatePayload = function (task, payload) {\n    payload !== 'remain' && (task.context.payload = payload);\n  };\n\n  Scheduler.prototype._createSeriesStageTask = function (stageHandler, stageHandlerRecord, ecModel, api) {\n    var scheduler = this;\n    var oldSeriesTaskMap = stageHandlerRecord.seriesTaskMap; // The count of stages are totally about only several dozen, so\n    // do not need to reuse the map.\n\n    var newSeriesTaskMap = stageHandlerRecord.seriesTaskMap = createHashMap();\n    var seriesType = stageHandler.seriesType;\n    var getTargetSeries = stageHandler.getTargetSeries; // If a stageHandler should cover all series, `createOnAllSeries` should be declared mandatorily,\n    // to avoid some typo or abuse. Otherwise if an extension do not specify a `seriesType`,\n    // it works but it may cause other irrelevant charts blocked.\n\n    if (stageHandler.createOnAllSeries) {\n      ecModel.eachRawSeries(create);\n    } else if (seriesType) {\n      ecModel.eachRawSeriesByType(seriesType, create);\n    } else if (getTargetSeries) {\n      getTargetSeries(ecModel, api).each(create);\n    }\n\n    function create(seriesModel) {\n      var pipelineId = seriesModel.uid; // Init tasks for each seriesModel only once.\n      // Reuse original task instance.\n\n      var task = newSeriesTaskMap.set(pipelineId, oldSeriesTaskMap && oldSeriesTaskMap.get(pipelineId) || createTask({\n        plan: seriesTaskPlan,\n        reset: seriesTaskReset,\n        count: seriesTaskCount\n      }));\n      task.context = {\n        model: seriesModel,\n        ecModel: ecModel,\n        api: api,\n        // PENDING: `useClearVisual` not used?\n        useClearVisual: stageHandler.isVisual && !stageHandler.isLayout,\n        plan: stageHandler.plan,\n        reset: stageHandler.reset,\n        scheduler: scheduler\n      };\n\n      scheduler._pipe(seriesModel, task);\n    }\n  };\n\n  Scheduler.prototype._createOverallStageTask = function (stageHandler, stageHandlerRecord, ecModel, api) {\n    var scheduler = this;\n    var overallTask = stageHandlerRecord.overallTask = stageHandlerRecord.overallTask // For overall task, the function only be called on reset stage.\n    || createTask({\n      reset: overallTaskReset\n    });\n    overallTask.context = {\n      ecModel: ecModel,\n      api: api,\n      overallReset: stageHandler.overallReset,\n      scheduler: scheduler\n    };\n    var oldAgentStubMap = overallTask.agentStubMap; // The count of stages are totally about only several dozen, so\n    // do not need to reuse the map.\n\n    var newAgentStubMap = overallTask.agentStubMap = createHashMap();\n    var seriesType = stageHandler.seriesType;\n    var getTargetSeries = stageHandler.getTargetSeries;\n    var overallProgress = true;\n    var shouldOverallTaskDirty = false; // FIXME:TS never used, so comment it\n    // let modifyOutputEnd = stageHandler.modifyOutputEnd;\n    // An overall task with seriesType detected or has `getTargetSeries`, we add\n    // stub in each pipelines, it will set the overall task dirty when the pipeline\n    // progress. Moreover, to avoid call the overall task each frame (too frequent),\n    // we set the pipeline block.\n\n    var errMsg = '';\n\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = '\"createOnAllSeries\" do not supported for \"overallReset\", ' + 'becuase it will block all streams.';\n    }\n\n    assert(!stageHandler.createOnAllSeries, errMsg);\n\n    if (seriesType) {\n      ecModel.eachRawSeriesByType(seriesType, createStub);\n    } else if (getTargetSeries) {\n      getTargetSeries(ecModel, api).each(createStub);\n    } // Otherwise, (usually it is legancy case), the overall task will only be\n    // executed when upstream dirty. Otherwise the progressive rendering of all\n    // pipelines will be disabled unexpectedly. But it still needs stubs to receive\n    // dirty info from upsteam.\n    else {\n        overallProgress = false;\n        each(ecModel.getSeries(), createStub);\n      }\n\n    function createStub(seriesModel) {\n      var pipelineId = seriesModel.uid;\n      var stub = newAgentStubMap.set(pipelineId, oldAgentStubMap && oldAgentStubMap.get(pipelineId) || ( // When the result of `getTargetSeries` changed, the overallTask\n      // should be set as dirty and re-performed.\n      shouldOverallTaskDirty = true, createTask({\n        reset: stubReset,\n        onDirty: stubOnDirty\n      })));\n      stub.context = {\n        model: seriesModel,\n        overallProgress: overallProgress // FIXME:TS never used, so comment it\n        // modifyOutputEnd: modifyOutputEnd\n\n      };\n      stub.agent = overallTask;\n      stub.__block = overallProgress;\n\n      scheduler._pipe(seriesModel, stub);\n    }\n\n    if (shouldOverallTaskDirty) {\n      overallTask.dirty();\n    }\n  };\n\n  Scheduler.prototype._pipe = function (seriesModel, task) {\n    var pipelineId = seriesModel.uid;\n\n    var pipeline = this._pipelineMap.get(pipelineId);\n\n    !pipeline.head && (pipeline.head = task);\n    pipeline.tail && pipeline.tail.pipe(task);\n    pipeline.tail = task;\n    task.__idxInPipeline = pipeline.count++;\n    task.__pipeline = pipeline;\n  };\n\n  Scheduler.wrapStageHandler = function (stageHandler, visualType) {\n    if (isFunction(stageHandler)) {\n      stageHandler = {\n        overallReset: stageHandler,\n        seriesType: detectSeriseType(stageHandler)\n      };\n    }\n\n    stageHandler.uid = getUID('stageHandler');\n    visualType && (stageHandler.visualType = visualType);\n    return stageHandler;\n  };\n\n  ;\n  return Scheduler;\n}();\n\nfunction overallTaskReset(context) {\n  context.overallReset(context.ecModel, context.api, context.payload);\n}\n\nfunction stubReset(context) {\n  return context.overallProgress && stubProgress;\n}\n\nfunction stubProgress() {\n  this.agent.dirty();\n  this.getDownstream().dirty();\n}\n\nfunction stubOnDirty() {\n  this.agent && this.agent.dirty();\n}\n\nfunction seriesTaskPlan(context) {\n  return context.plan ? context.plan(context.model, context.ecModel, context.api, context.payload) : null;\n}\n\nfunction seriesTaskReset(context) {\n  if (context.useClearVisual) {\n    context.data.clearAllVisual();\n  }\n\n  var resetDefines = context.resetDefines = normalizeToArray(context.reset(context.model, context.ecModel, context.api, context.payload));\n  return resetDefines.length > 1 ? map(resetDefines, function (v, idx) {\n    return makeSeriesTaskProgress(idx);\n  }) : singleSeriesTaskProgress;\n}\n\nvar singleSeriesTaskProgress = makeSeriesTaskProgress(0);\n\nfunction makeSeriesTaskProgress(resetDefineIdx) {\n  return function (params, context) {\n    var data = context.data;\n    var resetDefine = context.resetDefines[resetDefineIdx];\n\n    if (resetDefine && resetDefine.dataEach) {\n      for (var i = params.start; i < params.end; i++) {\n        resetDefine.dataEach(data, i);\n      }\n    } else if (resetDefine && resetDefine.progress) {\n      resetDefine.progress(params, data);\n    }\n  };\n}\n\nfunction seriesTaskCount(context) {\n  return context.data.count();\n}\n/**\n * Only some legacy stage handlers (usually in echarts extensions) are pure function.\n * To ensure that they can work normally, they should work in block mode, that is,\n * they should not be started util the previous tasks finished. So they cause the\n * progressive rendering disabled. We try to detect the series type, to narrow down\n * the block range to only the series type they concern, but not all series.\n */\n\n\nfunction detectSeriseType(legacyFunc) {\n  seriesType = null;\n\n  try {\n    // Assume there is no async when calling `eachSeriesByType`.\n    legacyFunc(ecModelMock, apiMock);\n  } catch (e) {}\n\n  return seriesType;\n}\n\nvar ecModelMock = {};\nvar apiMock = {};\nvar seriesType;\nmockMethods(ecModelMock, GlobalModel);\nmockMethods(apiMock, ExtensionAPI);\n\necModelMock.eachSeriesByType = ecModelMock.eachRawSeriesByType = function (type) {\n  seriesType = type;\n};\n\necModelMock.eachComponent = function (cond) {\n  if (cond.mainType === 'series' && cond.subType) {\n    seriesType = cond.subType;\n  }\n};\n\nfunction mockMethods(target, Clz) {\n  /* eslint-disable */\n  for (var name_1 in Clz.prototype) {\n    // Do not use hasOwnProperty\n    target[name_1] = noop;\n  }\n  /* eslint-enable */\n\n}\n\nexport default Scheduler;"],"names":["availableMethods","ExtensionAPI","ecInstance","zrUtil","methodName","this","Scheduler","api","dataProcessorHandlers","visualHandlers","_stageTaskMap","createHashMap","_dataProcessorHandlers","slice","_visualHandlers","_allHandlers","concat","prototype","restoreData","ecModel","payload","each","taskRecord","overallTask","dirty","getPerformArgs","task","isBlock","__pipeline","pipeline","_pipelineMap","get","id","pCtx","context","step","progressiveEnabled","progressiveRender","__idxInPipeline","blockIndex","modDataCount","modBy","Math","ceil","getPipeline","pipelineId","updateStreamModes","seriesModel","view","uid","dataLen","getData","count","incrementalPrepareRender","threshold","large","pipelineContext","restorePipelines","scheduler","pipelineMap","eachSeries","progressive","getProgressive","set","head","tail","getProgressiveThreshold","preventIncremental","round","_pipe","dataTask","prepareStageTasks","stageTaskMap","getModel","handler","record","assert","reset","overallReset","_createSeriesStageTask","_createOverallStageTask","prepareView","model","renderTask","__block","performDataProcessorTasks","_performStageTasks","block","performVisualTasks","opt","stageHandlers","unfinished","needSetDirty","setDirty","dirtyMap","stageHandler","idx","visualType","stageHandlerRecord","seriesTaskMap","overallNeedDirty_1","agentStubMap","stub","updatePayload","performArgs_1","perform","performArgs","skip","performRawSeries","isSeriesFiltered","performSeriesTasks","plan","getUpstream","oldSeriesTaskMap","newSeriesTaskMap","seriesType","getTargetSeries","create","createTask","seriesTaskPlan","seriesTaskReset","seriesTaskCount","useClearVisual","isVisual","isLayout","createOnAllSeries","eachRawSeries","eachRawSeriesByType","overallTaskReset","oldAgentStubMap","newAgentStubMap","overallProgress","shouldOverallTaskDirty","createStub","stubReset","onDirty","stubOnDirty","agent","getSeries","pipe","wrapStageHandler","isFunction","detectSeriseType","getUID","stubProgress","getDownstream","data","clearAllVisual","resetDefines","normalizeToArray","length","map","v","makeSeriesTaskProgress","singleSeriesTaskProgress","resetDefineIdx","params","resetDefine","dataEach","i","start","end","progress","legacyFunc","ecModelMock","apiMock","e","mockMethods","target","Clz","name_1","noop","GlobalModel","eachSeriesByType","type","eachComponent","cond","mainType","subType"],"sourceRoot":""}
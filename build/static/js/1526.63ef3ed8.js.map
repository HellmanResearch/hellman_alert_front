{"version":3,"file":"static/js/1526.63ef3ed8.js","mappings":"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","sources":["../node_modules/echarts/lib/model/Model.js","../node_modules/echarts/lib/model/OptionManager.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport env from 'zrender/lib/core/env.js';\nimport { enableClassExtend, enableClassCheck } from '../util/clazz.js';\nimport { AreaStyleMixin } from './mixin/areaStyle.js';\nimport TextStyleMixin from './mixin/textStyle.js';\nimport { LineStyleMixin } from './mixin/lineStyle.js';\nimport { ItemStyleMixin } from './mixin/itemStyle.js';\nimport { mixin, clone, merge } from 'zrender/lib/core/util.js';\n\nvar Model =\n/** @class */\nfunction () {\n  function Model(option, parentModel, ecModel) {\n    this.parentModel = parentModel;\n    this.ecModel = ecModel;\n    this.option = option; // Simple optimization\n    // if (this.init) {\n    //     if (arguments.length <= 4) {\n    //         this.init(option, parentModel, ecModel, extraOpt);\n    //     }\n    //     else {\n    //         this.init.apply(this, arguments);\n    //     }\n    // }\n  }\n\n  Model.prototype.init = function (option, parentModel, ecModel) {\n    var rest = [];\n\n    for (var _i = 3; _i < arguments.length; _i++) {\n      rest[_i - 3] = arguments[_i];\n    }\n  };\n  /**\n   * Merge the input option to me.\n   */\n\n\n  Model.prototype.mergeOption = function (option, ecModel) {\n    merge(this.option, option, true);\n  }; // `path` can be 'a.b.c', so the return value type have to be `ModelOption`\n  // TODO: TYPE strict key check?\n  // get(path: string | string[], ignoreParent?: boolean): ModelOption;\n\n\n  Model.prototype.get = function (path, ignoreParent) {\n    if (path == null) {\n      return this.option;\n    }\n\n    return this._doGet(this.parsePath(path), !ignoreParent && this.parentModel);\n  };\n\n  Model.prototype.getShallow = function (key, ignoreParent) {\n    var option = this.option;\n    var val = option == null ? option : option[key];\n\n    if (val == null && !ignoreParent) {\n      var parentModel = this.parentModel;\n\n      if (parentModel) {\n        // FIXME:TS do not know how to make it works\n        val = parentModel.getShallow(key);\n      }\n    }\n\n    return val;\n  }; // `path` can be 'a.b.c', so the return value type have to be `Model<ModelOption>`\n  // getModel(path: string | string[], parentModel?: Model): Model;\n  // TODO 'a.b.c' is deprecated\n\n\n  Model.prototype.getModel = function (path, parentModel) {\n    var hasPath = path != null;\n    var pathFinal = hasPath ? this.parsePath(path) : null;\n    var obj = hasPath ? this._doGet(pathFinal) : this.option;\n    parentModel = parentModel || this.parentModel && this.parentModel.getModel(this.resolveParentPath(pathFinal));\n    return new Model(obj, parentModel, this.ecModel);\n  };\n  /**\n   * If model has option\n   */\n\n\n  Model.prototype.isEmpty = function () {\n    return this.option == null;\n  };\n\n  Model.prototype.restoreData = function () {}; // Pending\n\n\n  Model.prototype.clone = function () {\n    var Ctor = this.constructor;\n    return new Ctor(clone(this.option));\n  }; // setReadOnly(properties): void {\n  // clazzUtil.setReadOnly(this, properties);\n  // }\n  // If path is null/undefined, return null/undefined.\n\n\n  Model.prototype.parsePath = function (path) {\n    if (typeof path === 'string') {\n      return path.split('.');\n    }\n\n    return path;\n  }; // Resolve path for parent. Perhaps useful when parent use a different property.\n  // Default to be a identity resolver.\n  // Can be modified to a different resolver.\n\n\n  Model.prototype.resolveParentPath = function (path) {\n    return path;\n  }; // FIXME:TS check whether put this method here\n\n\n  Model.prototype.isAnimationEnabled = function () {\n    if (!env.node && this.option) {\n      if (this.option.animation != null) {\n        return !!this.option.animation;\n      } else if (this.parentModel) {\n        return this.parentModel.isAnimationEnabled();\n      }\n    }\n  };\n\n  Model.prototype._doGet = function (pathArr, parentModel) {\n    var obj = this.option;\n\n    if (!pathArr) {\n      return obj;\n    }\n\n    for (var i = 0; i < pathArr.length; i++) {\n      // Ignore empty\n      if (!pathArr[i]) {\n        continue;\n      } // obj could be number/string/... (like 0)\n\n\n      obj = obj && typeof obj === 'object' ? obj[pathArr[i]] : null;\n\n      if (obj == null) {\n        break;\n      }\n    }\n\n    if (obj == null && parentModel) {\n      obj = parentModel._doGet(this.resolveParentPath(pathArr), parentModel.parentModel);\n    }\n\n    return obj;\n  };\n\n  return Model;\n}();\n\n; // Enable Model.extend.\n\nenableClassExtend(Model);\nenableClassCheck(Model);\nmixin(Model, LineStyleMixin);\nmixin(Model, ItemStyleMixin);\nmixin(Model, AreaStyleMixin);\nmixin(Model, TextStyleMixin);\nexport default Model;","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { normalizeToArray // , MappingExistingItem, setComponentTypeToKeyInfo, mappingToExists\n} from '../util/model.js';\nimport { each, clone, map, isTypedArray, setAsPrimitive, isArray, isObject // , HashMap , createHashMap, extend, merge,\n} from 'zrender/lib/core/util.js';\nimport { error } from '../util/log.js';\nvar QUERY_REG = /^(min|max)?(.+)$/; // Key: mainType\n// type FakeComponentsMap = HashMap<(MappingExistingItem & { subType: string })[]>;\n\n/**\n * TERM EXPLANATIONS:\n * See `ECOption` and `ECUnitOption` in `src/util/types.ts`.\n */\n\nvar OptionManager =\n/** @class */\nfunction () {\n  // timeline.notMerge is not supported in ec3. Firstly there is rearly\n  // case that notMerge is needed. Secondly supporting 'notMerge' requires\n  // rawOption cloned and backuped when timeline changed, which does no\n  // good to performance. What's more, that both timeline and setOption\n  // method supply 'notMerge' brings complex and some problems.\n  // Consider this case:\n  // (step1) chart.setOption({timeline: {notMerge: false}, ...}, false);\n  // (step2) chart.setOption({timeline: {notMerge: true}, ...}, false);\n  function OptionManager(api) {\n    this._timelineOptions = [];\n    this._mediaList = [];\n    /**\n     * -1, means default.\n     * empty means no media.\n     */\n\n    this._currentMediaIndices = [];\n    this._api = api;\n  }\n\n  OptionManager.prototype.setOption = function (rawOption, optionPreprocessorFuncs, opt) {\n    if (rawOption) {\n      // That set dat primitive is dangerous if user reuse the data when setOption again.\n      each(normalizeToArray(rawOption.series), function (series) {\n        series && series.data && isTypedArray(series.data) && setAsPrimitive(series.data);\n      });\n      each(normalizeToArray(rawOption.dataset), function (dataset) {\n        dataset && dataset.source && isTypedArray(dataset.source) && setAsPrimitive(dataset.source);\n      });\n    } // Caution: some series modify option data, if do not clone,\n    // it should ensure that the repeat modify correctly\n    // (create a new object when modify itself).\n\n\n    rawOption = clone(rawOption); // FIXME\n    // If some property is set in timeline options or media option but\n    // not set in baseOption, a warning should be given.\n\n    var optionBackup = this._optionBackup;\n    var newParsedOption = parseRawOption(rawOption, optionPreprocessorFuncs, !optionBackup);\n    this._newBaseOption = newParsedOption.baseOption; // For setOption at second time (using merge mode);\n\n    if (optionBackup) {\n      // FIXME\n      // the restore merge solution is essentially incorrect.\n      // the mapping can not be 100% consistent with ecModel, which probably brings\n      // potential bug!\n      // The first merge is delayed, becuase in most cases, users do not call `setOption` twice.\n      // let fakeCmptsMap = this._fakeCmptsMap;\n      // if (!fakeCmptsMap) {\n      //     fakeCmptsMap = this._fakeCmptsMap = createHashMap();\n      //     mergeToBackupOption(fakeCmptsMap, null, optionBackup.baseOption, null);\n      // }\n      // mergeToBackupOption(\n      //     fakeCmptsMap, optionBackup.baseOption, newParsedOption.baseOption, opt\n      // );\n      // For simplicity, timeline options and media options do not support merge,\n      // that is, if you `setOption` twice and both has timeline options, the latter\n      // timeline opitons will not be merged to the formers, but just substitude them.\n      if (newParsedOption.timelineOptions.length) {\n        optionBackup.timelineOptions = newParsedOption.timelineOptions;\n      }\n\n      if (newParsedOption.mediaList.length) {\n        optionBackup.mediaList = newParsedOption.mediaList;\n      }\n\n      if (newParsedOption.mediaDefault) {\n        optionBackup.mediaDefault = newParsedOption.mediaDefault;\n      }\n    } else {\n      this._optionBackup = newParsedOption;\n    }\n  };\n\n  OptionManager.prototype.mountOption = function (isRecreate) {\n    var optionBackup = this._optionBackup;\n    this._timelineOptions = optionBackup.timelineOptions;\n    this._mediaList = optionBackup.mediaList;\n    this._mediaDefault = optionBackup.mediaDefault;\n    this._currentMediaIndices = [];\n    return clone(isRecreate // this._optionBackup.baseOption, which is created at the first `setOption`\n    // called, and is merged into every new option by inner method `mergeToBackupOption`\n    // each time `setOption` called, can be only used in `isRecreate`, because\n    // its reliability is under suspicion. In other cases option merge is\n    // performed by `model.mergeOption`.\n    ? optionBackup.baseOption : this._newBaseOption);\n  };\n\n  OptionManager.prototype.getTimelineOption = function (ecModel) {\n    var option;\n    var timelineOptions = this._timelineOptions;\n\n    if (timelineOptions.length) {\n      // getTimelineOption can only be called after ecModel inited,\n      // so we can get currentIndex from timelineModel.\n      var timelineModel = ecModel.getComponent('timeline');\n\n      if (timelineModel) {\n        option = clone( // FIXME:TS as TimelineModel or quivlant interface\n        timelineOptions[timelineModel.getCurrentIndex()]);\n      }\n    }\n\n    return option;\n  };\n\n  OptionManager.prototype.getMediaOption = function (ecModel) {\n    var ecWidth = this._api.getWidth();\n\n    var ecHeight = this._api.getHeight();\n\n    var mediaList = this._mediaList;\n    var mediaDefault = this._mediaDefault;\n    var indices = [];\n    var result = []; // No media defined.\n\n    if (!mediaList.length && !mediaDefault) {\n      return result;\n    } // Multi media may be applied, the latter defined media has higher priority.\n\n\n    for (var i = 0, len = mediaList.length; i < len; i++) {\n      if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {\n        indices.push(i);\n      }\n    } // FIXME\n    // Whether mediaDefault should force users to provide? Otherwise\n    // the change by media query can not be recorvered.\n\n\n    if (!indices.length && mediaDefault) {\n      indices = [-1];\n    }\n\n    if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {\n      result = map(indices, function (index) {\n        return clone(index === -1 ? mediaDefault.option : mediaList[index].option);\n      });\n    } // Otherwise return nothing.\n\n\n    this._currentMediaIndices = indices;\n    return result;\n  };\n\n  return OptionManager;\n}();\n/**\n * [RAW_OPTION_PATTERNS]\n * (Note: \"series: []\" represents all other props in `ECUnitOption`)\n *\n * (1) No prop \"baseOption\" declared:\n * Root option is used as \"baseOption\" (except prop \"options\" and \"media\").\n * ```js\n * option = {\n *     series: [],\n *     timeline: {},\n *     options: [],\n * };\n * option = {\n *     series: [],\n *     media: {},\n * };\n * option = {\n *     series: [],\n *     timeline: {},\n *     options: [],\n *     media: {},\n * }\n * ```\n *\n * (2) Prop \"baseOption\" declared:\n * If \"baseOption\" declared, `ECUnitOption` props can only be declared\n * inside \"baseOption\" except prop \"timeline\" (compat ec2).\n * ```js\n * option = {\n *     baseOption: {\n *         timeline: {},\n *         series: [],\n *     },\n *     options: []\n * };\n * option = {\n *     baseOption: {\n *         series: [],\n *     },\n *     media: []\n * };\n * option = {\n *     baseOption: {\n *         timeline: {},\n *         series: [],\n *     },\n *     options: []\n *     media: []\n * };\n * option = {\n *     // ec3 compat ec2: allow (only) `timeline` declared\n *     // outside baseOption. Keep this setting for compat.\n *     timeline: {},\n *     baseOption: {\n *         series: [],\n *     },\n *     options: [],\n *     media: []\n * };\n * ```\n */\n\n\nfunction parseRawOption( // `rawOption` May be modified\nrawOption, optionPreprocessorFuncs, isNew) {\n  var mediaList = [];\n  var mediaDefault;\n  var baseOption;\n  var declaredBaseOption = rawOption.baseOption; // Compatible with ec2, [RAW_OPTION_PATTERNS] above.\n\n  var timelineOnRoot = rawOption.timeline;\n  var timelineOptionsOnRoot = rawOption.options;\n  var mediaOnRoot = rawOption.media;\n  var hasMedia = !!rawOption.media;\n  var hasTimeline = !!(timelineOptionsOnRoot || timelineOnRoot || declaredBaseOption && declaredBaseOption.timeline);\n\n  if (declaredBaseOption) {\n    baseOption = declaredBaseOption; // For merge option.\n\n    if (!baseOption.timeline) {\n      baseOption.timeline = timelineOnRoot;\n    }\n  } // For convenience, enable to use the root option as the `baseOption`:\n  // `{ ...normalOptionProps, media: [{ ... }, { ... }] }`\n  else {\n      if (hasTimeline || hasMedia) {\n        rawOption.options = rawOption.media = null;\n      }\n\n      baseOption = rawOption;\n    }\n\n  if (hasMedia) {\n    if (isArray(mediaOnRoot)) {\n      each(mediaOnRoot, function (singleMedia) {\n        if (process.env.NODE_ENV !== 'production') {\n          // Real case of wrong config.\n          if (singleMedia && !singleMedia.option && isObject(singleMedia.query) && isObject(singleMedia.query.option)) {\n            error('Illegal media option. Must be like { media: [ { query: {}, option: {} } ] }');\n          }\n        }\n\n        if (singleMedia && singleMedia.option) {\n          if (singleMedia.query) {\n            mediaList.push(singleMedia);\n          } else if (!mediaDefault) {\n            // Use the first media default.\n            mediaDefault = singleMedia;\n          }\n        }\n      });\n    } else {\n      if (process.env.NODE_ENV !== 'production') {\n        // Real case of wrong config.\n        error('Illegal media option. Must be an array. Like { media: [ {...}, {...} ] }');\n      }\n    }\n  }\n\n  doPreprocess(baseOption);\n  each(timelineOptionsOnRoot, function (option) {\n    return doPreprocess(option);\n  });\n  each(mediaList, function (media) {\n    return doPreprocess(media.option);\n  });\n\n  function doPreprocess(option) {\n    each(optionPreprocessorFuncs, function (preProcess) {\n      preProcess(option, isNew);\n    });\n  }\n\n  return {\n    baseOption: baseOption,\n    timelineOptions: timelineOptionsOnRoot || [],\n    mediaDefault: mediaDefault,\n    mediaList: mediaList\n  };\n}\n/**\n * @see <http://www.w3.org/TR/css3-mediaqueries/#media1>\n * Support: width, height, aspectRatio\n * Can use max or min as prefix.\n */\n\n\nfunction applyMediaQuery(query, ecWidth, ecHeight) {\n  var realMap = {\n    width: ecWidth,\n    height: ecHeight,\n    aspectratio: ecWidth / ecHeight // lowser case for convenientce.\n\n  };\n  var applicatable = true;\n  each(query, function (value, attr) {\n    var matched = attr.match(QUERY_REG);\n\n    if (!matched || !matched[1] || !matched[2]) {\n      return;\n    }\n\n    var operator = matched[1];\n    var realAttr = matched[2].toLowerCase();\n\n    if (!compare(realMap[realAttr], value, operator)) {\n      applicatable = false;\n    }\n  });\n  return applicatable;\n}\n\nfunction compare(real, expect, operator) {\n  if (operator === 'min') {\n    return real >= expect;\n  } else if (operator === 'max') {\n    return real <= expect;\n  } else {\n    // Equals\n    return real === expect;\n  }\n}\n\nfunction indicesEquals(indices1, indices2) {\n  // indices is always order by asc and has only finite number.\n  return indices1.join(',') === indices2.join(',');\n}\n/**\n * Consider case:\n * `chart.setOption(opt1);`\n * Then user do some interaction like dataZoom, dataView changing.\n * `chart.setOption(opt2);`\n * Then user press 'reset button' in toolbox.\n *\n * After doing that all of the interaction effects should be reset, the\n * chart should be the same as the result of invoke\n * `chart.setOption(opt1); chart.setOption(opt2);`.\n *\n * Although it is not able ensure that\n * `chart.setOption(opt1); chart.setOption(opt2);` is equivalents to\n * `chart.setOption(merge(opt1, opt2));` exactly,\n * this might be the only simple way to implement that feature.\n *\n * MEMO: We've considered some other approaches:\n * 1. Each model handle its self restoration but not uniform treatment.\n *     (Too complex in logic and error-prone)\n * 2. Use a shadow ecModel. (Performace expensive)\n *\n * FIXME: A possible solution:\n * Add a extra level of model for each component model. The inheritance chain would be:\n * ecModel <- componentModel <- componentActionModel <- dataItemModel\n * And all of the actions can only modify the `componentActionModel` rather than\n * `componentModel`. `setOption` will only modify the `ecModel` and `componentModel`.\n * When \"resotre\" action triggered, model from `componentActionModel` will be discarded\n * instead of recreating the \"ecModel\" from the \"_optionBackup\".\n */\n// function mergeToBackupOption(\n//     fakeCmptsMap: FakeComponentsMap,\n//     // `tarOption` Can be null/undefined, means init\n//     tarOption: ECUnitOption,\n//     newOption: ECUnitOption,\n//     // Can be null/undefined\n//     opt: InnerSetOptionOpts\n// ): void {\n//     newOption = newOption || {} as ECUnitOption;\n//     const notInit = !!tarOption;\n//     each(newOption, function (newOptsInMainType, mainType) {\n//         if (newOptsInMainType == null) {\n//             return;\n//         }\n//         if (!ComponentModel.hasClass(mainType)) {\n//             if (tarOption) {\n//                 tarOption[mainType] = merge(tarOption[mainType], newOptsInMainType, true);\n//             }\n//         }\n//         else {\n//             const oldTarOptsInMainType = notInit ? normalizeToArray(tarOption[mainType]) : null;\n//             const oldFakeCmptsInMainType = fakeCmptsMap.get(mainType) || [];\n//             const resultTarOptsInMainType = notInit ? (tarOption[mainType] = [] as ComponentOption[]) : null;\n//             const resultFakeCmptsInMainType = fakeCmptsMap.set(mainType, []);\n//             const mappingResult = mappingToExists(\n//                 oldFakeCmptsInMainType,\n//                 normalizeToArray(newOptsInMainType),\n//                 (opt && opt.replaceMergeMainTypeMap.get(mainType)) ? 'replaceMerge' : 'normalMerge'\n//             );\n//             setComponentTypeToKeyInfo(mappingResult, mainType, ComponentModel as ComponentModelConstructor);\n//             each(mappingResult, function (resultItem, index) {\n//                 // The same logic as `Global.ts#_mergeOption`.\n//                 let fakeCmpt = resultItem.existing;\n//                 const newOption = resultItem.newOption;\n//                 const keyInfo = resultItem.keyInfo;\n//                 let fakeCmptOpt;\n//                 if (!newOption) {\n//                     fakeCmptOpt = oldTarOptsInMainType[index];\n//                 }\n//                 else {\n//                     if (fakeCmpt && fakeCmpt.subType === keyInfo.subType) {\n//                         fakeCmpt.name = keyInfo.name;\n//                         if (notInit) {\n//                             fakeCmptOpt = merge(oldTarOptsInMainType[index], newOption, true);\n//                         }\n//                     }\n//                     else {\n//                         fakeCmpt = extend({}, keyInfo);\n//                         if (notInit) {\n//                             fakeCmptOpt = clone(newOption);\n//                         }\n//                     }\n//                 }\n//                 if (fakeCmpt) {\n//                     notInit && resultTarOptsInMainType.push(fakeCmptOpt);\n//                     resultFakeCmptsInMainType.push(fakeCmpt);\n//                 }\n//                 else {\n//                     notInit && resultTarOptsInMainType.push(void 0);\n//                     resultFakeCmptsInMainType.push(void 0);\n//                 }\n//             });\n//         }\n//     });\n// }\n\n\nexport default OptionManager;"],"names":["Model","option","parentModel","ecModel","this","prototype","init","rest","_i","arguments","length","mergeOption","merge","get","path","ignoreParent","_doGet","parsePath","getShallow","key","val","getModel","hasPath","pathFinal","resolveParentPath","isEmpty","restoreData","clone","Ctor","constructor","split","isAnimationEnabled","env","animation","pathArr","obj","i","enableClassExtend","enableClassCheck","mixin","LineStyleMixin","ItemStyleMixin","AreaStyleMixin","TextStyleMixin","QUERY_REG","OptionManager","api","_timelineOptions","_mediaList","_currentMediaIndices","_api","setOption","rawOption","optionPreprocessorFuncs","opt","each","normalizeToArray","series","data","isTypedArray","setAsPrimitive","dataset","source","optionBackup","_optionBackup","newParsedOption","isNew","mediaDefault","baseOption","mediaList","declaredBaseOption","timelineOnRoot","timeline","timelineOptionsOnRoot","options","mediaOnRoot","media","hasMedia","hasTimeline","doPreprocess","preProcess","isArray","singleMedia","query","push","timelineOptions","parseRawOption","_newBaseOption","mountOption","isRecreate","_mediaDefault","getTimelineOption","timelineModel","getComponent","getCurrentIndex","getMediaOption","indices1","indices2","ecWidth","getWidth","ecHeight","getHeight","indices","result","len","applyMediaQuery","join","map","index","realMap","width","height","aspectratio","applicatable","value","attr","matched","match","operator","realAttr","toLowerCase","real","expect","compare"],"sourceRoot":""}
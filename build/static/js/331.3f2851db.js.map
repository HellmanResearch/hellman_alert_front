{"version":3,"file":"static/js/331.3f2851db.js","mappings":"kUA+CWA,EAAa,CACtBC,KAAM,EACNC,MAAO,EACPC,IAAK,GAGHC,GAAmBC,EAAAA,EAAAA,MAKhB,SAASC,EAAqBC,GAEnCH,EAAiBG,GAASC,YAAaC,EAAAA,EAAAA,KACzC,CAiBO,SAASC,EAAgCC,EAAiBC,EAAaC,GAC5E,IAAIC,EAAS,CAAC,EACVC,EAAeC,EAAgCJ,GAEnD,IAAKG,IAAiBJ,EACpB,OAAOG,EAGT,IAKIG,EACAC,EANAC,EAAiB,GACjBC,EAAmB,GACnBb,EAAUK,EAAYL,QACtBC,EAAaJ,EAAiBG,GAASC,WACvCa,EAAMN,EAAaO,IAAM,IAAMT,EAAOU,eAG1CZ,EAAkBA,EAAgBa,SAClCC,EAAAA,EAAAA,IAAKd,GAAiB,SAAUe,EAAmBC,GACjD,IAAIC,GAAeC,EAAAA,EAAAA,IAASH,GAAqBA,EAAoBf,EAAgBgB,GAAe,CAClGG,KAAMJ,GAGkB,YAAtBE,EAAaG,MAA8C,MAAxBd,IACrCA,EAAuBU,EACvBT,EAA2Bc,EAA0BJ,IAGvDd,EAAOc,EAAaE,MAAQ,EAC9B,IACA,IAAIG,EAAgBzB,EAAW0B,IAAIb,IAAQb,EAAW2B,IAAId,EAAK,CAC7De,eAAgBlB,EAChBmB,YAAa,IA+Bf,SAASC,EAAQC,EAAWC,EAASC,GACnC,IAAK,IAAIC,EAAI,EAAGA,EAAID,EAAUC,IAC5BH,EAAUI,KAAKH,EAAUE,EAE7B,CAEA,SAASV,EAA0BJ,GACjC,IAAIgB,EAAUhB,EAAagB,QAC3B,OAAOA,EAAUA,EAAQC,OAAS,CACpC,CAIA,OAxCApB,EAAAA,EAAAA,IAAKd,GAAiB,SAAUiB,EAAcD,GAC5C,IAAImB,EAAelB,EAAaE,KAC5BiB,EAAQf,EAA0BJ,GAEtC,GAA4B,MAAxBX,EAA8B,CAChC,IAAI+B,EAAQf,EAAcI,YAC1BC,EAAQxB,EAAOgC,GAAeE,EAAOD,GACrCT,EAAQlB,EAAkB4B,EAAOD,GACjCd,EAAcI,aAAeU,CAM/B,MACS9B,IAAyBU,GAC9BW,EAAQxB,EAAOgC,GAAe,EAAGC,GACjCT,EAAQnB,EAAgB,EAAG4B,KAGrBC,EAAQf,EAAcG,eAC1BE,EAAQxB,EAAOgC,GAAeE,EAAOD,GACrCT,EAAQlB,EAAkB4B,EAAOD,GACjCd,EAAcG,gBAAkBW,EAExC,IAaA5B,EAAe0B,SAAW/B,EAAOmC,SAAW9B,GAC5CC,EAAiByB,SAAW/B,EAAOoC,WAAa9B,GACzCN,CACT,CAOO,SAASqC,EAA6BvC,EAAaC,EAAQuC,GAChE,IAAItC,EAAS,CAAC,EAGd,IAFmBE,EAAgCJ,GAGjD,OAAOE,EAGT,IAEIuC,EAFAC,EAAezC,EAAOyC,aACtBC,EAAmB1C,EAAO0C,iBAG1BD,IAAiBE,EAAAA,IAA6BF,IAAiBG,EAAAA,KACjEhC,EAAAA,EAAAA,IAAK8B,GAAkB,SAAUG,EAAKC,GACK,WAApC9B,EAAAA,EAAAA,IAAS6B,GAAOA,EAAI5B,KAAO4B,KAC9BL,EAAwBM,EAE5B,IAGF,IAAIC,EAAY,WAKd,IAJA,IAAIC,EAAU,CAAC,EACXC,EAAU,CAAC,EACXC,EAAe,GAEVrB,EAAI,EAAGsB,EAAMC,KAAKC,IAAI,EAAGd,GAAWV,EAAIsB,EAAKtB,IAAK,CACzD,IAAIyB,EAAcC,EAAevD,EAAOwD,KAAMf,EAAczC,EAAOU,eAAgBgC,EAAkB1C,EAAOyD,WAAY5B,GACxHqB,EAAapB,KAAKwB,GAClB,IAAII,EAAeJ,IAAgBnE,EAAWG,IAY9C,GARIoE,GAA6B,MAAbV,EAAQW,GAAa9B,IAAMW,IAC7CQ,EAAQW,EAAI9B,IAGG,MAAbmB,EAAQY,GAAaZ,EAAQY,IAAMZ,EAAQW,IAAMD,GAAgBR,EAAaF,EAAQY,KAAOzE,EAAWG,OAC1G0D,EAAQY,EAAI/B,GAGVgC,EAAUb,IAAYE,EAAaF,EAAQY,KAAOzE,EAAWG,IAC/D,OAAO0D,EASJU,IACCJ,IAAgBnE,EAAWE,OAAsB,MAAb4D,EAAQU,GAAa9B,IAAMW,IACjES,EAAQU,EAAI9B,GAGG,MAAboB,EAAQW,GAAaX,EAAQW,IAAMX,EAAQU,IAC7CV,EAAQW,EAAI/B,GAGlB,CAEA,SAASgC,EAAUd,GACjB,OAAsB,MAAfA,EAAUY,GAA4B,MAAfZ,EAAUa,CAC1C,CAEA,OAAOC,EAAUb,GAAWA,EAAUa,EAAUZ,GAAWA,EAAU,IACvE,CA9CgB,GAgDhB,GAAIF,EAAW,CACb9C,EAAO6D,MAAQ,CAACf,EAAUY,GAE1B,IAAII,EAAwC,MAAzBvB,EAAgCA,EAAwBO,EAAUa,EAGrF3D,EAAOmC,SAAW,CAAC2B,GACnB9D,EAAOoC,WAAa,CAAC0B,EACvB,CAEA,OAAO9D,CACT,CAKO,SAASE,EAAgCJ,GAQ9C,IAFeA,EAAYsB,IAAI,QAAQ,GAGrC,OAAO2C,EAAAA,EAAAA,IAAyBjE,EAAYL,QAAS,UAAW,CAC9DuE,MAAOlE,EAAYsB,IAAI,gBAAgB,GACvC6C,GAAInE,EAAYsB,IAAI,aAAa,IAChC8C,EAAAA,IAAkBC,OAAO,EAEhC,CAKO,SAASC,EAAkCnE,GAGhD,OAAKA,EAAamB,IAAI,aAAa,IAAUnB,EAAamB,IAAI,uBAAuB,IAI9E2C,EAAAA,EAAAA,IAAyB9D,EAAaR,QAAS,UAAW,CAC/DuE,MAAO/D,EAAamB,IAAI,oBAAoB,GAC5C6C,GAAIhE,EAAamB,IAAI,iBAAiB,IACrC8C,EAAAA,IAAkBC,OANZ,EAOX,CAOO,SAASE,EAAatE,EAAQuE,GACnC,OAAOhB,EAAevD,EAAOwD,KAAMxD,EAAOyC,aAAczC,EAAOU,eAAgBV,EAAO0C,iBAAkB1C,EAAOyD,WAAYc,EAC7H,CAGA,SAAShB,EAAeC,EAAMf,EAAc/B,EAAgBgC,EAAkBe,EAAYc,GACxF,IAAIC,EAUAC,EACAC,EAPJ,IAAIC,EAAAA,EAAAA,IAAanB,GACf,OAAOrE,EAAWG,IAQpB,GAAIoD,EAAkB,CACpB,IAAIkC,EAAalC,EAAiB6B,IAE9BvD,EAAAA,EAAAA,IAAS4D,IACXH,EAAUG,EAAW3D,KACrByD,EAAUE,EAAW1D,OACZ2D,EAAAA,EAAAA,IAASD,KAClBH,EAAUG,EAEd,CAEA,GAAe,MAAXF,EACF,MAAmB,YAAZA,EAAwBvF,EAAWC,KAAOD,EAAWG,IAG9D,GAAImD,IAAiBqC,EAAAA,GAA0B,CAC7C,IAAIC,EAAgBvB,EAEpB,GAAI9C,IAAmBsE,EAAAA,IAGrB,IAFA,IAAIC,EAASF,EAAcR,GAElB1C,EAAI,EAAGA,GAAKoD,GAAU,IAAIjD,QAAUH,EAhCnC,EAgCgDA,IACxD,GAAsD,OAAjD2C,EAASU,EAAYD,EAAOxB,EAAa5B,KAC5C,OAAO2C,OAIX,IAAS3C,EAAI,EAAGA,EAAIkD,EAAc/C,QAAUH,EAtClC,EAsC+CA,IAAK,CAC5D,IAAIsD,EAAMJ,EAActB,EAAa5B,GAErC,GAAIsD,GAAgD,OAAxCX,EAASU,EAAYC,EAAIZ,KACnC,OAAOC,CAEX,CAEJ,MAAO,GAAI/B,IAAiBE,EAAAA,GAA2B,CACrD,IAAIyC,EAAiB5B,EAErB,IAAKiB,EACH,OAAOtF,EAAWG,IAGpB,IAASuC,EAAI,EAAGA,EAAIuD,EAAepD,QAAUH,EArDjC,EAqD8CA,IAGxD,IAFIwD,EAAOD,EAAevD,KAE2B,OAAxC2C,EAASU,EAAYG,EAAKZ,KACrC,OAAOD,CAGb,MAAO,GAAI/B,IAAiBG,EAAAA,GAA6B,CACvD,IAAI0C,EAAmB9B,EAEvB,IAAKiB,EACH,OAAOtF,EAAWG,IAKpB,KAFI2F,EAASK,EAAiBb,MAEfE,EAAAA,EAAAA,IAAaM,GAC1B,OAAO9F,EAAWG,IAGpB,IAASuC,EAAI,EAAGA,EAAIoD,EAAOjD,QAAUH,EAzEzB,EAyEsCA,IAChD,GAAyC,OAApC2C,EAASU,EAAYD,EAAOpD,KAC/B,OAAO2C,CAGb,MAAO,GAAI/B,IAAiB8C,EAAAA,GAC1B,KAAIC,EAAehC,EAEnB,IAAS3B,EAAI,EAAGA,EAAI2D,EAAaxD,QAAUH,EAjF/B,EAiF4CA,IAAK,CAC3D,IAAIwD,EAAOG,EAAa3D,GACpB4D,GAAMC,EAAAA,EAAAA,IAAiBL,GAE3B,KAAKM,EAAAA,EAAAA,IAAQF,GACX,OAAOtG,EAAWG,IAGpB,GAA6C,OAAxCkF,EAASU,EAAYO,EAAIlB,KAC5B,OAAOC,CAEX,CAbuB,CAgBzB,SAASU,EAAYO,GACnB,IAAIG,GAAQf,EAAAA,EAAAA,IAASY,GAGrB,OAAW,MAAPA,GAAeI,SAASJ,IAAgB,KAARA,EAC3BG,EAAQzG,EAAWE,MAAQF,EAAWG,IACpCsG,GAAiB,MAARH,EACXtG,EAAWC,UADb,CAGT,CAEA,OAAOD,EAAWG,GACpB,C,+JC/PIwG,EAEJ,WACE,SAASA,EAAcC,GAErBC,KAAKC,YAAc,GACnBD,KAAKE,WAAa,GAElBF,KAAKG,kBAAoB,GACzBH,KAAKI,iBAAmB,EACxBJ,KAAKK,QAAS,EACdL,KAAKM,YAAcP,CACrB,CA+SA,OAzSAD,EAAcS,UAAUC,MAAQ,WAC9BR,KAAKS,gBAAgB,GAAI,IAEzBT,KAAKE,WAAa,GAClBF,KAAKK,QAAS,CAChB,EAEAP,EAAcS,UAAUE,gBAAkB,SAAUC,EAAYC,GAC9DX,KAAKC,YAAcS,EACnBV,KAAKG,kBAAoBQ,EACzBX,KAAKI,mBAEDJ,KAAKI,iBAAmB,OAC1BJ,KAAKI,iBAAmB,EAE5B,EAOAN,EAAcS,UAAUK,gBAAkB,WACxC,OAAOZ,KAAKM,YAAY7F,IAAM,IAAMuF,KAAKI,gBAC3C,EAMAN,EAAcS,UAAUM,cAAgB,WAGlCb,KAAKc,aACPd,KAAKe,gBAELf,KAAKK,QAAS,EAElB,EAEAP,EAAcS,UAAUQ,cAAgB,WACtCf,KAAKS,gBAAgB,GAAI,IAEzB,IAKIO,EACAL,EANAZ,EAAaC,KAAKM,YAElBW,EAAkBjB,KAAKkB,6BAEvBC,IAAgBF,EAAgBjF,OAIpC,GAAIoF,EAASrB,GAAa,CACxB,IAAIhG,EAAcgG,EACdvC,OAAO,EACPf,OAAe,EACf4E,OAAW,EAEf,GAAIF,EAAa,CACf,IAAIG,EAAcL,EAAgB,GAClCK,EAAYT,gBAEZrD,GADA6D,EAAWC,EAAYC,aACP/D,KAChBf,EAAe4E,EAAS5E,aACxBkE,EAAmB,CAACW,EAAYV,kBAClC,MAEIpD,EAAOzD,EAAYsB,IAAI,QAAQ,GAC/BoB,GAAekC,EAAAA,EAAAA,IAAanB,GAAQgE,EAAAA,GAA4BjC,EAAAA,GAChEoB,EAAmB,GAIvB,IAAIc,EAAmBzB,KAAK0B,2BAA6B,CAAC,EACtDC,EAAkBN,GAAYA,EAASO,eAAiB,CAAC,EACzDlH,GAAiBmH,EAAAA,EAAAA,IAAUJ,EAAiB/G,eAAgBiH,EAAgBjH,iBAAmB,KAC/FoH,GAAeD,EAAAA,EAAAA,IAAUJ,EAAiBK,aAAcH,EAAgBG,cAIxEC,GAAaF,EAAAA,EAAAA,IAAUJ,EAAiBM,WAAYJ,EAAgBI,YAIxEf,EADwBtG,IAAmBiH,EAAgBjH,kBAAoBoH,KAAmBH,EAAgBG,cAAgBC,EAC3F,EAACC,EAAAA,EAAAA,IAAaxE,EAAM,CACzD9C,eAAgBA,EAChBoH,aAAcA,EACdC,WAAYA,GACXtF,IAAiB,EACtB,KAAO,CACL,IAAIvC,EAAe6F,EAEnB,GAAIoB,EAAa,CACf,IAAI3C,EAASwB,KAAKiC,gBAAgBhB,GAElCD,EAAmBxC,EAAOkC,WAC1BC,EAAmBnC,EAAOmC,gBAC5B,KACK,CACD,IAAIuB,EAAahI,EAAamB,IAAI,UAAU,GAC5C2F,EAAmB,EAACgB,EAAAA,EAAAA,IAAaE,EAAYlC,KAAK0B,0BAA2B,OAC7Ef,EAAmB,EACrB,CACJ,CAMAX,KAAKS,gBAAgBO,EAAkBL,EACzC,EAEAb,EAAcS,UAAU0B,gBAAkB,SAAUE,GAClD,IAoBIzB,EApBAxG,EAAe8F,KAAKM,YACpB8B,EAAkBlI,EAAamB,IAAI,aAAa,GAChDgH,EAAsBnI,EAAamB,IAAI,uBAAuB,GAMvC,MAAvBgH,GAGuB,IAArBF,EAAUnG,QAKZsG,EAPW,IAYf,IAAIC,EAAe,GACf5B,EAAmB,GA0BvB,OAzBA/F,EAAAA,EAAAA,IAAKuH,GAAW,SAAUK,GACxBA,EAAM3B,gBACN,IAAIQ,EAAWmB,EAAMjB,UAAUc,GAAuB,GAG3B,MAAvBA,GAAgChB,GAKlCiB,EAPW,IAUbC,EAAazG,KAAKuF,GAClBV,EAAiB7E,KAAK0G,EAAM5B,kBAC9B,IAEIwB,EACF1B,GAAa+B,EAAAA,EAAAA,IAAmBL,EAAiBG,EAAc,CAC7DG,aAAcxI,EAAayI,iBAEG,MAAvBN,IACT3B,EAAa,EAACkC,EAAAA,EAAAA,IAAmBL,EAAa,MAGzC,CACL7B,WAAYA,EACZC,iBAAkBA,EAEtB,EAEAb,EAAcS,UAAUO,SAAW,WACjC,GAAId,KAAKK,OACP,OAAO,EAMT,IAFA,IAAIY,EAAkBjB,KAAKkB,6BAElBrF,EAAI,EAAGA,EAAIoF,EAAgBjF,OAAQH,IAAK,CAC/C,IAAIgH,EAAW5B,EAAgBpF,GAE/B,GAEAgH,EAAS/B,YAAcd,KAAKG,kBAAkBtE,KAAOgH,EAASjC,kBAC5D,OAAO,CAEX,CACF,EAOAd,EAAcS,UAAUgB,UAAY,SAAUuB,GAC5CA,EAAcA,GAAe,EAC7B,IAAI9I,EAASgG,KAAKC,YAAY6C,GAE9B,IAAK9I,EAAQ,CAEX,IAAIiH,EAAkBjB,KAAKkB,6BAE3B,OAAOD,EAAgB,IAAMA,EAAgB,GAAGM,UAAUuB,EAC5D,CAEA,OAAO9I,CACT,EAWA8F,EAAcS,UAAUwC,mBAAqB,SAAUC,GAKrD,IAAIC,EAASD,EAAiBE,kBAC9B,OAAOlD,KAAKmD,mBAAmBF,EAAOlB,WAAYiB,EAAiBhJ,OAAQiJ,EAAOG,KACpF,EAEAtD,EAAcS,UAAU4C,mBAAqB,SAAUE,EAAWC,EAAcC,GAE9E,IACIC,EAAYxD,KAAKE,WACjBuD,EAAiBD,EAFH,GAIbC,IACHA,EAAiBD,EALD,GAK0B,CAAC,GAG7C,IAAIE,EAAcD,EAAeF,GAEjC,IAAKG,EAAa,CAChB,IAAIpC,EAActB,KAAKkB,6BAA6B,GAEhDE,EAASpB,KAAKM,cAAgBgB,EAChCoC,EAAcpC,EAAY6B,mBAAmBE,EAAWC,EAAcC,IAEtEG,EAAc,IAAIC,EAAAA,IAENC,SAAS,IAAIC,EAAAA,GAAoBP,EAAcD,EAAUrH,QAASqH,GAGhFI,EAAeF,GAAiBG,CAClC,CAEA,OAAOA,CACT,EAOA5D,EAAcS,UAAUW,2BAA6B,WAInD,IAAInB,EAAaC,KAAKM,YAEtB,GAAIc,EAASrB,GAAa,CACxB,IAAI7F,GAAeC,EAAAA,EAAAA,IAAgC4F,GACnD,OAAQ7F,EAAoB,CAACA,EAAa4J,oBAAnB,EACzB,CACE,OAAOC,EAAAA,EAAAA,KAAI1F,EAAAA,EAAAA,IAAkC0B,IAAa,SAAU7F,GAClE,OAAOA,EAAa4J,kBACtB,GAEJ,EAEAhE,EAAcS,UAAUmB,wBAA0B,WAChD,IACIhH,EACAoH,EACAC,EAHAhC,EAAaC,KAAKM,YAKtB,GAAIc,EAASrB,GACXrF,EAAiBqF,EAAW1E,IAAI,kBAAkB,GAClDyG,EAAe/B,EAAW1E,IAAI,gBAAgB,GAC9C0G,EAAahC,EAAW1E,IAAI,cAAc,QAEvC,IAAK2E,KAAKkB,6BAA6BlF,OAAQ,CAChD,IAAIgI,EAAQjE,EACZrF,EAAiBsJ,EAAM3I,IAAI,kBAAkB,GAC7CyG,EAAekC,EAAM3I,IAAI,gBAAgB,GACzC0G,EAAaiC,EAAM3I,IAAI,cAAc,EACvC,CAEF,MAAO,CACLX,eAAgBA,EAChBoH,aAAcA,EACdC,WAAYA,EAEhB,EAEOjC,CACT,CA1TA,GA+TO,SAASmE,EAA4B/J,GACpBA,EAAagK,OAAOC,YACvBC,EAAAA,EAAAA,IAAelK,EAAagK,OAAOC,UACxD,CAEA,SAAS/C,EAASrB,GAEhB,MAA+B,WAAxBA,EAAWsE,QACpB,CAEA,SAAS/B,EAAQgC,GACf,MAAM,IAAIC,MAAMD,EAClB,C","sources":["../node_modules/echarts/lib/data/helper/sourceHelper.js","../node_modules/echarts/lib/data/helper/sourceManager.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { makeInner, getDataItemValue, queryReferringComponents, SINGLE_REFERRING } from '../../util/model.js';\nimport { createHashMap, each, isArray, isString, isObject, isTypedArray } from 'zrender/lib/core/util.js';\nimport { SOURCE_FORMAT_ORIGINAL, SOURCE_FORMAT_ARRAY_ROWS, SOURCE_FORMAT_OBJECT_ROWS, SERIES_LAYOUT_BY_ROW, SOURCE_FORMAT_KEYED_COLUMNS } from '../../util/types.js'; // The result of `guessOrdinal`.\n\nexport var BE_ORDINAL = {\n  Must: 1,\n  Might: 2,\n  Not: 3 // Other cases\n\n};\nvar innerGlobalModel = makeInner();\n/**\n * MUST be called before mergeOption of all series.\n */\n\nexport function resetSourceDefaulter(ecModel) {\n  // `datasetMap` is used to make default encode.\n  innerGlobalModel(ecModel).datasetMap = createHashMap();\n}\n/**\n * [The strategy of the arrengment of data dimensions for dataset]:\n * \"value way\": all axes are non-category axes. So series one by one take\n *     several (the number is coordSysDims.length) dimensions from dataset.\n *     The result of data arrengment of data dimensions like:\n *     | ser0_x | ser0_y | ser1_x | ser1_y | ser2_x | ser2_y |\n * \"category way\": at least one axis is category axis. So the the first data\n *     dimension is always mapped to the first category axis and shared by\n *     all of the series. The other data dimensions are taken by series like\n *     \"value way\" does.\n *     The result of data arrengment of data dimensions like:\n *     | ser_shared_x | ser0_y | ser1_y | ser2_y |\n *\n * @return encode Never be `null/undefined`.\n */\n\nexport function makeSeriesEncodeForAxisCoordSys(coordDimensions, seriesModel, source) {\n  var encode = {};\n  var datasetModel = querySeriesUpstreamDatasetModel(seriesModel); // Currently only make default when using dataset, util more reqirements occur.\n\n  if (!datasetModel || !coordDimensions) {\n    return encode;\n  }\n\n  var encodeItemName = [];\n  var encodeSeriesName = [];\n  var ecModel = seriesModel.ecModel;\n  var datasetMap = innerGlobalModel(ecModel).datasetMap;\n  var key = datasetModel.uid + '_' + source.seriesLayoutBy;\n  var baseCategoryDimIndex;\n  var categoryWayValueDimStart;\n  coordDimensions = coordDimensions.slice();\n  each(coordDimensions, function (coordDimInfoLoose, coordDimIdx) {\n    var coordDimInfo = isObject(coordDimInfoLoose) ? coordDimInfoLoose : coordDimensions[coordDimIdx] = {\n      name: coordDimInfoLoose\n    };\n\n    if (coordDimInfo.type === 'ordinal' && baseCategoryDimIndex == null) {\n      baseCategoryDimIndex = coordDimIdx;\n      categoryWayValueDimStart = getDataDimCountOnCoordDim(coordDimInfo);\n    }\n\n    encode[coordDimInfo.name] = [];\n  });\n  var datasetRecord = datasetMap.get(key) || datasetMap.set(key, {\n    categoryWayDim: categoryWayValueDimStart,\n    valueWayDim: 0\n  }); // TODO\n  // Auto detect first time axis and do arrangement.\n\n  each(coordDimensions, function (coordDimInfo, coordDimIdx) {\n    var coordDimName = coordDimInfo.name;\n    var count = getDataDimCountOnCoordDim(coordDimInfo); // In value way.\n\n    if (baseCategoryDimIndex == null) {\n      var start = datasetRecord.valueWayDim;\n      pushDim(encode[coordDimName], start, count);\n      pushDim(encodeSeriesName, start, count);\n      datasetRecord.valueWayDim += count; // ??? TODO give a better default series name rule?\n      // especially when encode x y specified.\n      // consider: when mutiple series share one dimension\n      // category axis, series name should better use\n      // the other dimsion name. On the other hand, use\n      // both dimensions name.\n    } // In category way, the first category axis.\n    else if (baseCategoryDimIndex === coordDimIdx) {\n        pushDim(encode[coordDimName], 0, count);\n        pushDim(encodeItemName, 0, count);\n      } // In category way, the other axis.\n      else {\n          var start = datasetRecord.categoryWayDim;\n          pushDim(encode[coordDimName], start, count);\n          pushDim(encodeSeriesName, start, count);\n          datasetRecord.categoryWayDim += count;\n        }\n  });\n\n  function pushDim(dimIdxArr, idxFrom, idxCount) {\n    for (var i = 0; i < idxCount; i++) {\n      dimIdxArr.push(idxFrom + i);\n    }\n  }\n\n  function getDataDimCountOnCoordDim(coordDimInfo) {\n    var dimsDef = coordDimInfo.dimsDef;\n    return dimsDef ? dimsDef.length : 1;\n  }\n\n  encodeItemName.length && (encode.itemName = encodeItemName);\n  encodeSeriesName.length && (encode.seriesName = encodeSeriesName);\n  return encode;\n}\n/**\n * Work for data like [{name: ..., value: ...}, ...].\n *\n * @return encode Never be `null/undefined`.\n */\n\nexport function makeSeriesEncodeForNameBased(seriesModel, source, dimCount) {\n  var encode = {};\n  var datasetModel = querySeriesUpstreamDatasetModel(seriesModel); // Currently only make default when using dataset, util more reqirements occur.\n\n  if (!datasetModel) {\n    return encode;\n  }\n\n  var sourceFormat = source.sourceFormat;\n  var dimensionsDefine = source.dimensionsDefine;\n  var potentialNameDimIndex;\n\n  if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS || sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {\n    each(dimensionsDefine, function (dim, idx) {\n      if ((isObject(dim) ? dim.name : dim) === 'name') {\n        potentialNameDimIndex = idx;\n      }\n    });\n  }\n\n  var idxResult = function () {\n    var idxRes0 = {};\n    var idxRes1 = {};\n    var guessRecords = []; // 5 is an experience value.\n\n    for (var i = 0, len = Math.min(5, dimCount); i < len; i++) {\n      var guessResult = doGuessOrdinal(source.data, sourceFormat, source.seriesLayoutBy, dimensionsDefine, source.startIndex, i);\n      guessRecords.push(guessResult);\n      var isPureNumber = guessResult === BE_ORDINAL.Not; // [Strategy of idxRes0]: find the first BE_ORDINAL.Not as the value dim,\n      // and then find a name dim with the priority:\n      // \"BE_ORDINAL.Might|BE_ORDINAL.Must\" > \"other dim\" > \"the value dim itself\".\n\n      if (isPureNumber && idxRes0.v == null && i !== potentialNameDimIndex) {\n        idxRes0.v = i;\n      }\n\n      if (idxRes0.n == null || idxRes0.n === idxRes0.v || !isPureNumber && guessRecords[idxRes0.n] === BE_ORDINAL.Not) {\n        idxRes0.n = i;\n      }\n\n      if (fulfilled(idxRes0) && guessRecords[idxRes0.n] !== BE_ORDINAL.Not) {\n        return idxRes0;\n      } // [Strategy of idxRes1]: if idxRes0 not satisfied (that is, no BE_ORDINAL.Not),\n      // find the first BE_ORDINAL.Might as the value dim,\n      // and then find a name dim with the priority:\n      // \"other dim\" > \"the value dim itself\".\n      // That is for backward compat: number-like (e.g., `'3'`, `'55'`) can be\n      // treated as number.\n\n\n      if (!isPureNumber) {\n        if (guessResult === BE_ORDINAL.Might && idxRes1.v == null && i !== potentialNameDimIndex) {\n          idxRes1.v = i;\n        }\n\n        if (idxRes1.n == null || idxRes1.n === idxRes1.v) {\n          idxRes1.n = i;\n        }\n      }\n    }\n\n    function fulfilled(idxResult) {\n      return idxResult.v != null && idxResult.n != null;\n    }\n\n    return fulfilled(idxRes0) ? idxRes0 : fulfilled(idxRes1) ? idxRes1 : null;\n  }();\n\n  if (idxResult) {\n    encode.value = [idxResult.v]; // `potentialNameDimIndex` has highest priority.\n\n    var nameDimIndex = potentialNameDimIndex != null ? potentialNameDimIndex : idxResult.n; // By default, label use itemName in charts.\n    // So we dont set encodeLabel here.\n\n    encode.itemName = [nameDimIndex];\n    encode.seriesName = [nameDimIndex];\n  }\n\n  return encode;\n}\n/**\n * @return If return null/undefined, indicate that should not use datasetModel.\n */\n\nexport function querySeriesUpstreamDatasetModel(seriesModel) {\n  // Caution: consider the scenario:\n  // A dataset is declared and a series is not expected to use the dataset,\n  // and at the beginning `setOption({series: { noData })` (just prepare other\n  // option but no data), then `setOption({series: {data: [...]}); In this case,\n  // the user should set an empty array to avoid that dataset is used by default.\n  var thisData = seriesModel.get('data', true);\n\n  if (!thisData) {\n    return queryReferringComponents(seriesModel.ecModel, 'dataset', {\n      index: seriesModel.get('datasetIndex', true),\n      id: seriesModel.get('datasetId', true)\n    }, SINGLE_REFERRING).models[0];\n  }\n}\n/**\n * @return Always return an array event empty.\n */\n\nexport function queryDatasetUpstreamDatasetModels(datasetModel) {\n  // Only these attributes declared, we by defualt reference to `datasetIndex: 0`.\n  // Otherwise, no reference.\n  if (!datasetModel.get('transform', true) && !datasetModel.get('fromTransformResult', true)) {\n    return [];\n  }\n\n  return queryReferringComponents(datasetModel.ecModel, 'dataset', {\n    index: datasetModel.get('fromDatasetIndex', true),\n    id: datasetModel.get('fromDatasetId', true)\n  }, SINGLE_REFERRING).models;\n}\n/**\n * The rule should not be complex, otherwise user might not\n * be able to known where the data is wrong.\n * The code is ugly, but how to make it neat?\n */\n\nexport function guessOrdinal(source, dimIndex) {\n  return doGuessOrdinal(source.data, source.sourceFormat, source.seriesLayoutBy, source.dimensionsDefine, source.startIndex, dimIndex);\n} // dimIndex may be overflow source data.\n// return {BE_ORDINAL}\n\nfunction doGuessOrdinal(data, sourceFormat, seriesLayoutBy, dimensionsDefine, startIndex, dimIndex) {\n  var result; // Experience value.\n\n  var maxLoop = 5;\n\n  if (isTypedArray(data)) {\n    return BE_ORDINAL.Not;\n  } // When sourceType is 'objectRows' or 'keyedColumns', dimensionsDefine\n  // always exists in source.\n\n\n  var dimName;\n  var dimType;\n\n  if (dimensionsDefine) {\n    var dimDefItem = dimensionsDefine[dimIndex];\n\n    if (isObject(dimDefItem)) {\n      dimName = dimDefItem.name;\n      dimType = dimDefItem.type;\n    } else if (isString(dimDefItem)) {\n      dimName = dimDefItem;\n    }\n  }\n\n  if (dimType != null) {\n    return dimType === 'ordinal' ? BE_ORDINAL.Must : BE_ORDINAL.Not;\n  }\n\n  if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {\n    var dataArrayRows = data;\n\n    if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) {\n      var sample = dataArrayRows[dimIndex];\n\n      for (var i = 0; i < (sample || []).length && i < maxLoop; i++) {\n        if ((result = detectValue(sample[startIndex + i])) != null) {\n          return result;\n        }\n      }\n    } else {\n      for (var i = 0; i < dataArrayRows.length && i < maxLoop; i++) {\n        var row = dataArrayRows[startIndex + i];\n\n        if (row && (result = detectValue(row[dimIndex])) != null) {\n          return result;\n        }\n      }\n    }\n  } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {\n    var dataObjectRows = data;\n\n    if (!dimName) {\n      return BE_ORDINAL.Not;\n    }\n\n    for (var i = 0; i < dataObjectRows.length && i < maxLoop; i++) {\n      var item = dataObjectRows[i];\n\n      if (item && (result = detectValue(item[dimName])) != null) {\n        return result;\n      }\n    }\n  } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {\n    var dataKeyedColumns = data;\n\n    if (!dimName) {\n      return BE_ORDINAL.Not;\n    }\n\n    var sample = dataKeyedColumns[dimName];\n\n    if (!sample || isTypedArray(sample)) {\n      return BE_ORDINAL.Not;\n    }\n\n    for (var i = 0; i < sample.length && i < maxLoop; i++) {\n      if ((result = detectValue(sample[i])) != null) {\n        return result;\n      }\n    }\n  } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {\n    var dataOriginal = data;\n\n    for (var i = 0; i < dataOriginal.length && i < maxLoop; i++) {\n      var item = dataOriginal[i];\n      var val = getDataItemValue(item);\n\n      if (!isArray(val)) {\n        return BE_ORDINAL.Not;\n      }\n\n      if ((result = detectValue(val[dimIndex])) != null) {\n        return result;\n      }\n    }\n  }\n\n  function detectValue(val) {\n    var beStr = isString(val); // Consider usage convenience, '1', '2' will be treated as \"number\".\n    // `isFinit('')` get `true`.\n\n    if (val != null && isFinite(val) && val !== '') {\n      return beStr ? BE_ORDINAL.Might : BE_ORDINAL.Not;\n    } else if (beStr && val !== '-') {\n      return BE_ORDINAL.Must;\n    }\n  }\n\n  return BE_ORDINAL.Not;\n}","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { setAsPrimitive, map, isTypedArray, assert, each, retrieve2 } from 'zrender/lib/core/util.js';\nimport { createSource, cloneSourceShallow } from '../Source.js';\nimport { SOURCE_FORMAT_TYPED_ARRAY, SOURCE_FORMAT_ORIGINAL } from '../../util/types.js';\nimport { querySeriesUpstreamDatasetModel, queryDatasetUpstreamDatasetModels } from './sourceHelper.js';\nimport { applyDataTransform } from './transform.js';\nimport DataStore from '../DataStore.js';\nimport { DefaultDataProvider } from './dataProvider.js';\n/**\n * [REQUIREMENT_MEMO]:\n * (0) `metaRawOption` means `dimensions`/`sourceHeader`/`seriesLayoutBy` in raw option.\n * (1) Keep support the feature: `metaRawOption` can be specified both on `series` and\n * `root-dataset`. Them on `series` has higher priority.\n * (2) Do not support to set `metaRawOption` on a `non-root-dataset`, because it might\n * confuse users: whether those props indicate how to visit the upstream source or visit\n * the transform result source, and some transforms has nothing to do with these props,\n * and some transforms might have multiple upstream.\n * (3) Transforms should specify `metaRawOption` in each output, just like they can be\n * declared in `root-dataset`.\n * (4) At present only support visit source in `SERIES_LAYOUT_BY_COLUMN` in transforms.\n * That is for reducing complexity in transfroms.\n * PENDING: Whether to provide transposition transform?\n *\n * [IMPLEMENTAION_MEMO]:\n * \"sourceVisitConfig\" are calculated from `metaRawOption` and `data`.\n * They will not be calculated until `source` is about to be visited (to prevent from\n * duplicate calcuation). `source` is visited only in series and input to transforms.\n *\n * [DIMENSION_INHERIT_RULE]:\n * By default the dimensions are inherited from ancestors, unless a transform return\n * a new dimensions definition.\n * Consider the case:\n * ```js\n * dataset: [{\n *     source: [ ['Product', 'Sales', 'Prise'], ['Cookies', 321, 44.21], ...]\n * }, {\n *     transform: { type: 'filter', ... }\n * }]\n * dataset: [{\n *     dimension: ['Product', 'Sales', 'Prise'],\n *     source: [ ['Cookies', 321, 44.21], ...]\n * }, {\n *     transform: { type: 'filter', ... }\n * }]\n * ```\n * The two types of option should have the same behavior after transform.\n *\n *\n * [SCENARIO]:\n * (1) Provide source data directly:\n * ```js\n * series: {\n *     encode: {...},\n *     dimensions: [...]\n *     seriesLayoutBy: 'row',\n *     data: [[...]]\n * }\n * ```\n * (2) Series refer to dataset.\n * ```js\n * series: [{\n *     encode: {...}\n *     // Ignore datasetIndex means `datasetIndex: 0`\n *     // and the dimensions defination in dataset is used\n * }, {\n *     encode: {...},\n *     seriesLayoutBy: 'column',\n *     datasetIndex: 1\n * }]\n * ```\n * (3) dataset transform\n * ```js\n * dataset: [{\n *     source: [...]\n * }, {\n *     source: [...]\n * }, {\n *     // By default from 0.\n *     transform: { type: 'filter', config: {...} }\n * }, {\n *     // Piped.\n *     transform: [\n *         { type: 'filter', config: {...} },\n *         { type: 'sort', config: {...} }\n *     ]\n * }, {\n *     id: 'regressionData',\n *     fromDatasetIndex: 1,\n *     // Third-party transform\n *     transform: { type: 'ecStat:regression', config: {...} }\n * }, {\n *     // retrieve the extra result.\n *     id: 'regressionFormula',\n *     fromDatasetId: 'regressionData',\n *     fromTransformResult: 1\n * }]\n * ```\n */\n\nvar SourceManager =\n/** @class */\nfunction () {\n  function SourceManager(sourceHost) {\n    // Cached source. Do not repeat calculating if not dirty.\n    this._sourceList = [];\n    this._storeList = []; // version sign of each upstream source manager.\n\n    this._upstreamSignList = [];\n    this._versionSignBase = 0;\n    this._dirty = true;\n    this._sourceHost = sourceHost;\n  }\n  /**\n   * Mark dirty.\n   */\n\n\n  SourceManager.prototype.dirty = function () {\n    this._setLocalSource([], []);\n\n    this._storeList = [];\n    this._dirty = true;\n  };\n\n  SourceManager.prototype._setLocalSource = function (sourceList, upstreamSignList) {\n    this._sourceList = sourceList;\n    this._upstreamSignList = upstreamSignList;\n    this._versionSignBase++;\n\n    if (this._versionSignBase > 9e10) {\n      this._versionSignBase = 0;\n    }\n  };\n  /**\n   * For detecting whether the upstream source is dirty, so that\n   * the local cached source (in `_sourceList`) should be discarded.\n   */\n\n\n  SourceManager.prototype._getVersionSign = function () {\n    return this._sourceHost.uid + '_' + this._versionSignBase;\n  };\n  /**\n   * Always return a source instance. Otherwise throw error.\n   */\n\n\n  SourceManager.prototype.prepareSource = function () {\n    // For the case that call `setOption` multiple time but no data changed,\n    // cache the result source to prevent from repeating transform.\n    if (this._isDirty()) {\n      this._createSource();\n\n      this._dirty = false;\n    }\n  };\n\n  SourceManager.prototype._createSource = function () {\n    this._setLocalSource([], []);\n\n    var sourceHost = this._sourceHost;\n\n    var upSourceMgrList = this._getUpstreamSourceManagers();\n\n    var hasUpstream = !!upSourceMgrList.length;\n    var resultSourceList;\n    var upstreamSignList;\n\n    if (isSeries(sourceHost)) {\n      var seriesModel = sourceHost;\n      var data = void 0;\n      var sourceFormat = void 0;\n      var upSource = void 0; // Has upstream dataset\n\n      if (hasUpstream) {\n        var upSourceMgr = upSourceMgrList[0];\n        upSourceMgr.prepareSource();\n        upSource = upSourceMgr.getSource();\n        data = upSource.data;\n        sourceFormat = upSource.sourceFormat;\n        upstreamSignList = [upSourceMgr._getVersionSign()];\n      } // Series data is from own.\n      else {\n          data = seriesModel.get('data', true);\n          sourceFormat = isTypedArray(data) ? SOURCE_FORMAT_TYPED_ARRAY : SOURCE_FORMAT_ORIGINAL;\n          upstreamSignList = [];\n        } // See [REQUIREMENT_MEMO], merge settings on series and parent dataset if it is root.\n\n\n      var newMetaRawOption = this._getSourceMetaRawOption() || {};\n      var upMetaRawOption = upSource && upSource.metaRawOption || {};\n      var seriesLayoutBy = retrieve2(newMetaRawOption.seriesLayoutBy, upMetaRawOption.seriesLayoutBy) || null;\n      var sourceHeader = retrieve2(newMetaRawOption.sourceHeader, upMetaRawOption.sourceHeader); // Note here we should not use `upSource.dimensionsDefine`. Consider the case:\n      // `upSource.dimensionsDefine` is detected by `seriesLayoutBy: 'column'`,\n      // but series need `seriesLayoutBy: 'row'`.\n\n      var dimensions = retrieve2(newMetaRawOption.dimensions, upMetaRawOption.dimensions); // We share source with dataset as much as possible\n      // to avoid extra memroy cost of high dimensional data.\n\n      var needsCreateSource = seriesLayoutBy !== upMetaRawOption.seriesLayoutBy || !!sourceHeader !== !!upMetaRawOption.sourceHeader || dimensions;\n      resultSourceList = needsCreateSource ? [createSource(data, {\n        seriesLayoutBy: seriesLayoutBy,\n        sourceHeader: sourceHeader,\n        dimensions: dimensions\n      }, sourceFormat)] : [];\n    } else {\n      var datasetModel = sourceHost; // Has upstream dataset.\n\n      if (hasUpstream) {\n        var result = this._applyTransform(upSourceMgrList);\n\n        resultSourceList = result.sourceList;\n        upstreamSignList = result.upstreamSignList;\n      } // Is root dataset.\n      else {\n          var sourceData = datasetModel.get('source', true);\n          resultSourceList = [createSource(sourceData, this._getSourceMetaRawOption(), null)];\n          upstreamSignList = [];\n        }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert(resultSourceList && upstreamSignList);\n    }\n\n    this._setLocalSource(resultSourceList, upstreamSignList);\n  };\n\n  SourceManager.prototype._applyTransform = function (upMgrList) {\n    var datasetModel = this._sourceHost;\n    var transformOption = datasetModel.get('transform', true);\n    var fromTransformResult = datasetModel.get('fromTransformResult', true);\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert(fromTransformResult != null || transformOption != null);\n    }\n\n    if (fromTransformResult != null) {\n      var errMsg = '';\n\n      if (upMgrList.length !== 1) {\n        if (process.env.NODE_ENV !== 'production') {\n          errMsg = 'When using `fromTransformResult`, there should be only one upstream dataset';\n        }\n\n        doThrow(errMsg);\n      }\n    }\n\n    var sourceList;\n    var upSourceList = [];\n    var upstreamSignList = [];\n    each(upMgrList, function (upMgr) {\n      upMgr.prepareSource();\n      var upSource = upMgr.getSource(fromTransformResult || 0);\n      var errMsg = '';\n\n      if (fromTransformResult != null && !upSource) {\n        if (process.env.NODE_ENV !== 'production') {\n          errMsg = 'Can not retrieve result by `fromTransformResult`: ' + fromTransformResult;\n        }\n\n        doThrow(errMsg);\n      }\n\n      upSourceList.push(upSource);\n      upstreamSignList.push(upMgr._getVersionSign());\n    });\n\n    if (transformOption) {\n      sourceList = applyDataTransform(transformOption, upSourceList, {\n        datasetIndex: datasetModel.componentIndex\n      });\n    } else if (fromTransformResult != null) {\n      sourceList = [cloneSourceShallow(upSourceList[0])];\n    }\n\n    return {\n      sourceList: sourceList,\n      upstreamSignList: upstreamSignList\n    };\n  };\n\n  SourceManager.prototype._isDirty = function () {\n    if (this._dirty) {\n      return true;\n    } // All sourceList is from the some upsteam.\n\n\n    var upSourceMgrList = this._getUpstreamSourceManagers();\n\n    for (var i = 0; i < upSourceMgrList.length; i++) {\n      var upSrcMgr = upSourceMgrList[i];\n\n      if ( // Consider the case that there is ancestor diry, call it recursively.\n      // The performance is probably not an issue because usually the chain is not long.\n      upSrcMgr._isDirty() || this._upstreamSignList[i] !== upSrcMgr._getVersionSign()) {\n        return true;\n      }\n    }\n  };\n  /**\n   * @param sourceIndex By defualt 0, means \"main source\".\n   *                    Most cases there is only one source.\n   */\n\n\n  SourceManager.prototype.getSource = function (sourceIndex) {\n    sourceIndex = sourceIndex || 0;\n    var source = this._sourceList[sourceIndex];\n\n    if (!source) {\n      // Series may share source instance with dataset.\n      var upSourceMgrList = this._getUpstreamSourceManagers();\n\n      return upSourceMgrList[0] && upSourceMgrList[0].getSource(sourceIndex);\n    }\n\n    return source;\n  };\n  /**\n   *\n   * Get a data store which can be shared across series.\n   * Only available for series.\n   *\n   * @param seriesDimRequest Dimensions that are generated in series.\n   *        Should have been sorted by `storeDimIndex` asc.\n   */\n\n\n  SourceManager.prototype.getSharedDataStore = function (seriesDimRequest) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(isSeries(this._sourceHost), 'Can only call getDataStore on series source manager.');\n    }\n\n    var schema = seriesDimRequest.makeStoreSchema();\n    return this._innerGetDataStore(schema.dimensions, seriesDimRequest.source, schema.hash);\n  };\n\n  SourceManager.prototype._innerGetDataStore = function (storeDims, seriesSource, sourceReadKey) {\n    // TODO Can use other sourceIndex?\n    var sourceIndex = 0;\n    var storeList = this._storeList;\n    var cachedStoreMap = storeList[sourceIndex];\n\n    if (!cachedStoreMap) {\n      cachedStoreMap = storeList[sourceIndex] = {};\n    }\n\n    var cachedStore = cachedStoreMap[sourceReadKey];\n\n    if (!cachedStore) {\n      var upSourceMgr = this._getUpstreamSourceManagers()[0];\n\n      if (isSeries(this._sourceHost) && upSourceMgr) {\n        cachedStore = upSourceMgr._innerGetDataStore(storeDims, seriesSource, sourceReadKey);\n      } else {\n        cachedStore = new DataStore(); // Always create store from source of series.\n\n        cachedStore.initData(new DefaultDataProvider(seriesSource, storeDims.length), storeDims);\n      }\n\n      cachedStoreMap[sourceReadKey] = cachedStore;\n    }\n\n    return cachedStore;\n  };\n  /**\n   * PEDING: Is it fast enough?\n   * If no upstream, return empty array.\n   */\n\n\n  SourceManager.prototype._getUpstreamSourceManagers = function () {\n    // Always get the relationship from the raw option.\n    // Do not cache the link of the dependency graph, so that\n    // no need to update them when change happen.\n    var sourceHost = this._sourceHost;\n\n    if (isSeries(sourceHost)) {\n      var datasetModel = querySeriesUpstreamDatasetModel(sourceHost);\n      return !datasetModel ? [] : [datasetModel.getSourceManager()];\n    } else {\n      return map(queryDatasetUpstreamDatasetModels(sourceHost), function (datasetModel) {\n        return datasetModel.getSourceManager();\n      });\n    }\n  };\n\n  SourceManager.prototype._getSourceMetaRawOption = function () {\n    var sourceHost = this._sourceHost;\n    var seriesLayoutBy;\n    var sourceHeader;\n    var dimensions;\n\n    if (isSeries(sourceHost)) {\n      seriesLayoutBy = sourceHost.get('seriesLayoutBy', true);\n      sourceHeader = sourceHost.get('sourceHeader', true);\n      dimensions = sourceHost.get('dimensions', true);\n    } // See [REQUIREMENT_MEMO], `non-root-dataset` do not support them.\n    else if (!this._getUpstreamSourceManagers().length) {\n        var model = sourceHost;\n        seriesLayoutBy = model.get('seriesLayoutBy', true);\n        sourceHeader = model.get('sourceHeader', true);\n        dimensions = model.get('dimensions', true);\n      }\n\n    return {\n      seriesLayoutBy: seriesLayoutBy,\n      sourceHeader: sourceHeader,\n      dimensions: dimensions\n    };\n  };\n\n  return SourceManager;\n}();\n\nexport { SourceManager }; // Call this method after `super.init` and `super.mergeOption` to\n// disable the transform merge, but do not disable transfrom clone from rawOption.\n\nexport function disableTransformOptionMerge(datasetModel) {\n  var transformOption = datasetModel.option.transform;\n  transformOption && setAsPrimitive(datasetModel.option.transform);\n}\n\nfunction isSeries(sourceHost) {\n  // Avoid circular dependency with Series.ts\n  return sourceHost.mainType === 'series';\n}\n\nfunction doThrow(errMsg) {\n  throw new Error(errMsg);\n}"],"names":["BE_ORDINAL","Must","Might","Not","innerGlobalModel","makeInner","resetSourceDefaulter","ecModel","datasetMap","createHashMap","makeSeriesEncodeForAxisCoordSys","coordDimensions","seriesModel","source","encode","datasetModel","querySeriesUpstreamDatasetModel","baseCategoryDimIndex","categoryWayValueDimStart","encodeItemName","encodeSeriesName","key","uid","seriesLayoutBy","slice","each","coordDimInfoLoose","coordDimIdx","coordDimInfo","isObject","name","type","getDataDimCountOnCoordDim","datasetRecord","get","set","categoryWayDim","valueWayDim","pushDim","dimIdxArr","idxFrom","idxCount","i","push","dimsDef","length","coordDimName","count","start","itemName","seriesName","makeSeriesEncodeForNameBased","dimCount","potentialNameDimIndex","sourceFormat","dimensionsDefine","SOURCE_FORMAT_OBJECT_ROWS","SOURCE_FORMAT_KEYED_COLUMNS","dim","idx","idxResult","idxRes0","idxRes1","guessRecords","len","Math","min","guessResult","doGuessOrdinal","data","startIndex","isPureNumber","v","n","fulfilled","value","nameDimIndex","queryReferringComponents","index","id","SINGLE_REFERRING","models","queryDatasetUpstreamDatasetModels","guessOrdinal","dimIndex","result","dimName","dimType","isTypedArray","dimDefItem","isString","SOURCE_FORMAT_ARRAY_ROWS","dataArrayRows","SERIES_LAYOUT_BY_ROW","sample","detectValue","row","dataObjectRows","item","dataKeyedColumns","SOURCE_FORMAT_ORIGINAL","dataOriginal","val","getDataItemValue","isArray","beStr","isFinite","SourceManager","sourceHost","this","_sourceList","_storeList","_upstreamSignList","_versionSignBase","_dirty","_sourceHost","prototype","dirty","_setLocalSource","sourceList","upstreamSignList","_getVersionSign","prepareSource","_isDirty","_createSource","resultSourceList","upSourceMgrList","_getUpstreamSourceManagers","hasUpstream","isSeries","upSource","upSourceMgr","getSource","SOURCE_FORMAT_TYPED_ARRAY","newMetaRawOption","_getSourceMetaRawOption","upMetaRawOption","metaRawOption","retrieve2","sourceHeader","dimensions","createSource","_applyTransform","sourceData","upMgrList","transformOption","fromTransformResult","doThrow","upSourceList","upMgr","applyDataTransform","datasetIndex","componentIndex","cloneSourceShallow","upSrcMgr","sourceIndex","getSharedDataStore","seriesDimRequest","schema","makeStoreSchema","_innerGetDataStore","hash","storeDims","seriesSource","sourceReadKey","storeList","cachedStoreMap","cachedStore","DataStore","initData","DefaultDataProvider","getSourceManager","map","model","disableTransformOptionMerge","option","transform","setAsPrimitive","mainType","errMsg","Error"],"sourceRoot":""}
{"version":3,"file":"static/js/81.1bd090f2.js","mappings":"iNAkDIA,EAAqB,CACvB,QAAW,CACTC,YAAa,IACbC,iBAAiB,GAEnB,OAAU,CACRD,YAAa,EACbC,iBAAiB,IAGVC,EAAkB,CAAC,MAAO,OAEjCC,EAEJ,SAAUC,GAGR,SAASD,EAAIE,EAAMC,EAAKC,GACtB,IAAIC,EAAQJ,EAAOK,KAAKC,KAAML,IAASK,KAEvCF,EAAMG,WAAaT,EACnBM,EAAMI,KAAO,MAEbJ,EAAMK,cAAgBC,EAAAA,KACtBN,EAAMF,IAAMA,EACZ,IA6BIS,EA7BAC,EAAaT,EAAIS,WACjBC,EAASC,EAAAA,EAAAA,KAAsBZ,EAAKC,EAAIY,QAASZ,EAAIa,cACrDC,EAAWH,EAAAA,EAAAA,eAAgCZ,GAE3CgB,GADed,EAAMe,aAAeF,EAAWA,EAAST,KAAO,KACrDJ,EAAMc,QAAUL,EAAOK,SACjCE,EAAgBzB,EAAmBsB,EAAST,MA0BhD,GAzBAJ,EAAMiB,YAAcR,EAAOS,WAC3BlB,EAAMc,QAAUL,EAAOK,QAqBvBd,EAAMQ,WAAaA,EAGfA,EAEF,IAAK,IAAIW,EAAI,EAAGA,EAAIL,EAAQM,OAAQD,IAAK,CACvC,IAAIE,EAAaP,EAAQK,GAAGG,gBAAgBd,IAC5CD,EAAeA,GAAgBc,EAAWE,SAC7BC,MAAMH,EACrB,MAEAd,EAAeE,EAAOF,aAWxB,OARAP,EAAMyB,gBAAgBlB,EAAamB,EAAGnB,EAAaoB,EAAGpB,EAAaqB,MAAOrB,EAAasB,QAKvF7B,EAAMR,YAAcgB,EAAa,EAAIF,EAAAA,GAAiBP,EAAIP,YAAawB,EAAcxB,aAErFQ,EAAM8B,kBAAmBtB,GAAqBQ,EAAcvB,gBACrDO,CACT,CAgHA,OA7KA+B,EAAAA,EAAAA,IAAUpC,EAAKC,GA+DfD,EAAIqC,UAAUC,aAAe,SAAUP,EAAGC,EAAGC,EAAOC,GAClD,IAAIK,EAAOhC,KAAKoB,kBACZ7B,EAAkBS,KAAK4B,iBAC3BI,EAAOA,EAAKX,QAER9B,IAEFyC,EAAKP,GAAKO,EAAKP,EAAIO,EAAKL,QAG1B,IAAIM,EAAmBjC,KAAKkC,kBAC5BD,EAAiBE,UAAYH,EAAKI,mBAAmB,IAAIC,EAAAA,EAAab,EAAGC,EAAGC,EAAOC,IACnF,IAAIW,EAAYL,EAAiBM,OACjCN,EAAiBM,OAAS,KAC1BN,EAAiBO,qBACjBP,EAAiBM,OAASD,EAEtB/C,IACF0C,EAAiBQ,QAAUR,EAAiBQ,QAG9CzC,KAAK0C,kBACP,EAEAjD,EAAIqC,UAAUa,UAAY,SAAUhD,GAClC,OAAOK,KAAKe,YAAY6B,IAAIjD,EAC9B,EAEAF,EAAIqC,UAAUe,iBAAmB,SAAUC,GAGzC,IAFA,IAAIlC,EAAUZ,KAAKY,QAEVK,EAAI,EAAGA,EAAIL,EAAQM,OAAQD,IAAK,CACvC,IAAI8B,EAASnC,EAAQK,GAErB,GAAoB,YAAhB8B,EAAO7C,MAAsB6C,EAAOC,QAAQF,GAC9C,OAAOlC,EAAQK,EAEnB,CACF,EAMAxB,EAAIqC,UAAUmB,YAAc,SAAUtD,EAAMuD,GAC1ClD,KAAKG,cAAcgD,IAAIxD,EAAMuD,EAC/B,EAMAzD,EAAIqC,UAAUsB,YAAc,SAAUzD,GACpC,IAAIoD,EAAS/C,KAAKe,YAAY6B,IAAIjD,GAGlC,OAAOK,KAAKG,cAAcyC,IAAIjD,IAASoD,GAAUA,EAAOM,WAC1D,EAEA5D,EAAIqC,UAAUwB,YAAc,SAAUC,EAAMC,EAAQC,GAMlD,GALIrD,EAAAA,GAAgBmD,KAElBA,EAAOvD,KAAKoD,YAAYG,IAGtBA,EAAM,CACR,IAAIjD,EAAaN,KAAKM,WAOtB,OALIA,IAEFiD,EAAOjD,EAAWoD,QAAQH,IAGrBA,GAAQvD,KAAK2D,iBAAiBJ,EAAMC,EAAQC,EACrD,CACF,EAEAhE,EAAIqC,UAAU8B,YAAc,SAAUC,GACpC,IAAIvD,EAAaN,KAAKM,WAOtB,OALIA,IAEFuD,EAAQvD,EAAWwD,UAAUD,IAGxBA,GAAS7D,KAAK+D,iBAAiBF,EACxC,EAMApE,EAAIqC,UAAUiC,iBAAmB,SAAUF,GACzC,OAAOnE,EAAOoC,UAAU8B,YAAY7D,KAAKC,KAAM6D,EACjD,EAEApE,EAAIqC,UAAU6B,iBAAmB,SAAUK,EAAWR,EAAQC,GAC5D,OAAO/D,EAAOoC,UAAUwB,YAAYvD,KAAKC,KAAMgE,EAAWR,EAAQC,EACpE,EAEAhE,EAAIqC,UAAUmC,eAAiB,SAAUC,EAASC,EAAQC,GACxD,IAAIC,EAAWC,EAAYH,GAC3B,OAAOE,IAAarE,KAAOqE,EAASf,YAAYc,GAAS,IAC3D,EAEA3E,EAAIqC,UAAUyC,iBAAmB,SAAUL,EAASC,EAAQK,GAC1D,IAAIH,EAAWC,EAAYH,GAC3B,OAAOE,IAAarE,KAAOqE,EAAST,YAAYY,GAAS,IAC3D,EAEO/E,CACT,CA/KA,CA+KEgF,EAAAA,GAKF,SAASH,EAAYH,GACnB,IAAIO,EAAWP,EAAOO,SAClBC,EAAcR,EAAOQ,YACzB,OAAOD,EAAWA,EAASE,iBAAmBD,EAAcA,EAAYC,mBACpED,EAAYE,uBAAuB,MAAOC,EAAAA,IAAkBC,OAAO,IAAM,CAAC,GAAGH,iBAAmB,IACtG,CAPAxE,EAAAA,GAAaX,EAAKgF,EAAAA,GASlB,K,sMC1MIO,EAAgB,GAEpB,SAASC,EAAgBC,EAAQ/C,GAC/B,IAAK,IAAIgD,EAAI,EAAGA,EAAID,EAAOhE,OAAQiE,IACjCC,EAAAA,GAAoBF,EAAOC,GAAID,EAAOC,GAAIhD,EAE9C,CAEA,SAASkD,EAAqBH,EAAQI,EAAKC,EAAKjF,GAC9C,IAAK,IAAIW,EAAI,EAAGA,EAAIiE,EAAOhE,OAAQD,IAAK,CACtC,IAAIkE,EAAID,EAAOjE,GAEXX,IAEF6E,EAAI7E,EAAWoD,QAAQyB,IAGrBA,GAAKK,SAASL,EAAE,KAAOK,SAASL,EAAE,MACpCC,EAAAA,GAASE,EAAKA,EAAKH,GACnBC,EAAAA,GAASG,EAAKA,EAAKJ,GAEvB,CACF,CAwBA,IAAIM,EAEJ,WACE,SAASA,EAAO9F,GACdK,KAAKL,KAAOA,CACd,CAwBA,OAtBA8F,EAAO3D,UAAU4D,UAAY,SAAUC,GACrC3F,KAAK4F,QAAUD,CACjB,EAQAF,EAAO3D,UAAUuB,UAAY,WAC3B,IAAIsC,EAAS3F,KAAK4F,QAQlB,OANKD,IAGHA,EAAS3F,KAAK4F,QAAU5F,KAAK6F,cAGxBF,CACT,EAEOF,CACT,CA5BA,GAgCIK,EAGF,SAAgCC,EAAUC,GACxChG,KAAKE,KAAO,UACZF,KAAK+F,SAAWA,EAChB/F,KAAKgG,UAAYA,CACnB,EAOEC,EAGF,SAAmCf,GACjClF,KAAKE,KAAO,aACZF,KAAKkF,OAASA,CAChB,EAOEgB,EAEJ,SAAUxG,GAGR,SAASwG,EAAcvG,EAAMwG,EAAYC,GACvC,IAAItG,EAAQJ,EAAOK,KAAKC,KAAML,IAASK,KAKvC,OAHAF,EAAMI,KAAO,UACbJ,EAAMqG,WAAaA,EACnBrG,EAAM8F,QAAUQ,GAAM,CAACA,EAAG,GAAIA,EAAG,IAC1BtG,CACT,CAoJA,OA7JA+B,EAAAA,EAAAA,IAAUqE,EAAexG,GAWzBwG,EAAcpE,UAAU+D,WAAa,WAKnC,IAJA,IACIQ,EADAF,EAAanG,KAAKmG,WAElBG,EAAiB,EAEZrF,EAAI,EAAGA,EAAIkF,EAAWjF,OAAQD,IAAK,CAC1C,IAAIsF,EAAMJ,EAAWlF,GACjB8E,EAAWQ,EAAIR,SAGfS,EAAOT,GAAYA,EAAS7E,OAE5BsF,EAAOF,IACTD,EAAaE,EACbD,EAAiBE,EAErB,CAEA,GAAIH,EACF,OApHN,SAAkBnB,GAQhB,IAPA,IAAIuB,EAAa,EACbC,EAAK,EACLC,EAAK,EACLC,EAAM1B,EAAOhE,OACb2F,EAAK3B,EAAO0B,EAAM,GAAG,GACrBE,EAAK5B,EAAO0B,EAAM,GAAG,GAEhB3F,EAAI,EAAGA,EAAI2F,EAAK3F,IAAK,CAC5B,IAAI8F,EAAK7B,EAAOjE,GAAG,GACf+F,EAAK9B,EAAOjE,GAAG,GACfgG,EAAIJ,EAAKG,EAAKD,EAAKD,EACvBL,GAAcQ,EACdP,IAAOG,EAAKE,GAAME,EAClBN,IAAOG,EAAKE,GAAMC,EAClBJ,EAAKE,EACLD,EAAKE,CACP,CAEA,OAAOP,EAAa,CAACC,EAAKD,EAAa,EAAGE,EAAKF,EAAa,EAAGA,GAAc,CAACvB,EAAO,GAAG,IAAM,EAAGA,EAAO,GAAG,IAAM,EACnH,CAgGagC,CAASb,EAAWN,UAI7B,IAAI/D,EAAOhC,KAAKoB,kBAChB,MAAO,CAACY,EAAKR,EAAIQ,EAAKN,MAAQ,EAAGM,EAAKP,EAAIO,EAAKL,OAAS,EAC1D,EAEAuE,EAAcpE,UAAUV,gBAAkB,SAAUd,GAClD,IAAI0B,EAAOhC,KAAKmH,MAEhB,GAAInF,IAAS1B,EACX,OAAO0B,EAGT,IAAIsD,EAAM,CAAC8B,IAAUA,KACjB7B,EAAM,EAAC,KAAW,KAClBY,EAAanG,KAAKmG,WAsBtB,OArBAkB,EAAAA,EAAAA,IAAKlB,GAAY,SAAUI,GACR,YAAbA,EAAIrG,KAENmF,EAAqBkB,EAAIR,SAAUT,EAAKC,EAAKjF,IAE7C+G,EAAAA,EAAAA,IAAKd,EAAIrB,QAAQ,SAAUA,GACzBG,EAAqBH,EAAQI,EAAKC,EAAKjF,EACzC,GAEJ,IAEMkF,SAASF,EAAI,KAAOE,SAASF,EAAI,KAAOE,SAASD,EAAI,KAAOC,SAASD,EAAI,MAC7ED,EAAI,GAAKA,EAAI,GAAKC,EAAI,GAAKA,EAAI,GAAK,GAGtCvD,EAAO,IAAIK,EAAAA,EAAaiD,EAAI,GAAIA,EAAI,GAAIC,EAAI,GAAKD,EAAI,GAAIC,EAAI,GAAKD,EAAI,IAEjEhF,IACHN,KAAKmH,MAAQnF,GAGRA,CACT,EAEAkE,EAAcpE,UAAUkB,QAAU,SAAUF,GAC1C,IAAId,EAAOhC,KAAKoB,kBACZ+E,EAAanG,KAAKmG,WAEtB,IAAKnE,EAAKgB,QAAQF,EAAM,GAAIA,EAAM,IAChC,OAAO,EAGTwE,EAAS,IAAK,IAAIrG,EAAI,EAAG2F,EAAMT,EAAWjF,OAAQD,EAAI2F,EAAK3F,IAAK,CAC9D,IAAIsF,EAAMJ,EAAWlF,GAErB,GAAiB,YAAbsF,EAAIrG,KAAR,CAIA,IAAI6F,EAAWQ,EAAIR,SACfC,EAAYO,EAAIP,UAEpB,GAAIuB,EAAAA,EAAuBxB,EAAUjD,EAAM,GAAIA,EAAM,IAAK,CAExD,IAAK,IAAI0E,EAAI,EAAGA,GAAKxB,EAAYA,EAAU9E,OAAS,GAAIsG,IACtD,GAAID,EAAAA,EAAuBvB,EAAUwB,GAAI1E,EAAM,GAAIA,EAAM,IACvD,SAASwE,EAIb,OAAO,CACT,CAdA,CAeF,CAEA,OAAO,CACT,EAUApB,EAAcpE,UAAU2F,YAAc,SAAUjG,EAAGC,EAAGC,EAAOC,GAC3D,IAAIK,EAAOhC,KAAKoB,kBACZsG,EAAS1F,EAAKN,MAAQM,EAAKL,OAE1BD,EAEOC,IACVA,EAASD,EAAQgG,GAFjBhG,EAAQgG,EAAS/F,EASnB,IAJA,IAAIgG,EAAS,IAAItF,EAAAA,EAAab,EAAGC,EAAGC,EAAOC,GACvCQ,EAAYH,EAAKI,mBAAmBuF,GACpCxB,EAAanG,KAAKmG,WAEblF,EAAI,EAAGA,EAAIkF,EAAWjF,OAAQD,IAAK,CAC1C,IAAIsF,EAAMJ,EAAWlF,GAEJ,YAAbsF,EAAIrG,MACN+E,EAAgBsB,EAAIR,SAAU5D,IAC9BkF,EAAAA,EAAAA,IAAKd,EAAIP,WAAW,SAAU4B,GAC5B3C,EAAgB2C,EAAUzF,EAC5B,MAEAkF,EAAAA,EAAAA,IAAKd,EAAIrB,QAAQ,SAAUA,GACzBD,EAAgBC,EAAQ/C,EAC1B,GAEJ,EAEAH,EAAOhC,KAAKmH,OACPU,KAAKF,GAEV3H,KAAK4F,QAAU,CAAC5D,EAAKR,EAAIQ,EAAKN,MAAQ,EAAGM,EAAKP,EAAIO,EAAKL,OAAS,EAClE,EAEAuE,EAAcpE,UAAUgG,aAAe,SAAUnI,GACvC,MAARA,IAAiBA,EAAOK,KAAKL,MAC7B,IAAIoI,EAAY,IAAI7B,EAAcvG,EAAMK,KAAKmG,WAAYnG,KAAK4F,SAI9D,OAHAmC,EAAUZ,MAAQnH,KAAKmH,MACvBY,EAAUN,YAAc,KAEjBM,CACT,EAEO7B,CACT,CA/JA,CA+JET,GAIEuC,EAEJ,SAAUtI,GAGR,SAASsI,EAAarI,EAAMsI,GAC1B,IAAInI,EAAQJ,EAAOK,KAAKC,KAAML,IAASK,KAIvC,OAFAF,EAAMI,KAAO,SACbJ,EAAMoI,oBAAsBD,EACrBnI,CACT,CAmBA,OA3BA+B,EAAAA,EAAAA,IAAUmG,EAActI,GAUxBsI,EAAalG,UAAU+D,WAAa,WAOlC,IANA,IAAIsC,EAAKnI,KAAKkI,oBACVlG,EAAOmG,EAAG/G,kBACVuE,EAAS,CAAC3D,EAAKR,EAAIQ,EAAKN,MAAQ,EAAGM,EAAKP,EAAIO,EAAKL,OAAS,GAC1DyG,EAAMC,EAAAA,GAAgBrD,GACtB2C,EAASQ,EAENR,IAAWA,EAAOW,qBACvBD,EAAAA,GAAWD,EAAKT,EAAOY,oBAAqBH,GAC5CT,EAASA,EAAOpF,OAKlB,OAFA8F,EAAAA,GAAcD,EAAKA,GACnBhD,EAAAA,GAAoBO,EAAQA,EAAQyC,GAC7BzC,CACT,EAEOqC,CACT,CA7BA,CA6BEvC,E","sources":["../node_modules/echarts/lib/coord/geo/Geo.js","../node_modules/echarts/lib/coord/geo/Region.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\";\nimport * as zrUtil from 'zrender/lib/core/util.js';\nimport BoundingRect from 'zrender/lib/core/BoundingRect.js';\nimport View from '../View.js';\nimport geoSourceManager from './geoSourceManager.js';\nimport { SINGLE_REFERRING } from '../../util/model.js';\nimport { warn } from '../../util/log.js';\nvar GEO_DEFAULT_PARAMS = {\n  'geoJSON': {\n    aspectScale: 0.75,\n    invertLongitute: true\n  },\n  'geoSVG': {\n    aspectScale: 1,\n    invertLongitute: false\n  }\n};\nexport var geo2DDimensions = ['lng', 'lat'];\n\nvar Geo =\n/** @class */\nfunction (_super) {\n  __extends(Geo, _super);\n\n  function Geo(name, map, opt) {\n    var _this = _super.call(this, name) || this;\n\n    _this.dimensions = geo2DDimensions;\n    _this.type = 'geo'; // Only store specified name coord via `addGeoCoord`.\n\n    _this._nameCoordMap = zrUtil.createHashMap();\n    _this.map = map;\n    var projection = opt.projection;\n    var source = geoSourceManager.load(map, opt.nameMap, opt.nameProperty);\n    var resource = geoSourceManager.getGeoResource(map);\n    var resourceType = _this.resourceType = resource ? resource.type : null;\n    var regions = _this.regions = source.regions;\n    var defaultParams = GEO_DEFAULT_PARAMS[resource.type];\n    _this._regionsMap = source.regionsMap;\n    _this.regions = source.regions;\n\n    if (process.env.NODE_ENV !== 'production' && projection) {\n      // Do some check\n      if (resourceType === 'geoSVG') {\n        if (process.env.NODE_ENV !== 'production') {\n          warn(\"Map \" + map + \" with SVG source can't use projection. Only GeoJSON source supports projection.\");\n        }\n\n        projection = null;\n      }\n\n      if (!(projection.project && projection.unproject)) {\n        if (process.env.NODE_ENV !== 'production') {\n          warn('project and unproject must be both provided in the projeciton.');\n        }\n\n        projection = null;\n      }\n    }\n\n    _this.projection = projection;\n    var boundingRect;\n\n    if (projection) {\n      // Can't reuse the raw bounding rect\n      for (var i = 0; i < regions.length; i++) {\n        var regionRect = regions[i].getBoundingRect(projection);\n        boundingRect = boundingRect || regionRect.clone();\n        boundingRect.union(regionRect);\n      }\n    } else {\n      boundingRect = source.boundingRect;\n    }\n\n    _this.setBoundingRect(boundingRect.x, boundingRect.y, boundingRect.width, boundingRect.height); // aspectScale and invertLongitute actually is the parameters default raw projection.\n    // So we ignore them if projection is given.\n    // Ignore default aspect scale if projection exits.\n\n\n    _this.aspectScale = projection ? 1 : zrUtil.retrieve2(opt.aspectScale, defaultParams.aspectScale); // Not invert longitute if projection exits.\n\n    _this._invertLongitute = projection ? false : defaultParams.invertLongitute;\n    return _this;\n  }\n\n  Geo.prototype._transformTo = function (x, y, width, height) {\n    var rect = this.getBoundingRect();\n    var invertLongitute = this._invertLongitute;\n    rect = rect.clone();\n\n    if (invertLongitute) {\n      // Longitute is inverted\n      rect.y = -rect.y - rect.height;\n    }\n\n    var rawTransformable = this._rawTransformable;\n    rawTransformable.transform = rect.calculateTransform(new BoundingRect(x, y, width, height));\n    var rawParent = rawTransformable.parent;\n    rawTransformable.parent = null;\n    rawTransformable.decomposeTransform();\n    rawTransformable.parent = rawParent;\n\n    if (invertLongitute) {\n      rawTransformable.scaleY = -rawTransformable.scaleY;\n    }\n\n    this._updateTransform();\n  };\n\n  Geo.prototype.getRegion = function (name) {\n    return this._regionsMap.get(name);\n  };\n\n  Geo.prototype.getRegionByCoord = function (coord) {\n    var regions = this.regions;\n\n    for (var i = 0; i < regions.length; i++) {\n      var region = regions[i];\n\n      if (region.type === 'geoJSON' && region.contain(coord)) {\n        return regions[i];\n      }\n    }\n  };\n  /**\n   * Add geoCoord for indexing by name\n   */\n\n\n  Geo.prototype.addGeoCoord = function (name, geoCoord) {\n    this._nameCoordMap.set(name, geoCoord);\n  };\n  /**\n   * Get geoCoord by name\n   */\n\n\n  Geo.prototype.getGeoCoord = function (name) {\n    var region = this._regionsMap.get(name); // calcualte center only on demand.\n\n\n    return this._nameCoordMap.get(name) || region && region.getCenter();\n  };\n\n  Geo.prototype.dataToPoint = function (data, noRoam, out) {\n    if (zrUtil.isString(data)) {\n      // Map area name to geoCoord\n      data = this.getGeoCoord(data);\n    }\n\n    if (data) {\n      var projection = this.projection;\n\n      if (projection) {\n        // projection may return null point.\n        data = projection.project(data);\n      }\n\n      return data && this.projectedToPoint(data, noRoam, out);\n    }\n  };\n\n  Geo.prototype.pointToData = function (point) {\n    var projection = this.projection;\n\n    if (projection) {\n      // projection may return null point.\n      point = projection.unproject(point);\n    }\n\n    return point && this.pointToProjected(point);\n  };\n  /**\n   * Point to projected data. Same with pointToData when projection is used.\n   */\n\n\n  Geo.prototype.pointToProjected = function (point) {\n    return _super.prototype.pointToData.call(this, point);\n  };\n\n  Geo.prototype.projectedToPoint = function (projected, noRoam, out) {\n    return _super.prototype.dataToPoint.call(this, projected, noRoam, out);\n  };\n\n  Geo.prototype.convertToPixel = function (ecModel, finder, value) {\n    var coordSys = getCoordSys(finder);\n    return coordSys === this ? coordSys.dataToPoint(value) : null;\n  };\n\n  Geo.prototype.convertFromPixel = function (ecModel, finder, pixel) {\n    var coordSys = getCoordSys(finder);\n    return coordSys === this ? coordSys.pointToData(pixel) : null;\n  };\n\n  return Geo;\n}(View);\n\n;\nzrUtil.mixin(Geo, View);\n\nfunction getCoordSys(finder) {\n  var geoModel = finder.geoModel;\n  var seriesModel = finder.seriesModel;\n  return geoModel ? geoModel.coordinateSystem : seriesModel ? seriesModel.coordinateSystem // For map series.\n  || (seriesModel.getReferringComponents('geo', SINGLE_REFERRING).models[0] || {}).coordinateSystem : null;\n}\n\nexport default Geo;","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\";\nimport BoundingRect from 'zrender/lib/core/BoundingRect.js';\nimport * as vec2 from 'zrender/lib/core/vector.js';\nimport * as polygonContain from 'zrender/lib/contain/polygon.js';\nimport * as matrix from 'zrender/lib/core/matrix.js';\nimport { each } from 'zrender/lib/core/util.js';\nvar TMP_TRANSFORM = [];\n\nfunction transformPoints(points, transform) {\n  for (var p = 0; p < points.length; p++) {\n    vec2.applyTransform(points[p], points[p], transform);\n  }\n}\n\nfunction updateBBoxFromPoints(points, min, max, projection) {\n  for (var i = 0; i < points.length; i++) {\n    var p = points[i];\n\n    if (projection) {\n      // projection may return null point.\n      p = projection.project(p);\n    }\n\n    if (p && isFinite(p[0]) && isFinite(p[1])) {\n      vec2.min(min, min, p);\n      vec2.max(max, max, p);\n    }\n  }\n}\n\nfunction centroid(points) {\n  var signedArea = 0;\n  var cx = 0;\n  var cy = 0;\n  var len = points.length;\n  var x0 = points[len - 1][0];\n  var y0 = points[len - 1][1]; // Polygon should been closed.\n\n  for (var i = 0; i < len; i++) {\n    var x1 = points[i][0];\n    var y1 = points[i][1];\n    var a = x0 * y1 - x1 * y0;\n    signedArea += a;\n    cx += (x0 + x1) * a;\n    cy += (y0 + y1) * a;\n    x0 = x1;\n    y0 = y1;\n  }\n\n  return signedArea ? [cx / signedArea / 3, cy / signedArea / 3, signedArea] : [points[0][0] || 0, points[0][1] || 0];\n}\n\nvar Region =\n/** @class */\nfunction () {\n  function Region(name) {\n    this.name = name;\n  }\n\n  Region.prototype.setCenter = function (center) {\n    this._center = center;\n  };\n  /**\n   * Get center point in data unit. That is,\n   * for GeoJSONRegion, the unit is lat/lng,\n   * for GeoSVGRegion, the unit is SVG local coord.\n   */\n\n\n  Region.prototype.getCenter = function () {\n    var center = this._center;\n\n    if (!center) {\n      // In most cases there are no need to calculate this center.\n      // So calculate only when called.\n      center = this._center = this.calcCenter();\n    }\n\n    return center;\n  };\n\n  return Region;\n}();\n\nexport { Region };\n\nvar GeoJSONPolygonGeometry =\n/** @class */\nfunction () {\n  function GeoJSONPolygonGeometry(exterior, interiors) {\n    this.type = 'polygon';\n    this.exterior = exterior;\n    this.interiors = interiors;\n  }\n\n  return GeoJSONPolygonGeometry;\n}();\n\nexport { GeoJSONPolygonGeometry };\n\nvar GeoJSONLineStringGeometry =\n/** @class */\nfunction () {\n  function GeoJSONLineStringGeometry(points) {\n    this.type = 'linestring';\n    this.points = points;\n  }\n\n  return GeoJSONLineStringGeometry;\n}();\n\nexport { GeoJSONLineStringGeometry };\n\nvar GeoJSONRegion =\n/** @class */\nfunction (_super) {\n  __extends(GeoJSONRegion, _super);\n\n  function GeoJSONRegion(name, geometries, cp) {\n    var _this = _super.call(this, name) || this;\n\n    _this.type = 'geoJSON';\n    _this.geometries = geometries;\n    _this._center = cp && [cp[0], cp[1]];\n    return _this;\n  }\n\n  GeoJSONRegion.prototype.calcCenter = function () {\n    var geometries = this.geometries;\n    var largestGeo;\n    var largestGeoSize = 0;\n\n    for (var i = 0; i < geometries.length; i++) {\n      var geo = geometries[i];\n      var exterior = geo.exterior; // Simple trick to use points count instead of polygon area as region size.\n      // Ignore linestring\n\n      var size = exterior && exterior.length;\n\n      if (size > largestGeoSize) {\n        largestGeo = geo;\n        largestGeoSize = size;\n      }\n    }\n\n    if (largestGeo) {\n      return centroid(largestGeo.exterior);\n    } // from bounding rect by default.\n\n\n    var rect = this.getBoundingRect();\n    return [rect.x + rect.width / 2, rect.y + rect.height / 2];\n  };\n\n  GeoJSONRegion.prototype.getBoundingRect = function (projection) {\n    var rect = this._rect; // Always recalculate if using projection.\n\n    if (rect && !projection) {\n      return rect;\n    }\n\n    var min = [Infinity, Infinity];\n    var max = [-Infinity, -Infinity];\n    var geometries = this.geometries;\n    each(geometries, function (geo) {\n      if (geo.type === 'polygon') {\n        // Doesn't consider hole\n        updateBBoxFromPoints(geo.exterior, min, max, projection);\n      } else {\n        each(geo.points, function (points) {\n          updateBBoxFromPoints(points, min, max, projection);\n        });\n      }\n    }); // Normalie invalid bounding.\n\n    if (!(isFinite(min[0]) && isFinite(min[1]) && isFinite(max[0]) && isFinite(max[1]))) {\n      min[0] = min[1] = max[0] = max[1] = 0;\n    }\n\n    rect = new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n\n    if (!projection) {\n      this._rect = rect;\n    }\n\n    return rect;\n  };\n\n  GeoJSONRegion.prototype.contain = function (coord) {\n    var rect = this.getBoundingRect();\n    var geometries = this.geometries;\n\n    if (!rect.contain(coord[0], coord[1])) {\n      return false;\n    }\n\n    loopGeo: for (var i = 0, len = geometries.length; i < len; i++) {\n      var geo = geometries[i]; // Only support polygon.\n\n      if (geo.type !== 'polygon') {\n        continue;\n      }\n\n      var exterior = geo.exterior;\n      var interiors = geo.interiors;\n\n      if (polygonContain.contain(exterior, coord[0], coord[1])) {\n        // Not in the region if point is in the hole.\n        for (var k = 0; k < (interiors ? interiors.length : 0); k++) {\n          if (polygonContain.contain(interiors[k], coord[0], coord[1])) {\n            continue loopGeo;\n          }\n        }\n\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\n   * Transform the raw coords to target bounding.\n   * @param x\n   * @param y\n   * @param width\n   * @param height\n   */\n\n\n  GeoJSONRegion.prototype.transformTo = function (x, y, width, height) {\n    var rect = this.getBoundingRect();\n    var aspect = rect.width / rect.height;\n\n    if (!width) {\n      width = aspect * height;\n    } else if (!height) {\n      height = width / aspect;\n    }\n\n    var target = new BoundingRect(x, y, width, height);\n    var transform = rect.calculateTransform(target);\n    var geometries = this.geometries;\n\n    for (var i = 0; i < geometries.length; i++) {\n      var geo = geometries[i];\n\n      if (geo.type === 'polygon') {\n        transformPoints(geo.exterior, transform);\n        each(geo.interiors, function (interior) {\n          transformPoints(interior, transform);\n        });\n      } else {\n        each(geo.points, function (points) {\n          transformPoints(points, transform);\n        });\n      }\n    }\n\n    rect = this._rect;\n    rect.copy(target); // Update center\n\n    this._center = [rect.x + rect.width / 2, rect.y + rect.height / 2];\n  };\n\n  GeoJSONRegion.prototype.cloneShallow = function (name) {\n    name == null && (name = this.name);\n    var newRegion = new GeoJSONRegion(name, this.geometries, this._center);\n    newRegion._rect = this._rect;\n    newRegion.transformTo = null; // Simply avoid to be called.\n\n    return newRegion;\n  };\n\n  return GeoJSONRegion;\n}(Region);\n\nexport { GeoJSONRegion };\n\nvar GeoSVGRegion =\n/** @class */\nfunction (_super) {\n  __extends(GeoSVGRegion, _super);\n\n  function GeoSVGRegion(name, elOnlyForCalculate) {\n    var _this = _super.call(this, name) || this;\n\n    _this.type = 'geoSVG';\n    _this._elOnlyForCalculate = elOnlyForCalculate;\n    return _this;\n  }\n\n  GeoSVGRegion.prototype.calcCenter = function () {\n    var el = this._elOnlyForCalculate;\n    var rect = el.getBoundingRect();\n    var center = [rect.x + rect.width / 2, rect.y + rect.height / 2];\n    var mat = matrix.identity(TMP_TRANSFORM);\n    var target = el;\n\n    while (target && !target.isGeoSVGGraphicRoot) {\n      matrix.mul(mat, target.getLocalTransform(), mat);\n      target = target.parent;\n    }\n\n    matrix.invert(mat, mat);\n    vec2.applyTransform(center, center, mat);\n    return center;\n  };\n\n  return GeoSVGRegion;\n}(Region);\n\nexport { GeoSVGRegion };"],"names":["GEO_DEFAULT_PARAMS","aspectScale","invertLongitute","geo2DDimensions","Geo","_super","name","map","opt","_this","call","this","dimensions","type","_nameCoordMap","zrUtil","boundingRect","projection","source","geoSourceManager","nameMap","nameProperty","resource","regions","resourceType","defaultParams","_regionsMap","regionsMap","i","length","regionRect","getBoundingRect","clone","union","setBoundingRect","x","y","width","height","_invertLongitute","__extends","prototype","_transformTo","rect","rawTransformable","_rawTransformable","transform","calculateTransform","BoundingRect","rawParent","parent","decomposeTransform","scaleY","_updateTransform","getRegion","get","getRegionByCoord","coord","region","contain","addGeoCoord","geoCoord","set","getGeoCoord","getCenter","dataToPoint","data","noRoam","out","project","projectedToPoint","pointToData","point","unproject","pointToProjected","projected","convertToPixel","ecModel","finder","value","coordSys","getCoordSys","convertFromPixel","pixel","View","geoModel","seriesModel","coordinateSystem","getReferringComponents","SINGLE_REFERRING","models","TMP_TRANSFORM","transformPoints","points","p","vec2","updateBBoxFromPoints","min","max","isFinite","Region","setCenter","center","_center","calcCenter","GeoJSONPolygonGeometry","exterior","interiors","GeoJSONLineStringGeometry","GeoJSONRegion","geometries","cp","largestGeo","largestGeoSize","geo","size","signedArea","cx","cy","len","x0","y0","x1","y1","a","centroid","_rect","Infinity","each","loopGeo","polygonContain","k","transformTo","aspect","target","interior","copy","cloneShallow","newRegion","GeoSVGRegion","elOnlyForCalculate","_elOnlyForCalculate","el","mat","matrix","isGeoSVGGraphicRoot","getLocalTransform"],"sourceRoot":""}
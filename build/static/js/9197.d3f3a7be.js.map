{"version":3,"file":"static/js/9197.d3f3a7be.js","mappings":"6LAgDIA,EAAUC,KAAKC,IACZ,SAASC,EAAgBC,EAAOC,EAAWC,GAChD,IAAIC,EAAqBC,EAAAA,EAAAA,UAKrBC,EAAeF,EAAmBG,SAASC,KAAKL,GAChDM,EAAoBL,EAAmBG,SAASC,KAAKL,GAAc,GACnEO,EAAqBJ,EAAaK,OAAS,EAC3CC,EAAkBR,EAAmBS,YAAYL,KAAKL,GACtDW,GAAcC,EAAAA,EAAAA,IAAed,EAAOC,GACpCc,EAAYF,EAAYG,OACxBC,EAAaJ,EAAYK,OACzBC,EAAaN,EAAYO,OAE7B,GAAmB,QAAfpB,EAAMqB,KAAgB,CACxB,IAAIC,EAAU1B,EAAQI,EAAMuB,MAC5BR,EAAY,CAACnB,EAAQmB,EAAU,IAAMO,EAAS1B,EAAQmB,EAAU,IAAMO,EACxE,CAEAtB,EAAMwB,UAAUT,EAAU,GAAIA,EAAU,IACxCf,EAAMyB,eAAe,CACnBC,YAAajB,EACbS,OAAQD,EACRG,OAAQD,IAEV,IAAIH,EAASb,EAAmBwB,UAAUpB,KAAKP,GAG3CiB,IACFF,EAAU,GAAKC,EAAO,IAGpBG,IACFJ,EAAU,GAAKC,EAAO,IAGxB,IAAIY,EAAWzB,EAAmBS,YAAYL,KAAKP,GAC/C6B,EAAMd,EAAU,GAChBe,EAAMf,EAAU,GAEpB,GAAIE,GAAcE,EAEhBS,GAAYE,EAAMD,GAAOpB,OACpB,GAAIQ,EAGT,IAFAa,EAAMf,EAAU,GAAKa,EAAWnB,EAEzBqB,EAAMf,EAAU,IAAMgB,SAASD,IAAQC,SAAShB,EAAU,KAC/Da,GAAWI,EAAAA,EAAAA,IAAiBJ,GAC5BE,EAAMf,EAAU,GAAKa,EAAWnB,OAE7B,GAAIU,EAIT,IAFAU,EAAMd,EAAU,GAAKa,EAAWnB,EAEzBoB,EAAMd,EAAU,IAAMgB,SAASF,IAAQE,SAAShB,EAAU,KAC/Da,GAAWI,EAAAA,EAAAA,IAAiBJ,GAC5BC,EAAMd,EAAU,GAAKa,EAAWnB,MAE7B,CACkBT,EAAMM,WAAWI,OAAS,EAE1BD,IACrBmB,GAAWI,EAAAA,EAAAA,IAAiBJ,IAG9B,IAAIK,EAAQL,EAAWnB,EACvBqB,EAAMjC,KAAKqC,KAAKnB,EAAU,GAAKa,GAAYA,GAC3CC,GAAMM,EAAAA,EAAAA,IAAML,EAAMG,IAER,GAAKlB,EAAU,IAAM,GAC7Bc,EAAM,EACNC,GAAMK,EAAAA,EAAAA,IAAMF,IACHH,EAAM,GAAKf,EAAU,IAAM,IACpCe,EAAM,EACND,IAAOM,EAAAA,EAAAA,IAAMF,GAEjB,CAGA,IAAIG,GAAM/B,EAAa,GAAGgC,MAAQ7B,EAAkB,GAAG6B,OAAS1B,EAC5D2B,GAAMjC,EAAaI,GAAoB4B,MAAQ7B,EAAkBC,GAAoB4B,OAAS1B,EAElGR,EAAmBqB,UAAUjB,KAAKP,EAAO6B,EAAMD,EAAWQ,EAAIN,EAAMF,EAAWU,GAC/EnC,EAAmBoC,YAAYhC,KAAKP,EAAO4B,IAEvCQ,GAAME,IACRnC,EAAmBqC,cAAcjC,KAAKP,EAAO6B,EAAMD,EAAUE,EAAMF,EAWvE,C,uDCxGO,IAAIa,EAAa,CACtBJ,MAAO,EACPK,SAAU,EACVC,KAAM,EACN7C,IAAK,E,uCCHH8C,EAAgB,CAClBC,MAAM,EAENC,EAAG,EAEHC,SAAS,EAETC,KAAM,GAENC,aAAc,MAEdC,WAAY,KACZC,aAAc,CACZC,SAAU,KACVC,SAAU,MACVC,YAAa,KAGfC,cAAe,CAAC,EAEhBC,QAAS,GAETC,QAAQ,EAERC,cAAc,EACdC,QAAS,CACPd,MAAM,GAERe,YAAa,CAAC,EACdC,SAAU,CACRhB,MAAM,EACNiB,QAAQ,EACRC,gBAAiB,KACjBC,UAAW,CACTC,MAAO,UACPC,MAAO,EACP7C,KAAM,SAGR8C,OAAQ,CAAC,OAAQ,QACjBC,WAAY,CAAC,GAAI,KAEnBC,SAAU,CACRxB,MAAM,EAENyB,QAAQ,EAER5D,OAAQ,EACRsD,UAAW,CACTE,MAAO,IAGXK,UAAW,CACT1B,MAAM,EAENyB,QAAQ,EACRE,OAAQ,EAERC,aAAc,KAEdC,aAAc,KACdC,OAAQ,EAERC,SAAU,IAEZC,UAAW,CACThC,MAAM,EACNmB,UAAW,CACTC,MAAO,CAAC,WACRC,MAAO,EACP7C,KAAM,UAGVyD,UAAW,CACTjC,MAAM,EACNkC,UAAW,CACTd,MAAO,CAAC,wBAAyB,4BAInCe,EAAeC,EAAAA,GAAa,CAE9BC,aAAa,EAEbC,cAAe,KAIfN,UAAW,CACThC,MAAM,GAERwB,SAAU,CAERe,gBAAgB,EAChBxD,SAAU,QAEZ2C,UAAW,CACT3C,SAAU,SAEXgB,GACCyC,EAAYJ,EAAAA,GAAa,CAC3BC,YAAa,CAAC,EAAG,GACjBrB,SAAU,CAERhB,KAAM,QAERwB,SAAU,CAERxB,KAAM,QAIRnB,YAAa,EACb4D,UAAW,CAETzC,MAAM,EAENnB,YAAa,EAEbhB,OAAQ,EAERsD,UAAW,CAAC,GAGduB,eAAgB,CACd1C,MAAM,EACNmB,UAAW,CACTC,MAAO,UACPC,MAAO,KAGVtB,GACC4C,EAAWP,EAAAA,GAAa,CAC1BvD,YAAa,EACb6C,UAAW,CAETE,cAAc,EACdC,cAAc,EACde,KAAM,CACJC,QAAS,CACPC,WAAY,UAIlBd,UAAW,CACThC,MAAM,IAEPwC,GACCO,EAAUX,EAAAA,GAAgB,CAC5B3D,QAAS,IACR+D,GACH,KACE3C,SAAUsC,EACV3C,MAAOgD,EACP1C,KAAM6C,EACN1F,IAAK8F,E,yZCxIA,SAAS9E,EAAed,EAAO6F,GACpC,IAAIC,EAAY9F,EAAMqB,KAClB0E,GAAkBC,EAAAA,EAAAA,IAAyBhG,EAAO6F,EAAO7F,EAAM2B,aAAasE,YAChFjG,EAAMkG,SAASH,EAAgBI,SAC/B,IAAItE,EAAMkE,EAAgBlE,IACtBC,EAAMiE,EAAgBjE,IAUtBsE,EAAUP,EAAMO,QAEpB,GAAIA,GAAyB,SAAdN,EAEb,CACA,IAAIO,GAAkBC,EAAAA,EAAAA,IAAuB,MAAOF,GAChDG,GAA8B,EAKlC,GAJAtB,EAAAA,GAAYoB,GAAiB,SAAUG,GACrCD,EAA8BA,GAA+BC,EAAYC,gBAAkBZ,EAAMa,IACnG,IAEIH,EAA6B,CAG/B,IAAII,GAAoBC,EAAAA,EAAAA,IAAiBP,GAErCQ,EAeV,SAAgChF,EAAKC,EAAK+D,EAC1Cc,GAEE,IAAIG,EAAajB,EAAMa,KAAK/E,YACxBoF,EAAaD,EAAW,GAAKA,EAAW,GAExCE,GAAoBC,EAAAA,EAAAA,IAAqBN,EAAmBd,EAAMa,MAEtE,QAA0BQ,IAAtBF,EACF,MAAO,CACLnF,IAAKA,EACLC,IAAKA,GAIT,IAAIqF,EAAcC,IAClBnC,EAAAA,GAAY+B,GAAmB,SAAUK,GACvCF,EAActH,KAAKgC,IAAIwF,EAAKC,OAAQH,EACtC,IACA,IAAII,GAAeH,IACnBnC,EAAAA,GAAY+B,GAAmB,SAAUK,GACvCE,EAAc1H,KAAKiC,IAAIuF,EAAKC,OAASD,EAAKnD,MAAOqD,EACnD,IACAJ,EAActH,KAAK2H,IAAIL,GACvBI,EAAc1H,KAAK2H,IAAID,GACvB,IAAIE,EAAgBN,EAAcI,EAE9BG,EAAW5F,EAAMD,EAEjB8F,EAAiBD,GADM,GAAKP,EAAcI,GAAeR,GACNW,EAGvD,MAAO,CACL7F,IAFFA,GAAO8F,GAAkBR,EAAcM,GAGrC3F,IAJFA,GAAO6F,GAAkBJ,EAAcE,GAMzC,CAnD0BG,CAAuB/F,EAAKC,EAAK+D,EAAOc,GAC5D9E,EAAMgF,EAAchF,IACpBC,EAAM+E,EAAc/E,GACtB,CACF,CAEA,MAAO,CACLd,OAAQ,CAACa,EAAKC,GAGdZ,OAAQ6E,EAAgB8B,SACxBzG,OAAQ2E,EAAgB+B,SAE5B,CA2CO,SAASC,EAAgB/H,EAAOgI,GACrC,IAAInC,EAAQmC,EACRC,EAAanH,EAAed,EAAO6F,GACnC7E,EAASiH,EAAWjH,OACpBU,EAAcmE,EAAMqC,IAAI,eAExBlI,aAAiBmI,EAAAA,IACnBnI,EAAMuB,KAAOsE,EAAMqC,IAAI,YAGzB,IAAIpC,EAAY9F,EAAMqB,KAClBO,EAAWiE,EAAMqC,IAAI,YACrBE,EAAiC,aAAdtC,GAA0C,SAAdA,EACnD9F,EAAMwB,UAAUR,EAAO,GAAIA,EAAO,IAClChB,EAAMyB,eAAe,CACnBC,YAAaA,EACbR,OAAQ+G,EAAW/G,OACnBE,OAAQ6G,EAAW7G,OACnBiH,YAAaD,EAAmBvC,EAAMqC,IAAI,eAAiB,KAC3DI,YAAaF,EAAmBvC,EAAMqC,IAAI,eAAiB,OAO7C,MAAZtG,GACF5B,EAAMuC,aAAevC,EAAMuC,YAAYX,EAE3C,CAKO,SAAS2G,EAAmB1C,EAAO2C,GAGxC,GAFAA,EAAWA,GAAY3C,EAAMqC,IAAI,QAG/B,OAAQM,GAEN,IAAK,WACH,OAAO,IAAIC,EAAAA,EAAa,CACtBC,YAAa7C,EAAM8C,eAAiB9C,EAAM8C,iBAAmB9C,EAAM+C,gBACnE5H,OAAQ,CAACoG,KAAWA,OAGxB,IAAK,OACH,OAAO,IAAIyB,EAAAA,EAAU,CACnBC,OAAQjD,EAAMO,QAAQ2C,iBACtBC,OAAQnD,EAAMO,QAAQ8B,IAAI,YAG9B,QAEE,OAAO,IAAKe,EAAAA,EAAAA,SAAeT,IAAapI,EAAAA,GAGhD,CAKO,SAAS8I,EAAgBxC,GAC9B,IAAIyC,EAAazC,EAAK1G,MAAM2B,YACxBE,EAAMsH,EAAW,GACjBrH,EAAMqH,EAAW,GACrB,QAAStH,EAAM,GAAKC,EAAM,GAAKD,EAAM,GAAKC,EAAM,EAClD,CAUO,SAASsH,EAAmB1C,GACjC,IAoBmB2C,EAhBAC,EAJfC,EAAiB7C,EAAK8C,gBAAgBtB,IAAI,aAC1CuB,EAAkC,aAAd/C,EAAKrF,KAAsBqF,EAAK1G,MAAM2B,YAAY,GAAK,KAE/E,MAAwB,SAApB+E,EAAK1G,MAAMqB,MACIiI,EAIfC,EAHO,SAAUG,EAAMC,GACrB,OAAOjD,EAAK1G,MAAM4J,kBAAkBF,EAAMC,EAAKL,EACjD,GAEOrE,EAAAA,GAAgBsE,GAClB,SAAUD,GACf,OAAO,SAAUI,GAGf,IAAIG,EAAQnD,EAAK1G,MAAM8J,SAASJ,GAEhC,OADWJ,EAAIS,QAAQ,UAAoB,MAATF,EAAgBA,EAAQ,GAE5D,CACF,CARO,CAQLN,GACOtE,EAAAA,GAAkBsE,IACVF,EAgBfE,EAfO,SAAUG,EAAMC,GAWrB,OAJyB,MAArBF,IACFE,EAAMD,EAAKrH,MAAQoH,GAGdJ,EAAGW,EAAgBtD,EAAMgD,GAAOC,EAAmB,MAAdD,EAAKO,MAAgB,CAC/DA,MAAOP,EAAKO,OACV,KACN,GAGK,SAAUP,GACf,OAAOhD,EAAK1G,MAAM8J,SAASJ,EAC7B,CAEJ,CACO,SAASM,EAAgBtD,EAAMgD,GAIpC,MAAqB,aAAdhD,EAAKrF,KAAsBqF,EAAK1G,MAAM8J,SAASJ,GAAQA,EAAKrH,KACrE,CAMO,SAAS6H,EAAuBxD,GACrC,IAAIzG,EAAYyG,EAAKb,MACjB7F,EAAQ0G,EAAK1G,MAEjB,GAAKC,EAAUiI,IAAI,CAAC,YAAa,WAAYlI,EAAMmG,UAAnD,CAIA,IAAIgE,EACAC,EACAC,EAAsBrK,EAAM2B,YAG9ByI,EADEpK,aAAiByI,EAAAA,EACPzI,EAAMsK,SAElBH,EAAuBnK,EAAMM,YACII,OAGnC,IAEI6J,EAFAC,EAAiB9D,EAAK8C,gBACtBD,EAAiBH,EAAmB1C,GAEpC+D,EAAO,EAEPL,EAAY,KACdK,EAAO5K,KAAKqC,KAAKkI,EAAY,KAG/B,IAAK,IAAIM,EAAI,EAAGA,EAAIN,EAAWM,GAAKD,EAAM,CACxC,IAGIZ,EAAQN,EAHDY,EAAuBA,EAAqBO,GAAK,CAC1DrI,MAAOgI,EAAoB,GAAKK,GAEDA,GAE7BC,EAAaC,EADSJ,EAAeK,YAAYhB,GACAW,EAAetC,IAAI,WAAa,GACrFqC,EAAOA,EAAKO,MAAMH,GAAcJ,EAAOI,CACzC,CAEA,OAAOJ,CAhCP,CAiCF,CAEA,SAASK,EAAeG,EAAUvG,GAChC,IAAIwG,EAAgBxG,EAAS3E,KAAKoL,GAAK,IACnCC,EAAcH,EAAS7G,MACvBiH,EAAeJ,EAASK,OACxBC,EAAaH,EAAcrL,KAAK2H,IAAI3H,KAAKyL,IAAIN,IAAkBnL,KAAK2H,IAAI2D,EAAetL,KAAK0L,IAAIP,IAChGQ,EAAcN,EAAcrL,KAAK2H,IAAI3H,KAAK0L,IAAIP,IAAkBnL,KAAK2H,IAAI2D,EAAetL,KAAKyL,IAAIN,IAErG,OADkB,IAAIS,EAAAA,EAAaV,EAASW,EAAGX,EAASY,EAAGN,EAAYG,EAEzE,CAOO,SAASI,EAA0B/F,GACxC,IAAIjE,EAAWiE,EAAMqC,IAAI,YACzB,OAAmB,MAAZtG,EAAmB,OAASA,CACrC,CAOO,SAASiK,EAAoBnF,GAClC,MAAqB,aAAdA,EAAKrF,MAA2E,IAApDuK,EAA0BlF,EAAK8C,gBACpE,CACO,SAASsC,EAAwBC,EAAMC,GAE5C,IAAIC,EAAa,CAAC,EAalB,OATAhH,EAAAA,GAAY8G,EAAKG,iBAAiBF,IAAU,SAAUG,GAOpDF,GAAWG,EAAAA,EAAAA,IAAoBL,EAAMI,KAAY,CACnD,IACOlH,EAAAA,GAAYgH,EACrB,CACO,SAASI,EAAwBlD,EAAY4C,EAAMC,GACpDD,GACF9G,EAAAA,GAAY6G,EAAwBC,EAAMC,IAAU,SAAUM,GAC5D,IAAIC,EAAeR,EAAKS,qBAAqBF,GAC7CC,EAAa,GAAKpD,EAAW,KAAOA,EAAW,GAAKoD,EAAa,IACjEA,EAAa,GAAKpD,EAAW,KAAOA,EAAW,GAAKoD,EAAa,GACnE,GAEJ,C","sources":["../node_modules/echarts/lib/coord/axisAlignTicks.js","../node_modules/echarts/lib/coord/axisCommonTypes.js","../node_modules/echarts/lib/coord/axisDefault.js","../node_modules/echarts/lib/coord/axisHelper.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { getPrecisionSafe, round } from '../util/number.js';\nimport IntervalScale from '../scale/Interval.js';\nimport { getScaleExtent } from './axisHelper.js';\nimport { warn } from '../util/log.js';\nimport { increaseInterval, isValueNice } from '../scale/helper.js';\nvar mathLog = Math.log;\nexport function alignScaleTicks(scale, axisModel, alignToScale) {\n  var intervalScaleProto = IntervalScale.prototype; // NOTE: There is a precondition for log scale  here:\n  // In log scale we store _interval and _extent of exponent value.\n  // So if we use the method of InternalScale to set/get these data.\n  // It process the exponent value, which is linear and what we want here.\n\n  var alignToTicks = intervalScaleProto.getTicks.call(alignToScale);\n  var alignToNicedTicks = intervalScaleProto.getTicks.call(alignToScale, true);\n  var alignToSplitNumber = alignToTicks.length - 1;\n  var alignToInterval = intervalScaleProto.getInterval.call(alignToScale);\n  var scaleExtent = getScaleExtent(scale, axisModel);\n  var rawExtent = scaleExtent.extent;\n  var isMinFixed = scaleExtent.fixMin;\n  var isMaxFixed = scaleExtent.fixMax;\n\n  if (scale.type === 'log') {\n    var logBase = mathLog(scale.base);\n    rawExtent = [mathLog(rawExtent[0]) / logBase, mathLog(rawExtent[1]) / logBase];\n  }\n\n  scale.setExtent(rawExtent[0], rawExtent[1]);\n  scale.calcNiceExtent({\n    splitNumber: alignToSplitNumber,\n    fixMin: isMinFixed,\n    fixMax: isMaxFixed\n  });\n  var extent = intervalScaleProto.getExtent.call(scale); // Need to update the rawExtent.\n  // Because value in rawExtent may be not parsed. e.g. 'dataMin', 'dataMax'\n\n  if (isMinFixed) {\n    rawExtent[0] = extent[0];\n  }\n\n  if (isMaxFixed) {\n    rawExtent[1] = extent[1];\n  }\n\n  var interval = intervalScaleProto.getInterval.call(scale);\n  var min = rawExtent[0];\n  var max = rawExtent[1];\n\n  if (isMinFixed && isMaxFixed) {\n    // User set min, max, divide to get new interval\n    interval = (max - min) / alignToSplitNumber;\n  } else if (isMinFixed) {\n    max = rawExtent[0] + interval * alignToSplitNumber; // User set min, expand extent on the other side\n\n    while (max < rawExtent[1] && isFinite(max) && isFinite(rawExtent[1])) {\n      interval = increaseInterval(interval);\n      max = rawExtent[0] + interval * alignToSplitNumber;\n    }\n  } else if (isMaxFixed) {\n    // User set max, expand extent on the other side\n    min = rawExtent[1] - interval * alignToSplitNumber;\n\n    while (min > rawExtent[0] && isFinite(min) && isFinite(rawExtent[0])) {\n      interval = increaseInterval(interval);\n      min = rawExtent[1] - interval * alignToSplitNumber;\n    }\n  } else {\n    var nicedSplitNumber = scale.getTicks().length - 1;\n\n    if (nicedSplitNumber > alignToSplitNumber) {\n      interval = increaseInterval(interval);\n    }\n\n    var range = interval * alignToSplitNumber;\n    max = Math.ceil(rawExtent[1] / interval) * interval;\n    min = round(max - range); // Not change the result that crossing zero.\n\n    if (min < 0 && rawExtent[0] >= 0) {\n      min = 0;\n      max = round(range);\n    } else if (max > 0 && rawExtent[1] <= 0) {\n      max = 0;\n      min = -round(range);\n    }\n  } // Adjust min, max based on the extent of alignTo. When min or max is set in alignTo scale\n\n\n  var t0 = (alignToTicks[0].value - alignToNicedTicks[0].value) / alignToInterval;\n  var t1 = (alignToTicks[alignToSplitNumber].value - alignToNicedTicks[alignToSplitNumber].value) / alignToInterval; // NOTE: Must in setExtent -> setInterval -> setNiceExtent order.\n\n  intervalScaleProto.setExtent.call(scale, min + interval * t0, max + interval * t1);\n  intervalScaleProto.setInterval.call(scale, interval);\n\n  if (t0 || t1) {\n    intervalScaleProto.setNiceExtent.call(scale, min + interval, max - interval);\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    var ticks = intervalScaleProto.getTicks.call(scale);\n\n    if (ticks[1] && (!isValueNice(interval) || getPrecisionSafe(ticks[1].value) > getPrecisionSafe(interval))) {\n      warn( // eslint-disable-next-line\n      \"The ticks may be not readable when set min: \" + axisModel.get('min') + \", max: \" + axisModel.get('max') + \" and alignTicks: true\");\n    }\n  }\n}","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nexport var AXIS_TYPES = {\n  value: 1,\n  category: 1,\n  time: 1,\n  log: 1\n};","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport * as zrUtil from 'zrender/lib/core/util.js';\nvar defaultOption = {\n  show: true,\n  // zlevel: 0,\n  z: 0,\n  // Inverse the axis.\n  inverse: false,\n  // Axis name displayed.\n  name: '',\n  // 'start' | 'middle' | 'end'\n  nameLocation: 'end',\n  // By degree. By default auto rotate by nameLocation.\n  nameRotate: null,\n  nameTruncate: {\n    maxWidth: null,\n    ellipsis: '...',\n    placeholder: '.'\n  },\n  // Use global text style by default.\n  nameTextStyle: {},\n  // The gap between axisName and axisLine.\n  nameGap: 15,\n  // Default `false` to support tooltip.\n  silent: false,\n  // Default `false` to avoid legacy user event listener fail.\n  triggerEvent: false,\n  tooltip: {\n    show: false\n  },\n  axisPointer: {},\n  axisLine: {\n    show: true,\n    onZero: true,\n    onZeroAxisIndex: null,\n    lineStyle: {\n      color: '#6E7079',\n      width: 1,\n      type: 'solid'\n    },\n    // The arrow at both ends the the axis.\n    symbol: ['none', 'none'],\n    symbolSize: [10, 15]\n  },\n  axisTick: {\n    show: true,\n    // Whether axisTick is inside the grid or outside the grid.\n    inside: false,\n    // The length of axisTick.\n    length: 5,\n    lineStyle: {\n      width: 1\n    }\n  },\n  axisLabel: {\n    show: true,\n    // Whether axisLabel is inside the grid or outside the grid.\n    inside: false,\n    rotate: 0,\n    // true | false | null/undefined (auto)\n    showMinLabel: null,\n    // true | false | null/undefined (auto)\n    showMaxLabel: null,\n    margin: 8,\n    // formatter: null,\n    fontSize: 12\n  },\n  splitLine: {\n    show: true,\n    lineStyle: {\n      color: ['#E0E6F1'],\n      width: 1,\n      type: 'solid'\n    }\n  },\n  splitArea: {\n    show: false,\n    areaStyle: {\n      color: ['rgba(250,250,250,0.2)', 'rgba(210,219,238,0.2)']\n    }\n  }\n};\nvar categoryAxis = zrUtil.merge({\n  // The gap at both ends of the axis. For categoryAxis, boolean.\n  boundaryGap: true,\n  // Set false to faster category collection.\n  deduplication: null,\n  // splitArea: {\n  // show: false\n  // },\n  splitLine: {\n    show: false\n  },\n  axisTick: {\n    // If tick is align with label when boundaryGap is true\n    alignWithLabel: false,\n    interval: 'auto'\n  },\n  axisLabel: {\n    interval: 'auto'\n  }\n}, defaultOption);\nvar valueAxis = zrUtil.merge({\n  boundaryGap: [0, 0],\n  axisLine: {\n    // Not shown when other axis is categoryAxis in cartesian\n    show: 'auto'\n  },\n  axisTick: {\n    // Not shown when other axis is categoryAxis in cartesian\n    show: 'auto'\n  },\n  // TODO\n  // min/max: [30, datamin, 60] or [20, datamin] or [datamin, 60]\n  splitNumber: 5,\n  minorTick: {\n    // Minor tick, not available for cateogry axis.\n    show: false,\n    // Split number of minor ticks. The value should be in range of (0, 100)\n    splitNumber: 5,\n    // Lenght of minor tick\n    length: 3,\n    // Line style\n    lineStyle: {// Default to be same with axisTick\n    }\n  },\n  minorSplitLine: {\n    show: false,\n    lineStyle: {\n      color: '#F4F7FD',\n      width: 1\n    }\n  }\n}, defaultOption);\nvar timeAxis = zrUtil.merge({\n  splitNumber: 6,\n  axisLabel: {\n    // To eliminate labels that are not nice\n    showMinLabel: false,\n    showMaxLabel: false,\n    rich: {\n      primary: {\n        fontWeight: 'bold'\n      }\n    }\n  },\n  splitLine: {\n    show: false\n  }\n}, valueAxis);\nvar logAxis = zrUtil.defaults({\n  logBase: 10\n}, valueAxis);\nexport default {\n  category: categoryAxis,\n  value: valueAxis,\n  time: timeAxis,\n  log: logAxis\n};","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport * as zrUtil from 'zrender/lib/core/util.js';\nimport OrdinalScale from '../scale/Ordinal.js';\nimport IntervalScale from '../scale/Interval.js';\nimport Scale from '../scale/Scale.js';\nimport { prepareLayoutBarSeries, makeColumnLayout, retrieveColumnLayout } from '../layout/barGrid.js';\nimport BoundingRect from 'zrender/lib/core/BoundingRect.js';\nimport TimeScale from '../scale/Time.js';\nimport LogScale from '../scale/Log.js';\nimport { getStackedDimension } from '../data/helper/dataStackHelper.js';\nimport { ensureScaleRawExtentInfo } from './scaleRawExtentInfo.js';\n/**\n * Get axis scale extent before niced.\n * Item of returned array can only be number (including Infinity and NaN).\n *\n * Caution:\n * Precondition of calling this method:\n * The scale extent has been initialized using series data extent via\n * `scale.setExtent` or `scale.unionExtentFromData`;\n */\n\nexport function getScaleExtent(scale, model) {\n  var scaleType = scale.type;\n  var rawExtentResult = ensureScaleRawExtentInfo(scale, model, scale.getExtent()).calculate();\n  scale.setBlank(rawExtentResult.isBlank);\n  var min = rawExtentResult.min;\n  var max = rawExtentResult.max; // If bars are placed on a base axis of type time or interval account for axis boundary overflow and current axis\n  // is base axis\n  // FIXME\n  // (1) Consider support value axis, where below zero and axis `onZero` should be handled properly.\n  // (2) Refactor the logic with `barGrid`. Is it not need to `makeBarWidthAndOffsetInfo` twice with different extent?\n  //     Should not depend on series type `bar`?\n  // (3) Fix that might overlap when using dataZoom.\n  // (4) Consider other chart types using `barGrid`?\n  // See #6728, #4862, `test/bar-overflow-time-plot.html`\n\n  var ecModel = model.ecModel;\n\n  if (ecModel && scaleType === 'time'\n  /*|| scaleType === 'interval' */\n  ) {\n    var barSeriesModels = prepareLayoutBarSeries('bar', ecModel);\n    var isBaseAxisAndHasBarSeries_1 = false;\n    zrUtil.each(barSeriesModels, function (seriesModel) {\n      isBaseAxisAndHasBarSeries_1 = isBaseAxisAndHasBarSeries_1 || seriesModel.getBaseAxis() === model.axis;\n    });\n\n    if (isBaseAxisAndHasBarSeries_1) {\n      // Calculate placement of bars on axis. TODO should be decoupled\n      // with barLayout\n      var barWidthAndOffset = makeColumnLayout(barSeriesModels); // Adjust axis min and max to account for overflow\n\n      var adjustedScale = adjustScaleForOverflow(min, max, model, barWidthAndOffset);\n      min = adjustedScale.min;\n      max = adjustedScale.max;\n    }\n  }\n\n  return {\n    extent: [min, max],\n    // \"fix\" means \"fixed\", the value should not be\n    // changed in the subsequent steps.\n    fixMin: rawExtentResult.minFixed,\n    fixMax: rawExtentResult.maxFixed\n  };\n}\n\nfunction adjustScaleForOverflow(min, max, model, // Only support cartesian coord yet.\nbarWidthAndOffset) {\n  // Get Axis Length\n  var axisExtent = model.axis.getExtent();\n  var axisLength = axisExtent[1] - axisExtent[0]; // Get bars on current base axis and calculate min and max overflow\n\n  var barsOnCurrentAxis = retrieveColumnLayout(barWidthAndOffset, model.axis);\n\n  if (barsOnCurrentAxis === undefined) {\n    return {\n      min: min,\n      max: max\n    };\n  }\n\n  var minOverflow = Infinity;\n  zrUtil.each(barsOnCurrentAxis, function (item) {\n    minOverflow = Math.min(item.offset, minOverflow);\n  });\n  var maxOverflow = -Infinity;\n  zrUtil.each(barsOnCurrentAxis, function (item) {\n    maxOverflow = Math.max(item.offset + item.width, maxOverflow);\n  });\n  minOverflow = Math.abs(minOverflow);\n  maxOverflow = Math.abs(maxOverflow);\n  var totalOverFlow = minOverflow + maxOverflow; // Calculate required buffer based on old range and overflow\n\n  var oldRange = max - min;\n  var oldRangePercentOfNew = 1 - (minOverflow + maxOverflow) / axisLength;\n  var overflowBuffer = oldRange / oldRangePercentOfNew - oldRange;\n  max += overflowBuffer * (maxOverflow / totalOverFlow);\n  min -= overflowBuffer * (minOverflow / totalOverFlow);\n  return {\n    min: min,\n    max: max\n  };\n} // Precondition of calling this method:\n// The scale extent has been initailized using series data extent via\n// `scale.setExtent` or `scale.unionExtentFromData`;\n\n\nexport function niceScaleExtent(scale, inModel) {\n  var model = inModel;\n  var extentInfo = getScaleExtent(scale, model);\n  var extent = extentInfo.extent;\n  var splitNumber = model.get('splitNumber');\n\n  if (scale instanceof LogScale) {\n    scale.base = model.get('logBase');\n  }\n\n  var scaleType = scale.type;\n  var interval = model.get('interval');\n  var isIntervalOrTime = scaleType === 'interval' || scaleType === 'time';\n  scale.setExtent(extent[0], extent[1]);\n  scale.calcNiceExtent({\n    splitNumber: splitNumber,\n    fixMin: extentInfo.fixMin,\n    fixMax: extentInfo.fixMax,\n    minInterval: isIntervalOrTime ? model.get('minInterval') : null,\n    maxInterval: isIntervalOrTime ? model.get('maxInterval') : null\n  }); // If some one specified the min, max. And the default calculated interval\n  // is not good enough. He can specify the interval. It is often appeared\n  // in angle axis with angle 0 - 360. Interval calculated in interval scale is hard\n  // to be 60.\n  // FIXME\n\n  if (interval != null) {\n    scale.setInterval && scale.setInterval(interval);\n  }\n}\n/**\n * @param axisType Default retrieve from model.type\n */\n\nexport function createScaleByModel(model, axisType) {\n  axisType = axisType || model.get('type');\n\n  if (axisType) {\n    switch (axisType) {\n      // Buildin scale\n      case 'category':\n        return new OrdinalScale({\n          ordinalMeta: model.getOrdinalMeta ? model.getOrdinalMeta() : model.getCategories(),\n          extent: [Infinity, -Infinity]\n        });\n\n      case 'time':\n        return new TimeScale({\n          locale: model.ecModel.getLocaleModel(),\n          useUTC: model.ecModel.get('useUTC')\n        });\n\n      default:\n        // case 'value'/'interval', 'log', or others.\n        return new (Scale.getClass(axisType) || IntervalScale)();\n    }\n  }\n}\n/**\n * Check if the axis cross 0\n */\n\nexport function ifAxisCrossZero(axis) {\n  var dataExtent = axis.scale.getExtent();\n  var min = dataExtent[0];\n  var max = dataExtent[1];\n  return !(min > 0 && max > 0 || min < 0 && max < 0);\n}\n/**\n * @param axis\n * @return Label formatter function.\n *         param: {number} tickValue,\n *         param: {number} idx, the index in all ticks.\n *                         If category axis, this param is not required.\n *         return: {string} label string.\n */\n\nexport function makeLabelFormatter(axis) {\n  var labelFormatter = axis.getLabelModel().get('formatter');\n  var categoryTickStart = axis.type === 'category' ? axis.scale.getExtent()[0] : null;\n\n  if (axis.scale.type === 'time') {\n    return function (tpl) {\n      return function (tick, idx) {\n        return axis.scale.getFormattedLabel(tick, idx, tpl);\n      };\n    }(labelFormatter);\n  } else if (zrUtil.isString(labelFormatter)) {\n    return function (tpl) {\n      return function (tick) {\n        // For category axis, get raw value; for numeric axis,\n        // get formatted label like '1,333,444'.\n        var label = axis.scale.getLabel(tick);\n        var text = tpl.replace('{value}', label != null ? label : '');\n        return text;\n      };\n    }(labelFormatter);\n  } else if (zrUtil.isFunction(labelFormatter)) {\n    return function (cb) {\n      return function (tick, idx) {\n        // The original intention of `idx` is \"the index of the tick in all ticks\".\n        // But the previous implementation of category axis do not consider the\n        // `axisLabel.interval`, which cause that, for example, the `interval` is\n        // `1`, then the ticks \"name5\", \"name7\", \"name9\" are displayed, where the\n        // corresponding `idx` are `0`, `2`, `4`, but not `0`, `1`, `2`. So we keep\n        // the definition here for back compatibility.\n        if (categoryTickStart != null) {\n          idx = tick.value - categoryTickStart;\n        }\n\n        return cb(getAxisRawValue(axis, tick), idx, tick.level != null ? {\n          level: tick.level\n        } : null);\n      };\n    }(labelFormatter);\n  } else {\n    return function (tick) {\n      return axis.scale.getLabel(tick);\n    };\n  }\n}\nexport function getAxisRawValue(axis, tick) {\n  // In category axis with data zoom, tick is not the original\n  // index of axis.data. So tick should not be exposed to user\n  // in category axis.\n  return axis.type === 'category' ? axis.scale.getLabel(tick) : tick.value;\n}\n/**\n * @param axis\n * @return Be null/undefined if no labels.\n */\n\nexport function estimateLabelUnionRect(axis) {\n  var axisModel = axis.model;\n  var scale = axis.scale;\n\n  if (!axisModel.get(['axisLabel', 'show']) || scale.isBlank()) {\n    return;\n  }\n\n  var realNumberScaleTicks;\n  var tickCount;\n  var categoryScaleExtent = scale.getExtent(); // Optimize for large category data, avoid call `getTicks()`.\n\n  if (scale instanceof OrdinalScale) {\n    tickCount = scale.count();\n  } else {\n    realNumberScaleTicks = scale.getTicks();\n    tickCount = realNumberScaleTicks.length;\n  }\n\n  var axisLabelModel = axis.getLabelModel();\n  var labelFormatter = makeLabelFormatter(axis);\n  var rect;\n  var step = 1; // Simple optimization for large amount of labels\n\n  if (tickCount > 40) {\n    step = Math.ceil(tickCount / 40);\n  }\n\n  for (var i = 0; i < tickCount; i += step) {\n    var tick = realNumberScaleTicks ? realNumberScaleTicks[i] : {\n      value: categoryScaleExtent[0] + i\n    };\n    var label = labelFormatter(tick, i);\n    var unrotatedSingleRect = axisLabelModel.getTextRect(label);\n    var singleRect = rotateTextRect(unrotatedSingleRect, axisLabelModel.get('rotate') || 0);\n    rect ? rect.union(singleRect) : rect = singleRect;\n  }\n\n  return rect;\n}\n\nfunction rotateTextRect(textRect, rotate) {\n  var rotateRadians = rotate * Math.PI / 180;\n  var beforeWidth = textRect.width;\n  var beforeHeight = textRect.height;\n  var afterWidth = beforeWidth * Math.abs(Math.cos(rotateRadians)) + Math.abs(beforeHeight * Math.sin(rotateRadians));\n  var afterHeight = beforeWidth * Math.abs(Math.sin(rotateRadians)) + Math.abs(beforeHeight * Math.cos(rotateRadians));\n  var rotatedRect = new BoundingRect(textRect.x, textRect.y, afterWidth, afterHeight);\n  return rotatedRect;\n}\n/**\n * @param model axisLabelModel or axisTickModel\n * @return {number|String} Can be null|'auto'|number|function\n */\n\n\nexport function getOptionCategoryInterval(model) {\n  var interval = model.get('interval');\n  return interval == null ? 'auto' : interval;\n}\n/**\n * Set `categoryInterval` as 0 implicitly indicates that\n * show all labels reguardless of overlap.\n * @param {Object} axis axisModel.axis\n */\n\nexport function shouldShowAllLabels(axis) {\n  return axis.type === 'category' && getOptionCategoryInterval(axis.getLabelModel()) === 0;\n}\nexport function getDataDimensionsOnAxis(data, axisDim) {\n  // Remove duplicated dat dimensions caused by `getStackedDimension`.\n  var dataDimMap = {}; // Currently `mapDimensionsAll` will contain stack result dimension ('__\\0ecstackresult').\n  // PENDING: is it reasonable? Do we need to remove the original dim from \"coord dim\" since\n  // there has been stacked result dim?\n\n  zrUtil.each(data.mapDimensionsAll(axisDim), function (dataDim) {\n    // For example, the extent of the original dimension\n    // is [0.1, 0.5], the extent of the `stackResultDimension`\n    // is [7, 9], the final extent should NOT include [0.1, 0.5],\n    // because there is no graphic corresponding to [0.1, 0.5].\n    // See the case in `test/area-stack.html` `main1`, where area line\n    // stack needs `yAxis` not start from 0.\n    dataDimMap[getStackedDimension(data, dataDim)] = true;\n  });\n  return zrUtil.keys(dataDimMap);\n}\nexport function unionAxisExtentFromData(dataExtent, data, axisDim) {\n  if (data) {\n    zrUtil.each(getDataDimensionsOnAxis(data, axisDim), function (dim) {\n      var seriesExtent = data.getApproximateExtent(dim);\n      seriesExtent[0] < dataExtent[0] && (dataExtent[0] = seriesExtent[0]);\n      seriesExtent[1] > dataExtent[1] && (dataExtent[1] = seriesExtent[1]);\n    });\n  }\n}"],"names":["mathLog","Math","log","alignScaleTicks","scale","axisModel","alignToScale","intervalScaleProto","IntervalScale","alignToTicks","getTicks","call","alignToNicedTicks","alignToSplitNumber","length","alignToInterval","getInterval","scaleExtent","getScaleExtent","rawExtent","extent","isMinFixed","fixMin","isMaxFixed","fixMax","type","logBase","base","setExtent","calcNiceExtent","splitNumber","getExtent","interval","min","max","isFinite","increaseInterval","range","ceil","round","t0","value","t1","setInterval","setNiceExtent","AXIS_TYPES","category","time","defaultOption","show","z","inverse","name","nameLocation","nameRotate","nameTruncate","maxWidth","ellipsis","placeholder","nameTextStyle","nameGap","silent","triggerEvent","tooltip","axisPointer","axisLine","onZero","onZeroAxisIndex","lineStyle","color","width","symbol","symbolSize","axisTick","inside","axisLabel","rotate","showMinLabel","showMaxLabel","margin","fontSize","splitLine","splitArea","areaStyle","categoryAxis","zrUtil","boundaryGap","deduplication","alignWithLabel","valueAxis","minorTick","minorSplitLine","timeAxis","rich","primary","fontWeight","logAxis","model","scaleType","rawExtentResult","ensureScaleRawExtentInfo","calculate","setBlank","isBlank","ecModel","barSeriesModels","prepareLayoutBarSeries","isBaseAxisAndHasBarSeries_1","seriesModel","getBaseAxis","axis","barWidthAndOffset","makeColumnLayout","adjustedScale","axisExtent","axisLength","barsOnCurrentAxis","retrieveColumnLayout","undefined","minOverflow","Infinity","item","offset","maxOverflow","abs","totalOverFlow","oldRange","overflowBuffer","adjustScaleForOverflow","minFixed","maxFixed","niceScaleExtent","inModel","extentInfo","get","LogScale","isIntervalOrTime","minInterval","maxInterval","createScaleByModel","axisType","OrdinalScale","ordinalMeta","getOrdinalMeta","getCategories","TimeScale","locale","getLocaleModel","useUTC","Scale","ifAxisCrossZero","dataExtent","makeLabelFormatter","cb","tpl","labelFormatter","getLabelModel","categoryTickStart","tick","idx","getFormattedLabel","label","getLabel","replace","getAxisRawValue","level","estimateLabelUnionRect","realNumberScaleTicks","tickCount","categoryScaleExtent","count","rect","axisLabelModel","step","i","singleRect","rotateTextRect","getTextRect","union","textRect","rotateRadians","PI","beforeWidth","beforeHeight","height","afterWidth","cos","sin","afterHeight","BoundingRect","x","y","getOptionCategoryInterval","shouldShowAllLabels","getDataDimensionsOnAxis","data","axisDim","dataDimMap","mapDimensionsAll","dataDim","getStackedDimension","unionAxisExtentFromData","dim","seriesExtent","getApproximateExtent"],"sourceRoot":""}
{"version":3,"file":"static/js/6550.a8ad9ada.js","mappings":"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","sources":["../node_modules/echarts/lib/chart/line/lineAnimationDiff.js","../node_modules/echarts/lib/chart/line/poly.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { prepareDataCoordInfo, getStackedOnPoint } from './helper.js';\nimport { createFloat32Array } from '../../util/vendor.js';\n\nfunction diffData(oldData, newData) {\n  var diffResult = [];\n  newData.diff(oldData).add(function (idx) {\n    diffResult.push({\n      cmd: '+',\n      idx: idx\n    });\n  }).update(function (newIdx, oldIdx) {\n    diffResult.push({\n      cmd: '=',\n      idx: oldIdx,\n      idx1: newIdx\n    });\n  }).remove(function (idx) {\n    diffResult.push({\n      cmd: '-',\n      idx: idx\n    });\n  }).execute();\n  return diffResult;\n}\n\nexport default function lineAnimationDiff(oldData, newData, oldStackedOnPoints, newStackedOnPoints, oldCoordSys, newCoordSys, oldValueOrigin, newValueOrigin) {\n  var diff = diffData(oldData, newData); // let newIdList = newData.mapArray(newData.getId);\n  // let oldIdList = oldData.mapArray(oldData.getId);\n  // convertToIntId(newIdList, oldIdList);\n  // // FIXME One data ?\n  // diff = arrayDiff(oldIdList, newIdList);\n\n  var currPoints = [];\n  var nextPoints = []; // Points for stacking base line\n\n  var currStackedPoints = [];\n  var nextStackedPoints = [];\n  var status = [];\n  var sortedIndices = [];\n  var rawIndices = [];\n  var newDataOldCoordInfo = prepareDataCoordInfo(oldCoordSys, newData, oldValueOrigin); // const oldDataNewCoordInfo = prepareDataCoordInfo(newCoordSys, oldData, newValueOrigin);\n\n  var oldPoints = oldData.getLayout('points') || [];\n  var newPoints = newData.getLayout('points') || [];\n\n  for (var i = 0; i < diff.length; i++) {\n    var diffItem = diff[i];\n    var pointAdded = true;\n    var oldIdx2 = void 0;\n    var newIdx2 = void 0; // FIXME, animation is not so perfect when dataZoom window moves fast\n    // Which is in case remvoing or add more than one data in the tail or head\n\n    switch (diffItem.cmd) {\n      case '=':\n        oldIdx2 = diffItem.idx * 2;\n        newIdx2 = diffItem.idx1 * 2;\n        var currentX = oldPoints[oldIdx2];\n        var currentY = oldPoints[oldIdx2 + 1];\n        var nextX = newPoints[newIdx2];\n        var nextY = newPoints[newIdx2 + 1]; // If previous data is NaN, use next point directly\n\n        if (isNaN(currentX) || isNaN(currentY)) {\n          currentX = nextX;\n          currentY = nextY;\n        }\n\n        currPoints.push(currentX, currentY);\n        nextPoints.push(nextX, nextY);\n        currStackedPoints.push(oldStackedOnPoints[oldIdx2], oldStackedOnPoints[oldIdx2 + 1]);\n        nextStackedPoints.push(newStackedOnPoints[newIdx2], newStackedOnPoints[newIdx2 + 1]);\n        rawIndices.push(newData.getRawIndex(diffItem.idx1));\n        break;\n\n      case '+':\n        var newIdx = diffItem.idx;\n        var newDataDimsForPoint = newDataOldCoordInfo.dataDimsForPoint;\n        var oldPt = oldCoordSys.dataToPoint([newData.get(newDataDimsForPoint[0], newIdx), newData.get(newDataDimsForPoint[1], newIdx)]);\n        newIdx2 = newIdx * 2;\n        currPoints.push(oldPt[0], oldPt[1]);\n        nextPoints.push(newPoints[newIdx2], newPoints[newIdx2 + 1]);\n        var stackedOnPoint = getStackedOnPoint(newDataOldCoordInfo, oldCoordSys, newData, newIdx);\n        currStackedPoints.push(stackedOnPoint[0], stackedOnPoint[1]);\n        nextStackedPoints.push(newStackedOnPoints[newIdx2], newStackedOnPoints[newIdx2 + 1]);\n        rawIndices.push(newData.getRawIndex(newIdx));\n        break;\n\n      case '-':\n        pointAdded = false;\n    } // Original indices\n\n\n    if (pointAdded) {\n      status.push(diffItem);\n      sortedIndices.push(sortedIndices.length);\n    }\n  } // Diff result may be crossed if all items are changed\n  // Sort by data index\n\n\n  sortedIndices.sort(function (a, b) {\n    return rawIndices[a] - rawIndices[b];\n  });\n  var len = currPoints.length;\n  var sortedCurrPoints = createFloat32Array(len);\n  var sortedNextPoints = createFloat32Array(len);\n  var sortedCurrStackedPoints = createFloat32Array(len);\n  var sortedNextStackedPoints = createFloat32Array(len);\n  var sortedStatus = [];\n\n  for (var i = 0; i < sortedIndices.length; i++) {\n    var idx = sortedIndices[i];\n    var i2 = i * 2;\n    var idx2 = idx * 2;\n    sortedCurrPoints[i2] = currPoints[idx2];\n    sortedCurrPoints[i2 + 1] = currPoints[idx2 + 1];\n    sortedNextPoints[i2] = nextPoints[idx2];\n    sortedNextPoints[i2 + 1] = nextPoints[idx2 + 1];\n    sortedCurrStackedPoints[i2] = currStackedPoints[idx2];\n    sortedCurrStackedPoints[i2 + 1] = currStackedPoints[idx2 + 1];\n    sortedNextStackedPoints[i2] = nextStackedPoints[idx2];\n    sortedNextStackedPoints[i2 + 1] = nextStackedPoints[idx2 + 1];\n    sortedStatus[i] = status[idx];\n  }\n\n  return {\n    current: sortedCurrPoints,\n    next: sortedNextPoints,\n    stackedOnCurrent: sortedCurrStackedPoints,\n    stackedOnNext: sortedNextStackedPoints,\n    status: sortedStatus\n  };\n}","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\"; // Poly path support NaN point\n\nimport Path from 'zrender/lib/graphic/Path.js';\nimport PathProxy from 'zrender/lib/core/PathProxy.js';\nimport { cubicRootAt, cubicAt } from 'zrender/lib/core/curve.js';\nvar mathMin = Math.min;\nvar mathMax = Math.max;\n\nfunction isPointNull(x, y) {\n  return isNaN(x) || isNaN(y);\n}\n/**\n * Draw smoothed line in non-monotone, in may cause undesired curve in extreme\n * situations. This should be used when points are non-monotone neither in x or\n * y dimension.\n */\n\n\nfunction drawSegment(ctx, points, start, segLen, allLen, dir, smooth, smoothMonotone, connectNulls) {\n  var prevX;\n  var prevY;\n  var cpx0;\n  var cpy0;\n  var cpx1;\n  var cpy1;\n  var idx = start;\n  var k = 0;\n\n  for (; k < segLen; k++) {\n    var x = points[idx * 2];\n    var y = points[idx * 2 + 1];\n\n    if (idx >= allLen || idx < 0) {\n      break;\n    }\n\n    if (isPointNull(x, y)) {\n      if (connectNulls) {\n        idx += dir;\n        continue;\n      }\n\n      break;\n    }\n\n    if (idx === start) {\n      ctx[dir > 0 ? 'moveTo' : 'lineTo'](x, y);\n      cpx0 = x;\n      cpy0 = y;\n    } else {\n      var dx = x - prevX;\n      var dy = y - prevY; // Ignore tiny segment.\n\n      if (dx * dx + dy * dy < 0.5) {\n        idx += dir;\n        continue;\n      }\n\n      if (smooth > 0) {\n        var nextIdx = idx + dir;\n        var nextX = points[nextIdx * 2];\n        var nextY = points[nextIdx * 2 + 1]; // Ignore duplicate point\n\n        while (nextX === x && nextY === y && k < segLen) {\n          k++;\n          nextIdx += dir;\n          idx += dir;\n          nextX = points[nextIdx * 2];\n          nextY = points[nextIdx * 2 + 1];\n          x = points[idx * 2];\n          y = points[idx * 2 + 1];\n          dx = x - prevX;\n          dy = y - prevY;\n        }\n\n        var tmpK = k + 1;\n\n        if (connectNulls) {\n          // Find next point not null\n          while (isPointNull(nextX, nextY) && tmpK < segLen) {\n            tmpK++;\n            nextIdx += dir;\n            nextX = points[nextIdx * 2];\n            nextY = points[nextIdx * 2 + 1];\n          }\n        }\n\n        var ratioNextSeg = 0.5;\n        var vx = 0;\n        var vy = 0;\n        var nextCpx0 = void 0;\n        var nextCpy0 = void 0; // Is last point\n\n        if (tmpK >= segLen || isPointNull(nextX, nextY)) {\n          cpx1 = x;\n          cpy1 = y;\n        } else {\n          vx = nextX - prevX;\n          vy = nextY - prevY;\n          var dx0 = x - prevX;\n          var dx1 = nextX - x;\n          var dy0 = y - prevY;\n          var dy1 = nextY - y;\n          var lenPrevSeg = void 0;\n          var lenNextSeg = void 0;\n\n          if (smoothMonotone === 'x') {\n            lenPrevSeg = Math.abs(dx0);\n            lenNextSeg = Math.abs(dx1);\n            var dir_1 = vx > 0 ? 1 : -1;\n            cpx1 = x - dir_1 * lenPrevSeg * smooth;\n            cpy1 = y;\n            nextCpx0 = x + dir_1 * lenNextSeg * smooth;\n            nextCpy0 = y;\n          } else if (smoothMonotone === 'y') {\n            lenPrevSeg = Math.abs(dy0);\n            lenNextSeg = Math.abs(dy1);\n            var dir_2 = vy > 0 ? 1 : -1;\n            cpx1 = x;\n            cpy1 = y - dir_2 * lenPrevSeg * smooth;\n            nextCpx0 = x;\n            nextCpy0 = y + dir_2 * lenNextSeg * smooth;\n          } else {\n            lenPrevSeg = Math.sqrt(dx0 * dx0 + dy0 * dy0);\n            lenNextSeg = Math.sqrt(dx1 * dx1 + dy1 * dy1); // Use ratio of seg length\n\n            ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);\n            cpx1 = x - vx * smooth * (1 - ratioNextSeg);\n            cpy1 = y - vy * smooth * (1 - ratioNextSeg); // cp0 of next segment\n\n            nextCpx0 = x + vx * smooth * ratioNextSeg;\n            nextCpy0 = y + vy * smooth * ratioNextSeg; // Smooth constraint between point and next point.\n            // Avoid exceeding extreme after smoothing.\n\n            nextCpx0 = mathMin(nextCpx0, mathMax(nextX, x));\n            nextCpy0 = mathMin(nextCpy0, mathMax(nextY, y));\n            nextCpx0 = mathMax(nextCpx0, mathMin(nextX, x));\n            nextCpy0 = mathMax(nextCpy0, mathMin(nextY, y)); // Reclaculate cp1 based on the adjusted cp0 of next seg.\n\n            vx = nextCpx0 - x;\n            vy = nextCpy0 - y;\n            cpx1 = x - vx * lenPrevSeg / lenNextSeg;\n            cpy1 = y - vy * lenPrevSeg / lenNextSeg; // Smooth constraint between point and prev point.\n            // Avoid exceeding extreme after smoothing.\n\n            cpx1 = mathMin(cpx1, mathMax(prevX, x));\n            cpy1 = mathMin(cpy1, mathMax(prevY, y));\n            cpx1 = mathMax(cpx1, mathMin(prevX, x));\n            cpy1 = mathMax(cpy1, mathMin(prevY, y)); // Adjust next cp0 again.\n\n            vx = x - cpx1;\n            vy = y - cpy1;\n            nextCpx0 = x + vx * lenNextSeg / lenPrevSeg;\n            nextCpy0 = y + vy * lenNextSeg / lenPrevSeg;\n          }\n        }\n\n        ctx.bezierCurveTo(cpx0, cpy0, cpx1, cpy1, x, y);\n        cpx0 = nextCpx0;\n        cpy0 = nextCpy0;\n      } else {\n        ctx.lineTo(x, y);\n      }\n    }\n\n    prevX = x;\n    prevY = y;\n    idx += dir;\n  }\n\n  return k;\n}\n\nvar ECPolylineShape =\n/** @class */\nfunction () {\n  function ECPolylineShape() {\n    this.smooth = 0;\n    this.smoothConstraint = true;\n  }\n\n  return ECPolylineShape;\n}();\n\nvar ECPolyline =\n/** @class */\nfunction (_super) {\n  __extends(ECPolyline, _super);\n\n  function ECPolyline(opts) {\n    var _this = _super.call(this, opts) || this;\n\n    _this.type = 'ec-polyline';\n    return _this;\n  }\n\n  ECPolyline.prototype.getDefaultStyle = function () {\n    return {\n      stroke: '#000',\n      fill: null\n    };\n  };\n\n  ECPolyline.prototype.getDefaultShape = function () {\n    return new ECPolylineShape();\n  };\n\n  ECPolyline.prototype.buildPath = function (ctx, shape) {\n    var points = shape.points;\n    var i = 0;\n    var len = points.length / 2; // const result = getBoundingBox(points, shape.smoothConstraint);\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len * 2 - 2], points[len * 2 - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i * 2], points[i * 2 + 1])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      i += drawSegment(ctx, points, i, len, len, 1, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;\n    }\n  };\n\n  ECPolyline.prototype.getPointOn = function (xOrY, dim) {\n    if (!this.path) {\n      this.createPathProxy();\n      this.buildPath(this.path, this.shape);\n    }\n\n    var path = this.path;\n    var data = path.data;\n    var CMD = PathProxy.CMD;\n    var x0;\n    var y0;\n    var isDimX = dim === 'x';\n    var roots = [];\n\n    for (var i = 0; i < data.length;) {\n      var cmd = data[i++];\n      var x = void 0;\n      var y = void 0;\n      var x2 = void 0;\n      var y2 = void 0;\n      var x3 = void 0;\n      var y3 = void 0;\n      var t = void 0;\n\n      switch (cmd) {\n        case CMD.M:\n          x0 = data[i++];\n          y0 = data[i++];\n          break;\n\n        case CMD.L:\n          x = data[i++];\n          y = data[i++];\n          t = isDimX ? (xOrY - x0) / (x - x0) : (xOrY - y0) / (y - y0);\n\n          if (t <= 1 && t >= 0) {\n            var val = isDimX ? (y - y0) * t + y0 : (x - x0) * t + x0;\n            return isDimX ? [xOrY, val] : [val, xOrY];\n          }\n\n          x0 = x;\n          y0 = y;\n          break;\n\n        case CMD.C:\n          x = data[i++];\n          y = data[i++];\n          x2 = data[i++];\n          y2 = data[i++];\n          x3 = data[i++];\n          y3 = data[i++];\n          var nRoot = isDimX ? cubicRootAt(x0, x, x2, x3, xOrY, roots) : cubicRootAt(y0, y, y2, y3, xOrY, roots);\n\n          if (nRoot > 0) {\n            for (var i_1 = 0; i_1 < nRoot; i_1++) {\n              var t_1 = roots[i_1];\n\n              if (t_1 <= 1 && t_1 >= 0) {\n                var val = isDimX ? cubicAt(y0, y, y2, y3, t_1) : cubicAt(x0, x, x2, x3, t_1);\n                return isDimX ? [xOrY, val] : [val, xOrY];\n              }\n            }\n          }\n\n          x0 = x3;\n          y0 = y3;\n          break;\n      }\n    }\n  };\n\n  return ECPolyline;\n}(Path);\n\nexport { ECPolyline };\n\nvar ECPolygonShape =\n/** @class */\nfunction (_super) {\n  __extends(ECPolygonShape, _super);\n\n  function ECPolygonShape() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  return ECPolygonShape;\n}(ECPolylineShape);\n\nvar ECPolygon =\n/** @class */\nfunction (_super) {\n  __extends(ECPolygon, _super);\n\n  function ECPolygon(opts) {\n    var _this = _super.call(this, opts) || this;\n\n    _this.type = 'ec-polygon';\n    return _this;\n  }\n\n  ECPolygon.prototype.getDefaultShape = function () {\n    return new ECPolygonShape();\n  };\n\n  ECPolygon.prototype.buildPath = function (ctx, shape) {\n    var points = shape.points;\n    var stackedOnPoints = shape.stackedOnPoints;\n    var i = 0;\n    var len = points.length / 2;\n    var smoothMonotone = shape.smoothMonotone;\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len * 2 - 2], points[len * 2 - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i * 2], points[i * 2 + 1])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      var k = drawSegment(ctx, points, i, len, len, 1, shape.smooth, smoothMonotone, shape.connectNulls);\n      drawSegment(ctx, stackedOnPoints, i + k - 1, k, len, -1, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls);\n      i += k + 1;\n      ctx.closePath();\n    }\n  };\n\n  return ECPolygon;\n}(Path);\n\nexport { ECPolygon };"],"names":["lineAnimationDiff","oldData","newData","oldStackedOnPoints","newStackedOnPoints","oldCoordSys","newCoordSys","oldValueOrigin","newValueOrigin","diff","diffResult","add","idx","push","cmd","update","newIdx","oldIdx","idx1","remove","execute","diffData","currPoints","nextPoints","currStackedPoints","nextStackedPoints","status","sortedIndices","rawIndices","newDataOldCoordInfo","prepareDataCoordInfo","oldPoints","getLayout","newPoints","i","length","diffItem","pointAdded","oldIdx2","newIdx2","currentX","currentY","nextX","nextY","isNaN","getRawIndex","newDataDimsForPoint","dataDimsForPoint","oldPt","dataToPoint","get","stackedOnPoint","getStackedOnPoint","sort","a","b","len","sortedCurrPoints","createFloat32Array","sortedNextPoints","sortedCurrStackedPoints","sortedNextStackedPoints","sortedStatus","i2","idx2","current","next","stackedOnCurrent","stackedOnNext","mathMin","Math","min","mathMax","max","isPointNull","x","y","drawSegment","ctx","points","start","segLen","allLen","dir","smooth","smoothMonotone","connectNulls","prevX","prevY","cpx0","cpy0","cpx1","cpy1","k","dx","dy","nextIdx","tmpK","ratioNextSeg","vx","vy","nextCpx0","nextCpy0","dx0","dx1","dy0","dy1","lenPrevSeg","lenNextSeg","dir_1","abs","dir_2","sqrt","bezierCurveTo","lineTo","ECPolylineShape","this","smoothConstraint","ECPolyline","_super","opts","_this","call","type","__extends","prototype","getDefaultStyle","stroke","fill","getDefaultShape","buildPath","shape","getPointOn","xOrY","dim","path","createPathProxy","x0","y0","data","CMD","PathProxy","isDimX","roots","x2","y2","x3","y3","t","M","L","val","C","nRoot","cubicRootAt","i_1","t_1","cubicAt","Path","ECPolygonShape","apply","arguments","ECPolygon","stackedOnPoints","stackedOnSmooth","closePath"],"sourceRoot":""}
{"version":3,"file":"static/js/3336.93a9f8c5.js","mappings":"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","sources":["../node_modules/echarts/lib/chart/treemap/treemapAction.js","../node_modules/echarts/lib/chart/treemap/treemapLayout.js","../node_modules/echarts/lib/chart/treemap/treemapVisual.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport * as helper from '../helper/treeHelper.js';\nimport { noop } from 'zrender/lib/core/util.js';\nvar actionTypes = ['treemapZoomToNode', 'treemapRender', 'treemapMove'];\nexport function installTreemapAction(registers) {\n  for (var i = 0; i < actionTypes.length; i++) {\n    registers.registerAction({\n      type: actionTypes[i],\n      update: 'updateView'\n    }, noop);\n  }\n\n  registers.registerAction({\n    type: 'treemapRootToNode',\n    update: 'updateView'\n  }, function (payload, ecModel) {\n    ecModel.eachComponent({\n      mainType: 'series',\n      subType: 'treemap',\n      query: payload\n    }, handleRootToNode);\n\n    function handleRootToNode(model, index) {\n      var types = ['treemapZoomToNode', 'treemapRootToNode'];\n      var targetInfo = helper.retrieveTargetInfo(payload, types, model);\n\n      if (targetInfo) {\n        var originViewRoot = model.getViewRoot();\n\n        if (originViewRoot) {\n          payload.direction = helper.aboveViewRoot(originViewRoot, targetInfo.node) ? 'rollUp' : 'drillDown';\n        }\n\n        model.resetViewRoot(targetInfo.node);\n      }\n    }\n  });\n}","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/*\n* A third-party license is embeded for some of the code in this file:\n* The treemap layout implementation was originally copied from\n* \"d3.js\" with some modifications made for this project.\n* (See more details in the comment of the method \"squarify\" below.)\n* The use of the source code of this file is also subject to the terms\n* and consitions of the license of \"d3.js\" (BSD-3Clause, see\n* </licenses/LICENSE-d3>).\n*/\nimport * as zrUtil from 'zrender/lib/core/util.js';\nimport BoundingRect from 'zrender/lib/core/BoundingRect.js';\nimport { parsePercent, MAX_SAFE_INTEGER } from '../../util/number.js';\nimport * as layout from '../../util/layout.js';\nimport * as helper from '../helper/treeHelper.js';\nvar mathMax = Math.max;\nvar mathMin = Math.min;\nvar retrieveValue = zrUtil.retrieve;\nvar each = zrUtil.each;\nvar PATH_BORDER_WIDTH = ['itemStyle', 'borderWidth'];\nvar PATH_GAP_WIDTH = ['itemStyle', 'gapWidth'];\nvar PATH_UPPER_LABEL_SHOW = ['upperLabel', 'show'];\nvar PATH_UPPER_LABEL_HEIGHT = ['upperLabel', 'height'];\n;\n/**\n * @public\n */\n\nexport default {\n  seriesType: 'treemap',\n  reset: function (seriesModel, ecModel, api, payload) {\n    // Layout result in each node:\n    // {x, y, width, height, area, borderWidth}\n    var ecWidth = api.getWidth();\n    var ecHeight = api.getHeight();\n    var seriesOption = seriesModel.option;\n    var layoutInfo = layout.getLayoutRect(seriesModel.getBoxLayoutParams(), {\n      width: api.getWidth(),\n      height: api.getHeight()\n    });\n    var size = seriesOption.size || []; // Compatible with ec2.\n\n    var containerWidth = parsePercent(retrieveValue(layoutInfo.width, size[0]), ecWidth);\n    var containerHeight = parsePercent(retrieveValue(layoutInfo.height, size[1]), ecHeight); // Fetch payload info.\n\n    var payloadType = payload && payload.type;\n    var types = ['treemapZoomToNode', 'treemapRootToNode'];\n    var targetInfo = helper.retrieveTargetInfo(payload, types, seriesModel);\n    var rootRect = payloadType === 'treemapRender' || payloadType === 'treemapMove' ? payload.rootRect : null;\n    var viewRoot = seriesModel.getViewRoot();\n    var viewAbovePath = helper.getPathToRoot(viewRoot);\n\n    if (payloadType !== 'treemapMove') {\n      var rootSize = payloadType === 'treemapZoomToNode' ? estimateRootSize(seriesModel, targetInfo, viewRoot, containerWidth, containerHeight) : rootRect ? [rootRect.width, rootRect.height] : [containerWidth, containerHeight];\n      var sort_1 = seriesOption.sort;\n\n      if (sort_1 && sort_1 !== 'asc' && sort_1 !== 'desc') {\n        // Default to be desc order.\n        sort_1 = 'desc';\n      }\n\n      var options = {\n        squareRatio: seriesOption.squareRatio,\n        sort: sort_1,\n        leafDepth: seriesOption.leafDepth\n      }; // layout should be cleared because using updateView but not update.\n\n      viewRoot.hostTree.clearLayouts(); // TODO\n      // optimize: if out of view clip, do not layout.\n      // But take care that if do not render node out of view clip,\n      // how to calculate start po\n\n      var viewRootLayout_1 = {\n        x: 0,\n        y: 0,\n        width: rootSize[0],\n        height: rootSize[1],\n        area: rootSize[0] * rootSize[1]\n      };\n      viewRoot.setLayout(viewRootLayout_1);\n      squarify(viewRoot, options, false, 0); // Supplement layout.\n\n      viewRootLayout_1 = viewRoot.getLayout();\n      each(viewAbovePath, function (node, index) {\n        var childValue = (viewAbovePath[index + 1] || viewRoot).getValue();\n        node.setLayout(zrUtil.extend({\n          dataExtent: [childValue, childValue],\n          borderWidth: 0,\n          upperHeight: 0\n        }, viewRootLayout_1));\n      });\n    }\n\n    var treeRoot = seriesModel.getData().tree.root;\n    treeRoot.setLayout(calculateRootPosition(layoutInfo, rootRect, targetInfo), true);\n    seriesModel.setLayoutInfo(layoutInfo); // FIXME\n    // 现在没有clip功能，暂时取ec高宽。\n\n    prunning(treeRoot, // Transform to base element coordinate system.\n    new BoundingRect(-layoutInfo.x, -layoutInfo.y, ecWidth, ecHeight), viewAbovePath, viewRoot, 0);\n  }\n};\n/**\n * Layout treemap with squarify algorithm.\n * The original presentation of this algorithm\n * was made by Mark Bruls, Kees Huizing, and Jarke J. van Wijk\n * <https://graphics.ethz.ch/teaching/scivis_common/Literature/squarifiedTreeMaps.pdf>.\n * The implementation of this algorithm was originally copied from \"d3.js\"\n * <https://github.com/d3/d3/blob/9cc9a875e636a1dcf36cc1e07bdf77e1ad6e2c74/src/layout/treemap.js>\n * with some modifications made for this program.\n * See the license statement at the head of this file.\n *\n * @protected\n * @param {module:echarts/data/Tree~TreeNode} node\n * @param {Object} options\n * @param {string} options.sort 'asc' or 'desc'\n * @param {number} options.squareRatio\n * @param {boolean} hideChildren\n * @param {number} depth\n */\n\nfunction squarify(node, options, hideChildren, depth) {\n  var width;\n  var height;\n\n  if (node.isRemoved()) {\n    return;\n  }\n\n  var thisLayout = node.getLayout();\n  width = thisLayout.width;\n  height = thisLayout.height; // Considering border and gap\n\n  var nodeModel = node.getModel();\n  var borderWidth = nodeModel.get(PATH_BORDER_WIDTH);\n  var halfGapWidth = nodeModel.get(PATH_GAP_WIDTH) / 2;\n  var upperLabelHeight = getUpperLabelHeight(nodeModel);\n  var upperHeight = Math.max(borderWidth, upperLabelHeight);\n  var layoutOffset = borderWidth - halfGapWidth;\n  var layoutOffsetUpper = upperHeight - halfGapWidth;\n  node.setLayout({\n    borderWidth: borderWidth,\n    upperHeight: upperHeight,\n    upperLabelHeight: upperLabelHeight\n  }, true);\n  width = mathMax(width - 2 * layoutOffset, 0);\n  height = mathMax(height - layoutOffset - layoutOffsetUpper, 0);\n  var totalArea = width * height;\n  var viewChildren = initChildren(node, nodeModel, totalArea, options, hideChildren, depth);\n\n  if (!viewChildren.length) {\n    return;\n  }\n\n  var rect = {\n    x: layoutOffset,\n    y: layoutOffsetUpper,\n    width: width,\n    height: height\n  };\n  var rowFixedLength = mathMin(width, height);\n  var best = Infinity; // the best row score so far\n\n  var row = [];\n  row.area = 0;\n\n  for (var i = 0, len = viewChildren.length; i < len;) {\n    var child = viewChildren[i];\n    row.push(child);\n    row.area += child.getLayout().area;\n    var score = worst(row, rowFixedLength, options.squareRatio); // continue with this orientation\n\n    if (score <= best) {\n      i++;\n      best = score;\n    } // abort, and try a different orientation\n    else {\n        row.area -= row.pop().getLayout().area;\n        position(row, rowFixedLength, rect, halfGapWidth, false);\n        rowFixedLength = mathMin(rect.width, rect.height);\n        row.length = row.area = 0;\n        best = Infinity;\n      }\n  }\n\n  if (row.length) {\n    position(row, rowFixedLength, rect, halfGapWidth, true);\n  }\n\n  if (!hideChildren) {\n    var childrenVisibleMin = nodeModel.get('childrenVisibleMin');\n\n    if (childrenVisibleMin != null && totalArea < childrenVisibleMin) {\n      hideChildren = true;\n    }\n  }\n\n  for (var i = 0, len = viewChildren.length; i < len; i++) {\n    squarify(viewChildren[i], options, hideChildren, depth + 1);\n  }\n}\n/**\n * Set area to each child, and calculate data extent for visual coding.\n */\n\n\nfunction initChildren(node, nodeModel, totalArea, options, hideChildren, depth) {\n  var viewChildren = node.children || [];\n  var orderBy = options.sort;\n  orderBy !== 'asc' && orderBy !== 'desc' && (orderBy = null);\n  var overLeafDepth = options.leafDepth != null && options.leafDepth <= depth; // leafDepth has higher priority.\n\n  if (hideChildren && !overLeafDepth) {\n    return node.viewChildren = [];\n  } // Sort children, order by desc.\n\n\n  viewChildren = zrUtil.filter(viewChildren, function (child) {\n    return !child.isRemoved();\n  });\n  sort(viewChildren, orderBy);\n  var info = statistic(nodeModel, viewChildren, orderBy);\n\n  if (info.sum === 0) {\n    return node.viewChildren = [];\n  }\n\n  info.sum = filterByThreshold(nodeModel, totalArea, info.sum, orderBy, viewChildren);\n\n  if (info.sum === 0) {\n    return node.viewChildren = [];\n  } // Set area to each child.\n\n\n  for (var i = 0, len = viewChildren.length; i < len; i++) {\n    var area = viewChildren[i].getValue() / info.sum * totalArea; // Do not use setLayout({...}, true), because it is needed to clear last layout.\n\n    viewChildren[i].setLayout({\n      area: area\n    });\n  }\n\n  if (overLeafDepth) {\n    viewChildren.length && node.setLayout({\n      isLeafRoot: true\n    }, true);\n    viewChildren.length = 0;\n  }\n\n  node.viewChildren = viewChildren;\n  node.setLayout({\n    dataExtent: info.dataExtent\n  }, true);\n  return viewChildren;\n}\n/**\n * Consider 'visibleMin'. Modify viewChildren and get new sum.\n */\n\n\nfunction filterByThreshold(nodeModel, totalArea, sum, orderBy, orderedChildren) {\n  // visibleMin is not supported yet when no option.sort.\n  if (!orderBy) {\n    return sum;\n  }\n\n  var visibleMin = nodeModel.get('visibleMin');\n  var len = orderedChildren.length;\n  var deletePoint = len; // Always travel from little value to big value.\n\n  for (var i = len - 1; i >= 0; i--) {\n    var value = orderedChildren[orderBy === 'asc' ? len - i - 1 : i].getValue();\n\n    if (value / sum * totalArea < visibleMin) {\n      deletePoint = i;\n      sum -= value;\n    }\n  }\n\n  orderBy === 'asc' ? orderedChildren.splice(0, len - deletePoint) : orderedChildren.splice(deletePoint, len - deletePoint);\n  return sum;\n}\n/**\n * Sort\n */\n\n\nfunction sort(viewChildren, orderBy) {\n  if (orderBy) {\n    viewChildren.sort(function (a, b) {\n      var diff = orderBy === 'asc' ? a.getValue() - b.getValue() : b.getValue() - a.getValue();\n      return diff === 0 ? orderBy === 'asc' ? a.dataIndex - b.dataIndex : b.dataIndex - a.dataIndex : diff;\n    });\n  }\n\n  return viewChildren;\n}\n/**\n * Statistic\n */\n\n\nfunction statistic(nodeModel, children, orderBy) {\n  // Calculate sum.\n  var sum = 0;\n\n  for (var i = 0, len = children.length; i < len; i++) {\n    sum += children[i].getValue();\n  } // Statistic data extent for latter visual coding.\n  // Notice: data extent should be calculate based on raw children\n  // but not filtered view children, otherwise visual mapping will not\n  // be stable when zoom (where children is filtered by visibleMin).\n\n\n  var dimension = nodeModel.get('visualDimension');\n  var dataExtent; // The same as area dimension.\n\n  if (!children || !children.length) {\n    dataExtent = [NaN, NaN];\n  } else if (dimension === 'value' && orderBy) {\n    dataExtent = [children[children.length - 1].getValue(), children[0].getValue()];\n    orderBy === 'asc' && dataExtent.reverse();\n  } // Other dimension.\n  else {\n      dataExtent = [Infinity, -Infinity];\n      each(children, function (child) {\n        var value = child.getValue(dimension);\n        value < dataExtent[0] && (dataExtent[0] = value);\n        value > dataExtent[1] && (dataExtent[1] = value);\n      });\n    }\n\n  return {\n    sum: sum,\n    dataExtent: dataExtent\n  };\n}\n/**\n * Computes the score for the specified row,\n * as the worst aspect ratio.\n */\n\n\nfunction worst(row, rowFixedLength, ratio) {\n  var areaMax = 0;\n  var areaMin = Infinity;\n\n  for (var i = 0, area = void 0, len = row.length; i < len; i++) {\n    area = row[i].getLayout().area;\n\n    if (area) {\n      area < areaMin && (areaMin = area);\n      area > areaMax && (areaMax = area);\n    }\n  }\n\n  var squareArea = row.area * row.area;\n  var f = rowFixedLength * rowFixedLength * ratio;\n  return squareArea ? mathMax(f * areaMax / squareArea, squareArea / (f * areaMin)) : Infinity;\n}\n/**\n * Positions the specified row of nodes. Modifies `rect`.\n */\n\n\nfunction position(row, rowFixedLength, rect, halfGapWidth, flush) {\n  // When rowFixedLength === rect.width,\n  // it is horizontal subdivision,\n  // rowFixedLength is the width of the subdivision,\n  // rowOtherLength is the height of the subdivision,\n  // and nodes will be positioned from left to right.\n  // wh[idx0WhenH] means: when horizontal,\n  //      wh[idx0WhenH] => wh[0] => 'width'.\n  //      xy[idx1WhenH] => xy[1] => 'y'.\n  var idx0WhenH = rowFixedLength === rect.width ? 0 : 1;\n  var idx1WhenH = 1 - idx0WhenH;\n  var xy = ['x', 'y'];\n  var wh = ['width', 'height'];\n  var last = rect[xy[idx0WhenH]];\n  var rowOtherLength = rowFixedLength ? row.area / rowFixedLength : 0;\n\n  if (flush || rowOtherLength > rect[wh[idx1WhenH]]) {\n    rowOtherLength = rect[wh[idx1WhenH]]; // over+underflow\n  }\n\n  for (var i = 0, rowLen = row.length; i < rowLen; i++) {\n    var node = row[i];\n    var nodeLayout = {};\n    var step = rowOtherLength ? node.getLayout().area / rowOtherLength : 0;\n    var wh1 = nodeLayout[wh[idx1WhenH]] = mathMax(rowOtherLength - 2 * halfGapWidth, 0); // We use Math.max/min to avoid negative width/height when considering gap width.\n\n    var remain = rect[xy[idx0WhenH]] + rect[wh[idx0WhenH]] - last;\n    var modWH = i === rowLen - 1 || remain < step ? remain : step;\n    var wh0 = nodeLayout[wh[idx0WhenH]] = mathMax(modWH - 2 * halfGapWidth, 0);\n    nodeLayout[xy[idx1WhenH]] = rect[xy[idx1WhenH]] + mathMin(halfGapWidth, wh1 / 2);\n    nodeLayout[xy[idx0WhenH]] = last + mathMin(halfGapWidth, wh0 / 2);\n    last += modWH;\n    node.setLayout(nodeLayout, true);\n  }\n\n  rect[xy[idx1WhenH]] += rowOtherLength;\n  rect[wh[idx1WhenH]] -= rowOtherLength;\n} // Return [containerWidth, containerHeight] as default.\n\n\nfunction estimateRootSize(seriesModel, targetInfo, viewRoot, containerWidth, containerHeight) {\n  // If targetInfo.node exists, we zoom to the node,\n  // so estimate whold width and heigth by target node.\n  var currNode = (targetInfo || {}).node;\n  var defaultSize = [containerWidth, containerHeight];\n\n  if (!currNode || currNode === viewRoot) {\n    return defaultSize;\n  }\n\n  var parent;\n  var viewArea = containerWidth * containerHeight;\n  var area = viewArea * seriesModel.option.zoomToNodeRatio;\n\n  while (parent = currNode.parentNode) {\n    // jshint ignore:line\n    var sum = 0;\n    var siblings = parent.children;\n\n    for (var i = 0, len = siblings.length; i < len; i++) {\n      sum += siblings[i].getValue();\n    }\n\n    var currNodeValue = currNode.getValue();\n\n    if (currNodeValue === 0) {\n      return defaultSize;\n    }\n\n    area *= sum / currNodeValue; // Considering border, suppose aspect ratio is 1.\n\n    var parentModel = parent.getModel();\n    var borderWidth = parentModel.get(PATH_BORDER_WIDTH);\n    var upperHeight = Math.max(borderWidth, getUpperLabelHeight(parentModel));\n    area += 4 * borderWidth * borderWidth + (3 * borderWidth + upperHeight) * Math.pow(area, 0.5);\n    area > MAX_SAFE_INTEGER && (area = MAX_SAFE_INTEGER);\n    currNode = parent;\n  }\n\n  area < viewArea && (area = viewArea);\n  var scale = Math.pow(area / viewArea, 0.5);\n  return [containerWidth * scale, containerHeight * scale];\n} // Root postion base on coord of containerGroup\n\n\nfunction calculateRootPosition(layoutInfo, rootRect, targetInfo) {\n  if (rootRect) {\n    return {\n      x: rootRect.x,\n      y: rootRect.y\n    };\n  }\n\n  var defaultPosition = {\n    x: 0,\n    y: 0\n  };\n\n  if (!targetInfo) {\n    return defaultPosition;\n  } // If targetInfo is fetched by 'retrieveTargetInfo',\n  // old tree and new tree are the same tree,\n  // so the node still exists and we can visit it.\n\n\n  var targetNode = targetInfo.node;\n  var layout = targetNode.getLayout();\n\n  if (!layout) {\n    return defaultPosition;\n  } // Transform coord from local to container.\n\n\n  var targetCenter = [layout.width / 2, layout.height / 2];\n  var node = targetNode;\n\n  while (node) {\n    var nodeLayout = node.getLayout();\n    targetCenter[0] += nodeLayout.x;\n    targetCenter[1] += nodeLayout.y;\n    node = node.parentNode;\n  }\n\n  return {\n    x: layoutInfo.width / 2 - targetCenter[0],\n    y: layoutInfo.height / 2 - targetCenter[1]\n  };\n} // Mark nodes visible for prunning when visual coding and rendering.\n// Prunning depends on layout and root position, so we have to do it after layout.\n\n\nfunction prunning(node, clipRect, viewAbovePath, viewRoot, depth) {\n  var nodeLayout = node.getLayout();\n  var nodeInViewAbovePath = viewAbovePath[depth];\n  var isAboveViewRoot = nodeInViewAbovePath && nodeInViewAbovePath === node;\n\n  if (nodeInViewAbovePath && !isAboveViewRoot || depth === viewAbovePath.length && node !== viewRoot) {\n    return;\n  }\n\n  node.setLayout({\n    // isInView means: viewRoot sub tree + viewAbovePath\n    isInView: true,\n    // invisible only means: outside view clip so that the node can not\n    // see but still layout for animation preparation but not render.\n    invisible: !isAboveViewRoot && !clipRect.intersect(nodeLayout),\n    isAboveViewRoot: isAboveViewRoot\n  }, true); // Transform to child coordinate.\n\n  var childClipRect = new BoundingRect(clipRect.x - nodeLayout.x, clipRect.y - nodeLayout.y, clipRect.width, clipRect.height);\n  each(node.viewChildren || [], function (child) {\n    prunning(child, childClipRect, viewAbovePath, viewRoot, depth + 1);\n  });\n}\n\nfunction getUpperLabelHeight(model) {\n  return model.get(PATH_UPPER_LABEL_SHOW) ? model.get(PATH_UPPER_LABEL_HEIGHT) : 0;\n}","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport VisualMapping from '../../visual/VisualMapping.js';\nimport { each, extend, isArray } from 'zrender/lib/core/util.js';\nimport { modifyHSL, modifyAlpha } from 'zrender/lib/tool/color.js';\nimport { makeInner } from '../../util/model.js';\nvar ITEM_STYLE_NORMAL = 'itemStyle';\nvar inner = makeInner();\nexport default {\n  seriesType: 'treemap',\n  reset: function (seriesModel) {\n    var tree = seriesModel.getData().tree;\n    var root = tree.root;\n\n    if (root.isRemoved()) {\n      return;\n    }\n\n    travelTree(root, // Visual should calculate from tree root but not view root.\n    {}, seriesModel.getViewRoot().getAncestors(), seriesModel);\n  }\n};\n\nfunction travelTree(node, designatedVisual, viewRootAncestors, seriesModel) {\n  var nodeModel = node.getModel();\n  var nodeLayout = node.getLayout();\n  var data = node.hostTree.data; // Optimize\n\n  if (!nodeLayout || nodeLayout.invisible || !nodeLayout.isInView) {\n    return;\n  }\n\n  var nodeItemStyleModel = nodeModel.getModel(ITEM_STYLE_NORMAL);\n  var visuals = buildVisuals(nodeItemStyleModel, designatedVisual, seriesModel);\n  var existsStyle = data.ensureUniqueItemVisual(node.dataIndex, 'style'); // calculate border color\n\n  var borderColor = nodeItemStyleModel.get('borderColor');\n  var borderColorSaturation = nodeItemStyleModel.get('borderColorSaturation');\n  var thisNodeColor;\n\n  if (borderColorSaturation != null) {\n    // For performance, do not always execute 'calculateColor'.\n    thisNodeColor = calculateColor(visuals);\n    borderColor = calculateBorderColor(borderColorSaturation, thisNodeColor);\n  }\n\n  existsStyle.stroke = borderColor;\n  var viewChildren = node.viewChildren;\n\n  if (!viewChildren || !viewChildren.length) {\n    thisNodeColor = calculateColor(visuals); // Apply visual to this node.\n\n    existsStyle.fill = thisNodeColor;\n  } else {\n    var mapping_1 = buildVisualMapping(node, nodeModel, nodeLayout, nodeItemStyleModel, visuals, viewChildren); // Designate visual to children.\n\n    each(viewChildren, function (child, index) {\n      // If higher than viewRoot, only ancestors of viewRoot is needed to visit.\n      if (child.depth >= viewRootAncestors.length || child === viewRootAncestors[child.depth]) {\n        var childVisual = mapVisual(nodeModel, visuals, child, index, mapping_1, seriesModel);\n        travelTree(child, childVisual, viewRootAncestors, seriesModel);\n      }\n    });\n  }\n}\n\nfunction buildVisuals(nodeItemStyleModel, designatedVisual, seriesModel) {\n  var visuals = extend({}, designatedVisual);\n  var designatedVisualItemStyle = seriesModel.designatedVisualItemStyle;\n  each(['color', 'colorAlpha', 'colorSaturation'], function (visualName) {\n    // Priority: thisNode > thisLevel > parentNodeDesignated > seriesModel\n    designatedVisualItemStyle[visualName] = designatedVisual[visualName];\n    var val = nodeItemStyleModel.get(visualName);\n    designatedVisualItemStyle[visualName] = null;\n    val != null && (visuals[visualName] = val);\n  });\n  return visuals;\n}\n\nfunction calculateColor(visuals) {\n  var color = getValueVisualDefine(visuals, 'color');\n\n  if (color) {\n    var colorAlpha = getValueVisualDefine(visuals, 'colorAlpha');\n    var colorSaturation = getValueVisualDefine(visuals, 'colorSaturation');\n\n    if (colorSaturation) {\n      color = modifyHSL(color, null, null, colorSaturation);\n    }\n\n    if (colorAlpha) {\n      color = modifyAlpha(color, colorAlpha);\n    }\n\n    return color;\n  }\n}\n\nfunction calculateBorderColor(borderColorSaturation, thisNodeColor) {\n  return thisNodeColor != null // Can only be string\n  ? modifyHSL(thisNodeColor, null, null, borderColorSaturation) : null;\n}\n\nfunction getValueVisualDefine(visuals, name) {\n  var value = visuals[name];\n\n  if (value != null && value !== 'none') {\n    return value;\n  }\n}\n\nfunction buildVisualMapping(node, nodeModel, nodeLayout, nodeItemStyleModel, visuals, viewChildren) {\n  if (!viewChildren || !viewChildren.length) {\n    return;\n  }\n\n  var rangeVisual = getRangeVisual(nodeModel, 'color') || visuals.color != null && visuals.color !== 'none' && (getRangeVisual(nodeModel, 'colorAlpha') || getRangeVisual(nodeModel, 'colorSaturation'));\n\n  if (!rangeVisual) {\n    return;\n  }\n\n  var visualMin = nodeModel.get('visualMin');\n  var visualMax = nodeModel.get('visualMax');\n  var dataExtent = nodeLayout.dataExtent.slice();\n  visualMin != null && visualMin < dataExtent[0] && (dataExtent[0] = visualMin);\n  visualMax != null && visualMax > dataExtent[1] && (dataExtent[1] = visualMax);\n  var colorMappingBy = nodeModel.get('colorMappingBy');\n  var opt = {\n    type: rangeVisual.name,\n    dataExtent: dataExtent,\n    visual: rangeVisual.range\n  };\n\n  if (opt.type === 'color' && (colorMappingBy === 'index' || colorMappingBy === 'id')) {\n    opt.mappingMethod = 'category';\n    opt.loop = true; // categories is ordinal, so do not set opt.categories.\n  } else {\n    opt.mappingMethod = 'linear';\n  }\n\n  var mapping = new VisualMapping(opt);\n  inner(mapping).drColorMappingBy = colorMappingBy;\n  return mapping;\n} // Notice: If we dont have the attribute 'colorRange', but only use\n// attribute 'color' to represent both concepts of 'colorRange' and 'color',\n// (It means 'colorRange' when 'color' is Array, means 'color' when not array),\n// this problem will be encountered:\n// If a level-1 node dont have children, and its siblings has children,\n// and colorRange is set on level-1, then the node can not be colored.\n// So we separate 'colorRange' and 'color' to different attributes.\n\n\nfunction getRangeVisual(nodeModel, name) {\n  // 'colorRange', 'colorARange', 'colorSRange'.\n  // If not exsits on this node, fetch from levels and series.\n  var range = nodeModel.get(name);\n  return isArray(range) && range.length ? {\n    name: name,\n    range: range\n  } : null;\n}\n\nfunction mapVisual(nodeModel, visuals, child, index, mapping, seriesModel) {\n  var childVisuals = extend({}, visuals);\n\n  if (mapping) {\n    // Only support color, colorAlpha, colorSaturation.\n    var mappingType = mapping.type;\n    var colorMappingBy = mappingType === 'color' && inner(mapping).drColorMappingBy;\n    var value = colorMappingBy === 'index' ? index : colorMappingBy === 'id' ? seriesModel.mapIdToIndex(child.getId()) : child.getValue(nodeModel.get('visualDimension'));\n    childVisuals[mappingType] = mapping.mapValueToVisual(value);\n  }\n\n  return childVisuals;\n}"],"names":["actionTypes","installTreemapAction","registers","i","length","registerAction","type","update","noop","payload","ecModel","eachComponent","mainType","subType","query","model","index","targetInfo","helper","originViewRoot","getViewRoot","direction","node","resetViewRoot","mathMax","Math","max","mathMin","min","retrieveValue","zrUtil","each","PATH_BORDER_WIDTH","PATH_GAP_WIDTH","PATH_UPPER_LABEL_SHOW","PATH_UPPER_LABEL_HEIGHT","squarify","options","hideChildren","depth","width","height","isRemoved","thisLayout","getLayout","nodeModel","getModel","borderWidth","get","halfGapWidth","upperLabelHeight","getUpperLabelHeight","upperHeight","layoutOffset","layoutOffsetUpper","setLayout","totalArea","viewChildren","children","orderBy","sort","overLeafDepth","leafDepth","child","a","b","diff","getValue","dataIndex","info","sum","len","dataExtent","dimension","reverse","Infinity","value","NaN","statistic","orderedChildren","visibleMin","deletePoint","splice","filterByThreshold","area","isLeafRoot","initChildren","rect","x","y","rowFixedLength","best","row","push","score","worst","squareRatio","pop","position","childrenVisibleMin","ratio","areaMax","areaMin","squareArea","f","flush","idx0WhenH","idx1WhenH","xy","wh","last","rowOtherLength","rowLen","nodeLayout","step","wh1","remain","modWH","wh0","prunning","clipRect","viewAbovePath","viewRoot","nodeInViewAbovePath","isAboveViewRoot","isInView","invisible","intersect","childClipRect","BoundingRect","seriesType","reset","seriesModel","api","ecWidth","getWidth","ecHeight","getHeight","seriesOption","option","layoutInfo","layout","getBoxLayoutParams","size","containerWidth","parsePercent","containerHeight","payloadType","rootRect","rootSize","parent","currNode","defaultSize","viewArea","zoomToNodeRatio","parentNode","siblings","currNodeValue","parentModel","pow","MAX_SAFE_INTEGER","scale","estimateRootSize","sort_1","hostTree","clearLayouts","viewRootLayout_1","childValue","treeRoot","getData","tree","root","defaultPosition","targetNode","targetCenter","calculateRootPosition","setLayoutInfo","inner","makeInner","travelTree","designatedVisual","viewRootAncestors","data","thisNodeColor","nodeItemStyleModel","visuals","extend","designatedVisualItemStyle","visualName","val","buildVisuals","existsStyle","ensureUniqueItemVisual","borderColor","borderColorSaturation","modifyHSL","calculateBorderColor","calculateColor","stroke","mapping_1","rangeVisual","getRangeVisual","color","visualMin","visualMax","slice","colorMappingBy","opt","name","visual","range","mappingMethod","loop","mapping","VisualMapping","drColorMappingBy","buildVisualMapping","childVisual","childVisuals","mappingType","mapIdToIndex","getId","mapValueToVisual","mapVisual","fill","getValueVisualDefine","colorAlpha","colorSaturation","modifyAlpha","isArray","getAncestors"],"sourceRoot":""}
{"version":3,"file":"static/js/2406.22232276.js","mappings":"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","sources":["../node_modules/echarts/lib/label/labelGuideHelper.js","../node_modules/echarts/lib/label/labelLayoutHelper.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { Point, Path, Polyline } from '../util/graphic.js';\nimport PathProxy from 'zrender/lib/core/PathProxy.js';\nimport { normalizeRadian } from 'zrender/lib/contain/util.js';\nimport { cubicProjectPoint, quadraticProjectPoint } from 'zrender/lib/core/curve.js';\nimport { defaults, retrieve2 } from 'zrender/lib/core/util.js';\nimport { invert } from 'zrender/lib/core/matrix.js';\nimport * as vector from 'zrender/lib/core/vector.js';\nimport { DISPLAY_STATES, SPECIAL_STATES } from '../util/states.js';\nvar PI2 = Math.PI * 2;\nvar CMD = PathProxy.CMD;\nvar DEFAULT_SEARCH_SPACE = ['top', 'right', 'bottom', 'left'];\n\nfunction getCandidateAnchor(pos, distance, rect, outPt, outDir) {\n  var width = rect.width;\n  var height = rect.height;\n\n  switch (pos) {\n    case 'top':\n      outPt.set(rect.x + width / 2, rect.y - distance);\n      outDir.set(0, -1);\n      break;\n\n    case 'bottom':\n      outPt.set(rect.x + width / 2, rect.y + height + distance);\n      outDir.set(0, 1);\n      break;\n\n    case 'left':\n      outPt.set(rect.x - distance, rect.y + height / 2);\n      outDir.set(-1, 0);\n      break;\n\n    case 'right':\n      outPt.set(rect.x + width + distance, rect.y + height / 2);\n      outDir.set(1, 0);\n      break;\n  }\n}\n\nfunction projectPointToArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y, out) {\n  x -= cx;\n  y -= cy;\n  var d = Math.sqrt(x * x + y * y);\n  x /= d;\n  y /= d; // Intersect point.\n\n  var ox = x * r + cx;\n  var oy = y * r + cy;\n\n  if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {\n    // Is a circle\n    out[0] = ox;\n    out[1] = oy;\n    return d - r;\n  }\n\n  if (anticlockwise) {\n    var tmp = startAngle;\n    startAngle = normalizeRadian(endAngle);\n    endAngle = normalizeRadian(tmp);\n  } else {\n    startAngle = normalizeRadian(startAngle);\n    endAngle = normalizeRadian(endAngle);\n  }\n\n  if (startAngle > endAngle) {\n    endAngle += PI2;\n  }\n\n  var angle = Math.atan2(y, x);\n\n  if (angle < 0) {\n    angle += PI2;\n  }\n\n  if (angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle) {\n    // Project point is on the arc.\n    out[0] = ox;\n    out[1] = oy;\n    return d - r;\n  }\n\n  var x1 = r * Math.cos(startAngle) + cx;\n  var y1 = r * Math.sin(startAngle) + cy;\n  var x2 = r * Math.cos(endAngle) + cx;\n  var y2 = r * Math.sin(endAngle) + cy;\n  var d1 = (x1 - x) * (x1 - x) + (y1 - y) * (y1 - y);\n  var d2 = (x2 - x) * (x2 - x) + (y2 - y) * (y2 - y);\n\n  if (d1 < d2) {\n    out[0] = x1;\n    out[1] = y1;\n    return Math.sqrt(d1);\n  } else {\n    out[0] = x2;\n    out[1] = y2;\n    return Math.sqrt(d2);\n  }\n}\n\nfunction projectPointToLine(x1, y1, x2, y2, x, y, out, limitToEnds) {\n  var dx = x - x1;\n  var dy = y - y1;\n  var dx1 = x2 - x1;\n  var dy1 = y2 - y1;\n  var lineLen = Math.sqrt(dx1 * dx1 + dy1 * dy1);\n  dx1 /= lineLen;\n  dy1 /= lineLen; // dot product\n\n  var projectedLen = dx * dx1 + dy * dy1;\n  var t = projectedLen / lineLen;\n\n  if (limitToEnds) {\n    t = Math.min(Math.max(t, 0), 1);\n  }\n\n  t *= lineLen;\n  var ox = out[0] = x1 + t * dx1;\n  var oy = out[1] = y1 + t * dy1;\n  return Math.sqrt((ox - x) * (ox - x) + (oy - y) * (oy - y));\n}\n\nfunction projectPointToRect(x1, y1, width, height, x, y, out) {\n  if (width < 0) {\n    x1 = x1 + width;\n    width = -width;\n  }\n\n  if (height < 0) {\n    y1 = y1 + height;\n    height = -height;\n  }\n\n  var x2 = x1 + width;\n  var y2 = y1 + height;\n  var ox = out[0] = Math.min(Math.max(x, x1), x2);\n  var oy = out[1] = Math.min(Math.max(y, y1), y2);\n  return Math.sqrt((ox - x) * (ox - x) + (oy - y) * (oy - y));\n}\n\nvar tmpPt = [];\n\nfunction nearestPointOnRect(pt, rect, out) {\n  var dist = projectPointToRect(rect.x, rect.y, rect.width, rect.height, pt.x, pt.y, tmpPt);\n  out.set(tmpPt[0], tmpPt[1]);\n  return dist;\n}\n/**\n * Calculate min distance corresponding point.\n * This method won't evaluate if point is in the path.\n */\n\n\nfunction nearestPointOnPath(pt, path, out) {\n  var xi = 0;\n  var yi = 0;\n  var x0 = 0;\n  var y0 = 0;\n  var x1;\n  var y1;\n  var minDist = Infinity;\n  var data = path.data;\n  var x = pt.x;\n  var y = pt.y;\n\n  for (var i = 0; i < data.length;) {\n    var cmd = data[i++];\n\n    if (i === 1) {\n      xi = data[i];\n      yi = data[i + 1];\n      x0 = xi;\n      y0 = yi;\n    }\n\n    var d = minDist;\n\n    switch (cmd) {\n      case CMD.M:\n        // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\n        // 在 closePath 的时候使用\n        x0 = data[i++];\n        y0 = data[i++];\n        xi = x0;\n        yi = y0;\n        break;\n\n      case CMD.L:\n        d = projectPointToLine(xi, yi, data[i], data[i + 1], x, y, tmpPt, true);\n        xi = data[i++];\n        yi = data[i++];\n        break;\n\n      case CMD.C:\n        d = cubicProjectPoint(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y, tmpPt);\n        xi = data[i++];\n        yi = data[i++];\n        break;\n\n      case CMD.Q:\n        d = quadraticProjectPoint(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y, tmpPt);\n        xi = data[i++];\n        yi = data[i++];\n        break;\n\n      case CMD.A:\n        // TODO Arc 判断的开销比较大\n        var cx = data[i++];\n        var cy = data[i++];\n        var rx = data[i++];\n        var ry = data[i++];\n        var theta = data[i++];\n        var dTheta = data[i++]; // TODO Arc 旋转\n\n        i += 1;\n        var anticlockwise = !!(1 - data[i++]);\n        x1 = Math.cos(theta) * rx + cx;\n        y1 = Math.sin(theta) * ry + cy; // 不是直接使用 arc 命令\n\n        if (i <= 1) {\n          // 第一个命令起点还未定义\n          x0 = x1;\n          y0 = y1;\n        } // zr 使用scale来模拟椭圆, 这里也对x做一定的缩放\n\n\n        var _x = (x - cx) * ry / rx + cx;\n\n        d = projectPointToArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y, tmpPt);\n        xi = Math.cos(theta + dTheta) * rx + cx;\n        yi = Math.sin(theta + dTheta) * ry + cy;\n        break;\n\n      case CMD.R:\n        x0 = xi = data[i++];\n        y0 = yi = data[i++];\n        var width = data[i++];\n        var height = data[i++];\n        d = projectPointToRect(x0, y0, width, height, x, y, tmpPt);\n        break;\n\n      case CMD.Z:\n        d = projectPointToLine(xi, yi, x0, y0, x, y, tmpPt, true);\n        xi = x0;\n        yi = y0;\n        break;\n    }\n\n    if (d < minDist) {\n      minDist = d;\n      out.set(tmpPt[0], tmpPt[1]);\n    }\n  }\n\n  return minDist;\n} // Temporal varible for intermediate usage.\n\n\nvar pt0 = new Point();\nvar pt1 = new Point();\nvar pt2 = new Point();\nvar dir = new Point();\nvar dir2 = new Point();\n/**\n * Calculate a proper guide line based on the label position and graphic element definition\n * @param label\n * @param labelRect\n * @param target\n * @param targetRect\n */\n\nexport function updateLabelLinePoints(target, labelLineModel) {\n  if (!target) {\n    return;\n  }\n\n  var labelLine = target.getTextGuideLine();\n  var label = target.getTextContent(); // Needs to create text guide in each charts.\n\n  if (!(label && labelLine)) {\n    return;\n  }\n\n  var labelGuideConfig = target.textGuideLineConfig || {};\n  var points = [[0, 0], [0, 0], [0, 0]];\n  var searchSpace = labelGuideConfig.candidates || DEFAULT_SEARCH_SPACE;\n  var labelRect = label.getBoundingRect().clone();\n  labelRect.applyTransform(label.getComputedTransform());\n  var minDist = Infinity;\n  var anchorPoint = labelGuideConfig.anchor;\n  var targetTransform = target.getComputedTransform();\n  var targetInversedTransform = targetTransform && invert([], targetTransform);\n  var len = labelLineModel.get('length2') || 0;\n\n  if (anchorPoint) {\n    pt2.copy(anchorPoint);\n  }\n\n  for (var i = 0; i < searchSpace.length; i++) {\n    var candidate = searchSpace[i];\n    getCandidateAnchor(candidate, 0, labelRect, pt0, dir);\n    Point.scaleAndAdd(pt1, pt0, dir, len); // Transform to target coord space.\n\n    pt1.transform(targetInversedTransform); // Note: getBoundingRect will ensure the `path` being created.\n\n    var boundingRect = target.getBoundingRect();\n    var dist = anchorPoint ? anchorPoint.distance(pt1) : target instanceof Path ? nearestPointOnPath(pt1, target.path, pt2) : nearestPointOnRect(pt1, boundingRect, pt2); // TODO pt2 is in the path\n\n    if (dist < minDist) {\n      minDist = dist; // Transform back to global space.\n\n      pt1.transform(targetTransform);\n      pt2.transform(targetTransform);\n      pt2.toArray(points[0]);\n      pt1.toArray(points[1]);\n      pt0.toArray(points[2]);\n    }\n  }\n\n  limitTurnAngle(points, labelLineModel.get('minTurnAngle'));\n  labelLine.setShape({\n    points: points\n  });\n} // Temporal variable for the limitTurnAngle function\n\nvar tmpArr = [];\nvar tmpProjPoint = new Point();\n/**\n * Reduce the line segment attached to the label to limit the turn angle between two segments.\n * @param linePoints\n * @param minTurnAngle Radian of minimum turn angle. 0 - 180\n */\n\nexport function limitTurnAngle(linePoints, minTurnAngle) {\n  if (!(minTurnAngle <= 180 && minTurnAngle > 0)) {\n    return;\n  }\n\n  minTurnAngle = minTurnAngle / 180 * Math.PI; // The line points can be\n  //      /pt1----pt2 (label)\n  //     /\n  // pt0/\n\n  pt0.fromArray(linePoints[0]);\n  pt1.fromArray(linePoints[1]);\n  pt2.fromArray(linePoints[2]);\n  Point.sub(dir, pt0, pt1);\n  Point.sub(dir2, pt2, pt1);\n  var len1 = dir.len();\n  var len2 = dir2.len();\n\n  if (len1 < 1e-3 || len2 < 1e-3) {\n    return;\n  }\n\n  dir.scale(1 / len1);\n  dir2.scale(1 / len2);\n  var angleCos = dir.dot(dir2);\n  var minTurnAngleCos = Math.cos(minTurnAngle);\n\n  if (minTurnAngleCos < angleCos) {\n    // Smaller than minTurnAngle\n    // Calculate project point of pt0 on pt1-pt2\n    var d = projectPointToLine(pt1.x, pt1.y, pt2.x, pt2.y, pt0.x, pt0.y, tmpArr, false);\n    tmpProjPoint.fromArray(tmpArr); // Calculate new projected length with limited minTurnAngle and get the new connect point\n\n    tmpProjPoint.scaleAndAdd(dir2, d / Math.tan(Math.PI - minTurnAngle)); // Limit the new calculated connect point between pt1 and pt2.\n\n    var t = pt2.x !== pt1.x ? (tmpProjPoint.x - pt1.x) / (pt2.x - pt1.x) : (tmpProjPoint.y - pt1.y) / (pt2.y - pt1.y);\n\n    if (isNaN(t)) {\n      return;\n    }\n\n    if (t < 0) {\n      Point.copy(tmpProjPoint, pt1);\n    } else if (t > 1) {\n      Point.copy(tmpProjPoint, pt2);\n    }\n\n    tmpProjPoint.toArray(linePoints[1]);\n  }\n}\n/**\n * Limit the angle of line and the surface\n * @param maxSurfaceAngle Radian of minimum turn angle. 0 - 180. 0 is same direction to normal. 180 is opposite\n */\n\nexport function limitSurfaceAngle(linePoints, surfaceNormal, maxSurfaceAngle) {\n  if (!(maxSurfaceAngle <= 180 && maxSurfaceAngle > 0)) {\n    return;\n  }\n\n  maxSurfaceAngle = maxSurfaceAngle / 180 * Math.PI;\n  pt0.fromArray(linePoints[0]);\n  pt1.fromArray(linePoints[1]);\n  pt2.fromArray(linePoints[2]);\n  Point.sub(dir, pt1, pt0);\n  Point.sub(dir2, pt2, pt1);\n  var len1 = dir.len();\n  var len2 = dir2.len();\n\n  if (len1 < 1e-3 || len2 < 1e-3) {\n    return;\n  }\n\n  dir.scale(1 / len1);\n  dir2.scale(1 / len2);\n  var angleCos = dir.dot(surfaceNormal);\n  var maxSurfaceAngleCos = Math.cos(maxSurfaceAngle);\n\n  if (angleCos < maxSurfaceAngleCos) {\n    // Calculate project point of pt0 on pt1-pt2\n    var d = projectPointToLine(pt1.x, pt1.y, pt2.x, pt2.y, pt0.x, pt0.y, tmpArr, false);\n    tmpProjPoint.fromArray(tmpArr);\n    var HALF_PI = Math.PI / 2;\n    var angle2 = Math.acos(dir2.dot(surfaceNormal));\n    var newAngle = HALF_PI + angle2 - maxSurfaceAngle;\n\n    if (newAngle >= HALF_PI) {\n      // parallel\n      Point.copy(tmpProjPoint, pt2);\n    } else {\n      // Calculate new projected length with limited minTurnAngle and get the new connect point\n      tmpProjPoint.scaleAndAdd(dir2, d / Math.tan(Math.PI / 2 - newAngle)); // Limit the new calculated connect point between pt1 and pt2.\n\n      var t = pt2.x !== pt1.x ? (tmpProjPoint.x - pt1.x) / (pt2.x - pt1.x) : (tmpProjPoint.y - pt1.y) / (pt2.y - pt1.y);\n\n      if (isNaN(t)) {\n        return;\n      }\n\n      if (t < 0) {\n        Point.copy(tmpProjPoint, pt1);\n      } else if (t > 1) {\n        Point.copy(tmpProjPoint, pt2);\n      }\n    }\n\n    tmpProjPoint.toArray(linePoints[1]);\n  }\n}\n\nfunction setLabelLineState(labelLine, ignore, stateName, stateModel) {\n  var isNormal = stateName === 'normal';\n  var stateObj = isNormal ? labelLine : labelLine.ensureState(stateName); // Make sure display.\n\n  stateObj.ignore = ignore; // Set smooth\n\n  var smooth = stateModel.get('smooth');\n\n  if (smooth && smooth === true) {\n    smooth = 0.3;\n  }\n\n  stateObj.shape = stateObj.shape || {};\n\n  if (smooth > 0) {\n    stateObj.shape.smooth = smooth;\n  }\n\n  var styleObj = stateModel.getModel('lineStyle').getLineStyle();\n  isNormal ? labelLine.useStyle(styleObj) : stateObj.style = styleObj;\n}\n\nfunction buildLabelLinePath(path, shape) {\n  var smooth = shape.smooth;\n  var points = shape.points;\n\n  if (!points) {\n    return;\n  }\n\n  path.moveTo(points[0][0], points[0][1]);\n\n  if (smooth > 0 && points.length >= 3) {\n    var len1 = vector.dist(points[0], points[1]);\n    var len2 = vector.dist(points[1], points[2]);\n\n    if (!len1 || !len2) {\n      path.lineTo(points[1][0], points[1][1]);\n      path.lineTo(points[2][0], points[2][1]);\n      return;\n    }\n\n    var moveLen = Math.min(len1, len2) * smooth;\n    var midPoint0 = vector.lerp([], points[1], points[0], moveLen / len1);\n    var midPoint2 = vector.lerp([], points[1], points[2], moveLen / len2);\n    var midPoint1 = vector.lerp([], midPoint0, midPoint2, 0.5);\n    path.bezierCurveTo(midPoint0[0], midPoint0[1], midPoint0[0], midPoint0[1], midPoint1[0], midPoint1[1]);\n    path.bezierCurveTo(midPoint2[0], midPoint2[1], midPoint2[0], midPoint2[1], points[2][0], points[2][1]);\n  } else {\n    for (var i = 1; i < points.length; i++) {\n      path.lineTo(points[i][0], points[i][1]);\n    }\n  }\n}\n/**\n * Create a label line if necessary and set it's style.\n */\n\n\nexport function setLabelLineStyle(targetEl, statesModels, defaultStyle) {\n  var labelLine = targetEl.getTextGuideLine();\n  var label = targetEl.getTextContent();\n\n  if (!label) {\n    // Not show label line if there is no label.\n    if (labelLine) {\n      targetEl.removeTextGuideLine();\n    }\n\n    return;\n  }\n\n  var normalModel = statesModels.normal;\n  var showNormal = normalModel.get('show');\n  var labelIgnoreNormal = label.ignore;\n\n  for (var i = 0; i < DISPLAY_STATES.length; i++) {\n    var stateName = DISPLAY_STATES[i];\n    var stateModel = statesModels[stateName];\n    var isNormal = stateName === 'normal';\n\n    if (stateModel) {\n      var stateShow = stateModel.get('show');\n      var isLabelIgnored = isNormal ? labelIgnoreNormal : retrieve2(label.states[stateName] && label.states[stateName].ignore, labelIgnoreNormal);\n\n      if (isLabelIgnored // Not show when label is not shown in this state.\n      || !retrieve2(stateShow, showNormal) // Use normal state by default if not set.\n      ) {\n          var stateObj = isNormal ? labelLine : labelLine && labelLine.states[stateName];\n\n          if (stateObj) {\n            stateObj.ignore = true;\n          }\n\n          continue;\n        } // Create labelLine if not exists\n\n\n      if (!labelLine) {\n        labelLine = new Polyline();\n        targetEl.setTextGuideLine(labelLine); // Reset state of normal because it's new created.\n        // NOTE: NORMAL should always been the first!\n\n        if (!isNormal && (labelIgnoreNormal || !showNormal)) {\n          setLabelLineState(labelLine, true, 'normal', statesModels.normal);\n        } // Use same state proxy.\n\n\n        if (targetEl.stateProxy) {\n          labelLine.stateProxy = targetEl.stateProxy;\n        }\n      }\n\n      setLabelLineState(labelLine, false, stateName, stateModel);\n    }\n  }\n\n  if (labelLine) {\n    defaults(labelLine.style, defaultStyle); // Not fill.\n\n    labelLine.style.fill = null;\n    var showAbove = normalModel.get('showAbove');\n    var labelLineConfig = targetEl.textGuideLineConfig = targetEl.textGuideLineConfig || {};\n    labelLineConfig.showAbove = showAbove || false; // Custom the buildPath.\n\n    labelLine.buildPath = buildLabelLinePath;\n  }\n}\nexport function getLabelLineStatesModels(itemModel, labelLineName) {\n  labelLineName = labelLineName || 'labelLine';\n  var statesModels = {\n    normal: itemModel.getModel(labelLineName)\n  };\n\n  for (var i = 0; i < SPECIAL_STATES.length; i++) {\n    var stateName = SPECIAL_STATES[i];\n    statesModels[stateName] = itemModel.getModel([stateName, labelLineName]);\n  }\n\n  return statesModels;\n}","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { BoundingRect, OrientedBoundingRect } from '../util/graphic.js';\nexport function prepareLayoutList(input) {\n  var list = [];\n\n  for (var i = 0; i < input.length; i++) {\n    var rawItem = input[i];\n\n    if (rawItem.defaultAttr.ignore) {\n      continue;\n    }\n\n    var label = rawItem.label;\n    var transform = label.getComputedTransform(); // NOTE: Get bounding rect after getComputedTransform, or label may not been updated by the host el.\n\n    var localRect = label.getBoundingRect();\n    var isAxisAligned = !transform || transform[1] < 1e-5 && transform[2] < 1e-5;\n    var minMargin = label.style.margin || 0;\n    var globalRect = localRect.clone();\n    globalRect.applyTransform(transform);\n    globalRect.x -= minMargin / 2;\n    globalRect.y -= minMargin / 2;\n    globalRect.width += minMargin;\n    globalRect.height += minMargin;\n    var obb = isAxisAligned ? new OrientedBoundingRect(localRect, transform) : null;\n    list.push({\n      label: label,\n      labelLine: rawItem.labelLine,\n      rect: globalRect,\n      localRect: localRect,\n      obb: obb,\n      priority: rawItem.priority,\n      defaultAttr: rawItem.defaultAttr,\n      layoutOption: rawItem.computedLayoutOption,\n      axisAligned: isAxisAligned,\n      transform: transform\n    });\n  }\n\n  return list;\n}\n\nfunction shiftLayout(list, xyDim, sizeDim, minBound, maxBound, balanceShift) {\n  var len = list.length;\n\n  if (len < 2) {\n    return;\n  }\n\n  list.sort(function (a, b) {\n    return a.rect[xyDim] - b.rect[xyDim];\n  });\n  var lastPos = 0;\n  var delta;\n  var adjusted = false;\n  var shifts = [];\n  var totalShifts = 0;\n\n  for (var i = 0; i < len; i++) {\n    var item = list[i];\n    var rect = item.rect;\n    delta = rect[xyDim] - lastPos;\n\n    if (delta < 0) {\n      // shiftForward(i, len, -delta);\n      rect[xyDim] -= delta;\n      item.label[xyDim] -= delta;\n      adjusted = true;\n    }\n\n    var shift = Math.max(-delta, 0);\n    shifts.push(shift);\n    totalShifts += shift;\n    lastPos = rect[xyDim] + rect[sizeDim];\n  }\n\n  if (totalShifts > 0 && balanceShift) {\n    // Shift back to make the distribution more equally.\n    shiftList(-totalShifts / len, 0, len);\n  } // TODO bleedMargin?\n\n\n  var first = list[0];\n  var last = list[len - 1];\n  var minGap;\n  var maxGap;\n  updateMinMaxGap(); // If ends exceed two bounds, squeeze at most 80%, then take the gap of two bounds.\n\n  minGap < 0 && squeezeGaps(-minGap, 0.8);\n  maxGap < 0 && squeezeGaps(maxGap, 0.8);\n  updateMinMaxGap();\n  takeBoundsGap(minGap, maxGap, 1);\n  takeBoundsGap(maxGap, minGap, -1); // Handle bailout when there is not enough space.\n\n  updateMinMaxGap();\n\n  if (minGap < 0) {\n    squeezeWhenBailout(-minGap);\n  }\n\n  if (maxGap < 0) {\n    squeezeWhenBailout(maxGap);\n  }\n\n  function updateMinMaxGap() {\n    minGap = first.rect[xyDim] - minBound;\n    maxGap = maxBound - last.rect[xyDim] - last.rect[sizeDim];\n  }\n\n  function takeBoundsGap(gapThisBound, gapOtherBound, moveDir) {\n    if (gapThisBound < 0) {\n      // Move from other gap if can.\n      var moveFromMaxGap = Math.min(gapOtherBound, -gapThisBound);\n\n      if (moveFromMaxGap > 0) {\n        shiftList(moveFromMaxGap * moveDir, 0, len);\n        var remained = moveFromMaxGap + gapThisBound;\n\n        if (remained < 0) {\n          squeezeGaps(-remained * moveDir, 1);\n        }\n      } else {\n        squeezeGaps(-gapThisBound * moveDir, 1);\n      }\n    }\n  }\n\n  function shiftList(delta, start, end) {\n    if (delta !== 0) {\n      adjusted = true;\n    }\n\n    for (var i = start; i < end; i++) {\n      var item = list[i];\n      var rect = item.rect;\n      rect[xyDim] += delta;\n      item.label[xyDim] += delta;\n    }\n  } // Squeeze gaps if the labels exceed margin.\n\n\n  function squeezeGaps(delta, maxSqeezePercent) {\n    var gaps = [];\n    var totalGaps = 0;\n\n    for (var i = 1; i < len; i++) {\n      var prevItemRect = list[i - 1].rect;\n      var gap = Math.max(list[i].rect[xyDim] - prevItemRect[xyDim] - prevItemRect[sizeDim], 0);\n      gaps.push(gap);\n      totalGaps += gap;\n    }\n\n    if (!totalGaps) {\n      return;\n    }\n\n    var squeezePercent = Math.min(Math.abs(delta) / totalGaps, maxSqeezePercent);\n\n    if (delta > 0) {\n      for (var i = 0; i < len - 1; i++) {\n        // Distribute the shift delta to all gaps.\n        var movement = gaps[i] * squeezePercent; // Forward\n\n        shiftList(movement, 0, i + 1);\n      }\n    } else {\n      // Backward\n      for (var i = len - 1; i > 0; i--) {\n        // Distribute the shift delta to all gaps.\n        var movement = gaps[i - 1] * squeezePercent;\n        shiftList(-movement, i, len);\n      }\n    }\n  }\n  /**\n   * Squeeze to allow overlap if there is no more space available.\n   * Let other overlapping strategy like hideOverlap do the job instead of keep exceeding the bounds.\n   */\n\n\n  function squeezeWhenBailout(delta) {\n    var dir = delta < 0 ? -1 : 1;\n    delta = Math.abs(delta);\n    var moveForEachLabel = Math.ceil(delta / (len - 1));\n\n    for (var i = 0; i < len - 1; i++) {\n      if (dir > 0) {\n        // Forward\n        shiftList(moveForEachLabel, 0, i + 1);\n      } else {\n        // Backward\n        shiftList(-moveForEachLabel, len - i - 1, len);\n      }\n\n      delta -= moveForEachLabel;\n\n      if (delta <= 0) {\n        return;\n      }\n    }\n  }\n\n  return adjusted;\n}\n/**\n * Adjust labels on x direction to avoid overlap.\n */\n\n\nexport function shiftLayoutOnX(list, leftBound, rightBound, // If average the shifts on all labels and add them to 0\n// TODO: Not sure if should enable it.\n// Pros: The angle of lines will distribute more equally\n// Cons: In some layout. It may not what user wanted. like in pie. the label of last sector is usually changed unexpectedly.\nbalanceShift) {\n  return shiftLayout(list, 'x', 'width', leftBound, rightBound, balanceShift);\n}\n/**\n * Adjust labels on y direction to avoid overlap.\n */\n\nexport function shiftLayoutOnY(list, topBound, bottomBound, // If average the shifts on all labels and add them to 0\nbalanceShift) {\n  return shiftLayout(list, 'y', 'height', topBound, bottomBound, balanceShift);\n}\nexport function hideOverlap(labelList) {\n  var displayedLabels = []; // TODO, render overflow visible first, put in the displayedLabels.\n\n  labelList.sort(function (a, b) {\n    return b.priority - a.priority;\n  });\n  var globalRect = new BoundingRect(0, 0, 0, 0);\n\n  function hideEl(el) {\n    if (!el.ignore) {\n      // Show on emphasis.\n      var emphasisState = el.ensureState('emphasis');\n\n      if (emphasisState.ignore == null) {\n        emphasisState.ignore = false;\n      }\n    }\n\n    el.ignore = true;\n  }\n\n  for (var i = 0; i < labelList.length; i++) {\n    var labelItem = labelList[i];\n    var isAxisAligned = labelItem.axisAligned;\n    var localRect = labelItem.localRect;\n    var transform = labelItem.transform;\n    var label = labelItem.label;\n    var labelLine = labelItem.labelLine;\n    globalRect.copy(labelItem.rect); // Add a threshold because layout may be aligned precisely.\n\n    globalRect.width -= 0.1;\n    globalRect.height -= 0.1;\n    globalRect.x += 0.05;\n    globalRect.y += 0.05;\n    var obb = labelItem.obb;\n    var overlapped = false;\n\n    for (var j = 0; j < displayedLabels.length; j++) {\n      var existsTextCfg = displayedLabels[j]; // Fast rejection.\n\n      if (!globalRect.intersect(existsTextCfg.rect)) {\n        continue;\n      }\n\n      if (isAxisAligned && existsTextCfg.axisAligned) {\n        // Is overlapped\n        overlapped = true;\n        break;\n      }\n\n      if (!existsTextCfg.obb) {\n        // If self is not axis aligned. But other is.\n        existsTextCfg.obb = new OrientedBoundingRect(existsTextCfg.localRect, existsTextCfg.transform);\n      }\n\n      if (!obb) {\n        // If self is axis aligned. But other is not.\n        obb = new OrientedBoundingRect(localRect, transform);\n      }\n\n      if (obb.intersect(existsTextCfg.obb)) {\n        overlapped = true;\n        break;\n      }\n    } // TODO Callback to determine if this overlap should be handled?\n\n\n    if (overlapped) {\n      hideEl(label);\n      labelLine && hideEl(labelLine);\n    } else {\n      label.attr('ignore', labelItem.defaultAttr.ignore);\n      labelLine && labelLine.attr('ignore', labelItem.defaultAttr.labelGuideIgnore);\n      displayedLabels.push(labelItem);\n    }\n  }\n}"],"names":["PI2","Math","PI","CMD","PathProxy","DEFAULT_SEARCH_SPACE","getCandidateAnchor","pos","distance","rect","outPt","outDir","width","height","set","x","y","projectPointToArc","cx","cy","r","startAngle","endAngle","anticlockwise","out","d","sqrt","ox","oy","abs","tmp","normalizeRadian","angle","atan2","x1","cos","y1","sin","x2","y2","d1","d2","projectPointToLine","limitToEnds","dx","dy","dx1","dy1","lineLen","t","min","max","projectPointToRect","tmpPt","nearestPointOnRect","pt","dist","nearestPointOnPath","path","xi","yi","x0","y0","minDist","Infinity","data","i","length","cmd","M","L","C","cubicProjectPoint","Q","quadraticProjectPoint","A","rx","ry","theta","dTheta","R","Z","pt0","Point","pt1","pt2","dir","dir2","updateLabelLinePoints","target","labelLineModel","labelLine","getTextGuideLine","label","getTextContent","labelGuideConfig","textGuideLineConfig","points","searchSpace","candidates","labelRect","getBoundingRect","clone","applyTransform","getComputedTransform","anchorPoint","anchor","targetTransform","targetInversedTransform","invert","len","get","copy","transform","boundingRect","Path","toArray","limitTurnAngle","setShape","tmpArr","tmpProjPoint","linePoints","minTurnAngle","fromArray","len1","len2","scale","angleCos","dot","scaleAndAdd","tan","isNaN","limitSurfaceAngle","surfaceNormal","maxSurfaceAngle","HALF_PI","newAngle","acos","setLabelLineState","ignore","stateName","stateModel","isNormal","stateObj","ensureState","smooth","shape","styleObj","getModel","getLineStyle","useStyle","style","buildLabelLinePath","moveTo","vector","lineTo","moveLen","midPoint0","midPoint2","midPoint1","bezierCurveTo","setLabelLineStyle","targetEl","statesModels","defaultStyle","normalModel","normal","showNormal","labelIgnoreNormal","DISPLAY_STATES","stateShow","retrieve2","states","Polyline","setTextGuideLine","stateProxy","defaults","fill","showAbove","buildPath","removeTextGuideLine","getLabelLineStatesModels","itemModel","labelLineName","SPECIAL_STATES","prepareLayoutList","input","list","rawItem","defaultAttr","localRect","isAxisAligned","minMargin","margin","globalRect","obb","OrientedBoundingRect","push","priority","layoutOption","computedLayoutOption","axisAligned","shiftLayout","xyDim","sizeDim","minBound","maxBound","balanceShift","sort","a","b","delta","lastPos","adjusted","shifts","totalShifts","item","shift","shiftList","minGap","maxGap","first","last","updateMinMaxGap","squeezeGaps","takeBoundsGap","squeezeWhenBailout","gapThisBound","gapOtherBound","moveDir","moveFromMaxGap","remained","start","end","maxSqeezePercent","gaps","totalGaps","prevItemRect","gap","squeezePercent","moveForEachLabel","ceil","shiftLayoutOnX","leftBound","rightBound","shiftLayoutOnY","topBound","bottomBound","hideOverlap","labelList","displayedLabels","BoundingRect","hideEl","el","emphasisState","labelItem","overlapped","j","existsTextCfg","intersect","attr","labelGuideIgnore"],"sourceRoot":""}
{"version":3,"file":"static/js/3684.c3df5e7a.js","mappings":"4HAiDIA,GAAQC,E,SAAAA,MAkCZ,SAASC,EAAkBC,EAAKC,GAC9B,GA0DOJ,EA1DQK,MA0DIC,WA1DJD,KAAO,CAEpB,IAAIE,GAAQC,EAAAA,EAAAA,IAAO,CAAC,EAAGR,EAAMK,MAAME,OACnCA,EAAMF,KAAKI,UAAYL,EACvBM,EAAQN,EAAKG,EAAOJ,EACtB,MAEEQ,EAAWP,EAAKC,KAAKI,SAAUT,EAAMK,MAAMC,SAAUH,GAGvD,OAAOC,CACT,CAEA,SAASQ,EAAgBT,EAAKC,GAE5B,OADAD,EAAIU,QAAUV,EAAIU,OAAOC,SAClBV,CACT,CAEA,SAASW,EAAsBZ,EAAKC,GAQlC,OAHAY,EAAAA,EAAAA,IAAKhB,EAAMI,GAAKG,OAAO,SAAUU,EAAMR,GACrCQ,IAASb,GAAOO,EAAWM,EAAKC,eAAgBT,EAAUL,EAAKD,EACjE,IACOC,CACT,CASA,SAASe,EAAcV,GACrB,IAAIH,EAAWN,EAAMK,MAAMC,SAC3B,OAAmB,MAAZG,GAAgC,MAAZH,EAAmBA,EAAWN,EAAMM,GAAUC,MAAME,EACjF,CAMA,SAASW,IACP,IAAId,EAAWN,EAAMK,MAAMC,SAC3B,OAAmB,MAAZA,EAAmB,CAAC,CACzBW,KAAMX,KACHe,EAAAA,EAAAA,KAAIC,EAAAA,EAAAA,IAAKtB,EAAMM,GAAUC,QAAQ,SAAUgB,GAC9C,MAAO,CACLA,KAAMA,EACNN,KAAMjB,EAAMM,GAAUC,MAAMgB,GAEhC,GACF,CAMA,SAASb,EAAQJ,EAAUC,EAAOJ,GAChCH,EAAMM,GAAUC,MAAQ,CAAC,GACzBS,EAAAA,EAAAA,IAAKT,GAAO,SAAUU,EAAMR,GAC1BE,EAAWM,EAAMR,EAAUH,EAAUH,EACvC,GACF,CAEA,SAASQ,EAAWM,EAAMR,EAAUH,EAAUH,GAC5CH,EAAMM,GAAUC,MAAME,GAAYQ,EAClCjB,EAAMiB,GAAMX,SAAWA,EACvBW,EAAKR,SAAWA,EAEZN,EAAIU,SACNI,EAAKd,EAAIqB,YAAcrB,EAAIU,OAC3BV,EAAIU,OAAOV,EAAIsB,UAAUhB,IAAaQ,GAIxCA,EAAKE,cAAgBA,EACrBF,EAAKG,iBAAmBA,CAC1B,CAEA,IApHA,SAAwBjB,GACtB,IAAIG,EAAWH,EAAIG,SACfC,EAAQJ,EAAII,MAEXA,IACHA,EAAQ,CACNmB,KAAMpB,GAERH,EAAIsB,UAAY,CACdC,KAAM,SAIVvB,EAAII,MAAQJ,EAAIG,SAAW,KAC3BI,EAAQJ,EAAUC,EAAOJ,IAEzBa,EAAAA,EAAAA,IAAKT,GAAO,SAAUU,IACpBD,EAAAA,EAAAA,IAAKV,EAASqB,sBAAsB,SAAUC,GAC5CX,EAAKY,WAAWD,GAAYE,EAAAA,EAAAA,IAAM5B,EAAmBC,GACvD,GACF,IAEAG,EAASuB,WAAW,gBAAgBC,EAAAA,EAAAA,IAAMf,EAAuBZ,KAGjEa,EAAAA,EAAAA,IAAKV,EAASyB,mBAAmB,SAAUH,GACzCtB,EAASuB,WAAWD,GAAYE,EAAAA,EAAAA,IAAMlB,EAAiBT,GACzD,KAEA6B,EAAAA,EAAAA,IAAOzB,EAAMD,EAASG,YAAcH,EACtC,C","sources":["../node_modules/echarts/lib/data/helper/linkSeriesData.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Link lists and struct (graph or tree)\n */\nimport { curry, each, assert, extend, map, keys } from 'zrender/lib/core/util.js';\nimport { makeInner } from '../../util/model.js';\nvar inner = makeInner();\n\nfunction linkSeriesData(opt) {\n  var mainData = opt.mainData;\n  var datas = opt.datas;\n\n  if (!datas) {\n    datas = {\n      main: mainData\n    };\n    opt.datasAttr = {\n      main: 'data'\n    };\n  }\n\n  opt.datas = opt.mainData = null;\n  linkAll(mainData, datas, opt); // Porxy data original methods.\n\n  each(datas, function (data) {\n    each(mainData.TRANSFERABLE_METHODS, function (methodName) {\n      data.wrapMethod(methodName, curry(transferInjection, opt));\n    });\n  }); // Beyond transfer, additional features should be added to `cloneShallow`.\n\n  mainData.wrapMethod('cloneShallow', curry(cloneShallowInjection, opt)); // Only mainData trigger change, because struct.update may trigger\n  // another changable methods, which may bring about dead lock.\n\n  each(mainData.CHANGABLE_METHODS, function (methodName) {\n    mainData.wrapMethod(methodName, curry(changeInjection, opt));\n  }); // Make sure datas contains mainData.\n\n  assert(datas[mainData.dataType] === mainData);\n}\n\nfunction transferInjection(opt, res) {\n  if (isMainData(this)) {\n    // Transfer datas to new main data.\n    var datas = extend({}, inner(this).datas);\n    datas[this.dataType] = res;\n    linkAll(res, datas, opt);\n  } else {\n    // Modify the reference in main data to point newData.\n    linkSingle(res, this.dataType, inner(this).mainData, opt);\n  }\n\n  return res;\n}\n\nfunction changeInjection(opt, res) {\n  opt.struct && opt.struct.update();\n  return res;\n}\n\nfunction cloneShallowInjection(opt, res) {\n  // cloneShallow, which brings about some fragilities, may be inappropriate\n  // to be exposed as an API. So for implementation simplicity we can make\n  // the restriction that cloneShallow of not-mainData should not be invoked\n  // outside, but only be invoked here.\n  each(inner(res).datas, function (data, dataType) {\n    data !== res && linkSingle(data.cloneShallow(), dataType, res, opt);\n  });\n  return res;\n}\n/**\n * Supplement method to List.\n *\n * @public\n * @param [dataType] If not specified, return mainData.\n */\n\n\nfunction getLinkedData(dataType) {\n  var mainData = inner(this).mainData;\n  return dataType == null || mainData == null ? mainData : inner(mainData).datas[dataType];\n}\n/**\n * Get list of all linked data\n */\n\n\nfunction getLinkedDataAll() {\n  var mainData = inner(this).mainData;\n  return mainData == null ? [{\n    data: mainData\n  }] : map(keys(inner(mainData).datas), function (type) {\n    return {\n      type: type,\n      data: inner(mainData).datas[type]\n    };\n  });\n}\n\nfunction isMainData(data) {\n  return inner(data).mainData === data;\n}\n\nfunction linkAll(mainData, datas, opt) {\n  inner(mainData).datas = {};\n  each(datas, function (data, dataType) {\n    linkSingle(data, dataType, mainData, opt);\n  });\n}\n\nfunction linkSingle(data, dataType, mainData, opt) {\n  inner(mainData).datas[dataType] = data;\n  inner(data).mainData = mainData;\n  data.dataType = dataType;\n\n  if (opt.struct) {\n    data[opt.structAttr] = opt.struct;\n    opt.struct[opt.datasAttr[dataType]] = data;\n  } // Supplement method.\n\n\n  data.getLinkedData = getLinkedData;\n  data.getLinkedDataAll = getLinkedDataAll;\n}\n\nexport default linkSeriesData;"],"names":["inner","makeInner","transferInjection","opt","res","this","mainData","datas","extend","dataType","linkAll","linkSingle","changeInjection","struct","update","cloneShallowInjection","each","data","cloneShallow","getLinkedData","getLinkedDataAll","map","keys","type","structAttr","datasAttr","main","TRANSFERABLE_METHODS","methodName","wrapMethod","curry","CHANGABLE_METHODS","assert"],"sourceRoot":""}
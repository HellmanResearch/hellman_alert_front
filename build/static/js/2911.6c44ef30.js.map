{"version":3,"file":"static/js/2911.6c44ef30.js","mappings":"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","sources":["../node_modules/echarts/lib/data/DataDiffer.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction dataIndexMapValueLength(valNumOrArrLengthMoreThan2) {\n  return valNumOrArrLengthMoreThan2 == null ? 0 : valNumOrArrLengthMoreThan2.length || 1;\n}\n\nfunction defaultKeyGetter(item) {\n  return item;\n}\n\nvar DataDiffer =\n/** @class */\nfunction () {\n  /**\n   * @param context Can be visited by this.context in callback.\n   */\n  function DataDiffer(oldArr, newArr, oldKeyGetter, newKeyGetter, context, // By default: 'oneToOne'.\n  diffMode) {\n    this._old = oldArr;\n    this._new = newArr;\n    this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;\n    this._newKeyGetter = newKeyGetter || defaultKeyGetter; // Visible in callback via `this.context`;\n\n    this.context = context;\n    this._diffModeMultiple = diffMode === 'multiple';\n  }\n  /**\n   * Callback function when add a data\n   */\n\n\n  DataDiffer.prototype.add = function (func) {\n    this._add = func;\n    return this;\n  };\n  /**\n   * Callback function when update a data\n   */\n\n\n  DataDiffer.prototype.update = function (func) {\n    this._update = func;\n    return this;\n  };\n  /**\n   * Callback function when update a data and only work in `cbMode: 'byKey'`.\n   */\n\n\n  DataDiffer.prototype.updateManyToOne = function (func) {\n    this._updateManyToOne = func;\n    return this;\n  };\n  /**\n   * Callback function when update a data and only work in `cbMode: 'byKey'`.\n   */\n\n\n  DataDiffer.prototype.updateOneToMany = function (func) {\n    this._updateOneToMany = func;\n    return this;\n  };\n  /**\n   * Callback function when update a data and only work in `cbMode: 'byKey'`.\n   */\n\n\n  DataDiffer.prototype.updateManyToMany = function (func) {\n    this._updateManyToMany = func;\n    return this;\n  };\n  /**\n   * Callback function when remove a data\n   */\n\n\n  DataDiffer.prototype.remove = function (func) {\n    this._remove = func;\n    return this;\n  };\n\n  DataDiffer.prototype.execute = function () {\n    this[this._diffModeMultiple ? '_executeMultiple' : '_executeOneToOne']();\n  };\n\n  DataDiffer.prototype._executeOneToOne = function () {\n    var oldArr = this._old;\n    var newArr = this._new;\n    var newDataIndexMap = {};\n    var oldDataKeyArr = new Array(oldArr.length);\n    var newDataKeyArr = new Array(newArr.length);\n\n    this._initIndexMap(oldArr, null, oldDataKeyArr, '_oldKeyGetter');\n\n    this._initIndexMap(newArr, newDataIndexMap, newDataKeyArr, '_newKeyGetter');\n\n    for (var i = 0; i < oldArr.length; i++) {\n      var oldKey = oldDataKeyArr[i];\n      var newIdxMapVal = newDataIndexMap[oldKey];\n      var newIdxMapValLen = dataIndexMapValueLength(newIdxMapVal); // idx can never be empty array here. see 'set null' logic below.\n\n      if (newIdxMapValLen > 1) {\n        // Consider there is duplicate key (for example, use dataItem.name as key).\n        // We should make sure every item in newArr and oldArr can be visited.\n        var newIdx = newIdxMapVal.shift();\n\n        if (newIdxMapVal.length === 1) {\n          newDataIndexMap[oldKey] = newIdxMapVal[0];\n        }\n\n        this._update && this._update(newIdx, i);\n      } else if (newIdxMapValLen === 1) {\n        newDataIndexMap[oldKey] = null;\n        this._update && this._update(newIdxMapVal, i);\n      } else {\n        this._remove && this._remove(i);\n      }\n    }\n\n    this._performRestAdd(newDataKeyArr, newDataIndexMap);\n  };\n  /**\n   * For example, consider the case:\n   * oldData: [o0, o1, o2, o3, o4, o5, o6, o7],\n   * newData: [n0, n1, n2, n3, n4, n5, n6, n7, n8],\n   * Where:\n   *     o0, o1, n0 has key 'a' (many to one)\n   *     o5, n4, n5, n6 has key 'b' (one to many)\n   *     o2, n1 has key 'c' (one to one)\n   *     n2, n3 has key 'd' (add)\n   *     o3, o4 has key 'e' (remove)\n   *     o6, o7, n7, n8 has key 'f' (many to many, treated as add and remove)\n   * Then:\n   *     (The order of the following directives are not ensured.)\n   *     this._updateManyToOne(n0, [o0, o1]);\n   *     this._updateOneToMany([n4, n5, n6], o5);\n   *     this._update(n1, o2);\n   *     this._remove(o3);\n   *     this._remove(o4);\n   *     this._remove(o6);\n   *     this._remove(o7);\n   *     this._add(n2);\n   *     this._add(n3);\n   *     this._add(n7);\n   *     this._add(n8);\n   */\n\n\n  DataDiffer.prototype._executeMultiple = function () {\n    var oldArr = this._old;\n    var newArr = this._new;\n    var oldDataIndexMap = {};\n    var newDataIndexMap = {};\n    var oldDataKeyArr = [];\n    var newDataKeyArr = [];\n\n    this._initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, '_oldKeyGetter');\n\n    this._initIndexMap(newArr, newDataIndexMap, newDataKeyArr, '_newKeyGetter');\n\n    for (var i = 0; i < oldDataKeyArr.length; i++) {\n      var oldKey = oldDataKeyArr[i];\n      var oldIdxMapVal = oldDataIndexMap[oldKey];\n      var newIdxMapVal = newDataIndexMap[oldKey];\n      var oldIdxMapValLen = dataIndexMapValueLength(oldIdxMapVal);\n      var newIdxMapValLen = dataIndexMapValueLength(newIdxMapVal);\n\n      if (oldIdxMapValLen > 1 && newIdxMapValLen === 1) {\n        this._updateManyToOne && this._updateManyToOne(newIdxMapVal, oldIdxMapVal);\n        newDataIndexMap[oldKey] = null;\n      } else if (oldIdxMapValLen === 1 && newIdxMapValLen > 1) {\n        this._updateOneToMany && this._updateOneToMany(newIdxMapVal, oldIdxMapVal);\n        newDataIndexMap[oldKey] = null;\n      } else if (oldIdxMapValLen === 1 && newIdxMapValLen === 1) {\n        this._update && this._update(newIdxMapVal, oldIdxMapVal);\n        newDataIndexMap[oldKey] = null;\n      } else if (oldIdxMapValLen > 1 && newIdxMapValLen > 1) {\n        this._updateManyToMany && this._updateManyToMany(newIdxMapVal, oldIdxMapVal);\n        newDataIndexMap[oldKey] = null;\n      } else if (oldIdxMapValLen > 1) {\n        for (var i_1 = 0; i_1 < oldIdxMapValLen; i_1++) {\n          this._remove && this._remove(oldIdxMapVal[i_1]);\n        }\n      } else {\n        this._remove && this._remove(oldIdxMapVal);\n      }\n    }\n\n    this._performRestAdd(newDataKeyArr, newDataIndexMap);\n  };\n\n  DataDiffer.prototype._performRestAdd = function (newDataKeyArr, newDataIndexMap) {\n    for (var i = 0; i < newDataKeyArr.length; i++) {\n      var newKey = newDataKeyArr[i];\n      var newIdxMapVal = newDataIndexMap[newKey];\n      var idxMapValLen = dataIndexMapValueLength(newIdxMapVal);\n\n      if (idxMapValLen > 1) {\n        for (var j = 0; j < idxMapValLen; j++) {\n          this._add && this._add(newIdxMapVal[j]);\n        }\n      } else if (idxMapValLen === 1) {\n        this._add && this._add(newIdxMapVal);\n      } // Support both `newDataKeyArr` are duplication removed or not removed.\n\n\n      newDataIndexMap[newKey] = null;\n    }\n  };\n\n  DataDiffer.prototype._initIndexMap = function (arr, // Can be null.\n  map, // In 'byKey', the output `keyArr` is duplication removed.\n  // In 'byIndex', the output `keyArr` is not duplication removed and\n  //     its indices are accurately corresponding to `arr`.\n  keyArr, keyGetterName) {\n    var cbModeMultiple = this._diffModeMultiple;\n\n    for (var i = 0; i < arr.length; i++) {\n      // Add prefix to avoid conflict with Object.prototype.\n      var key = '_ec_' + this[keyGetterName](arr[i], i);\n\n      if (!cbModeMultiple) {\n        keyArr[i] = key;\n      }\n\n      if (!map) {\n        continue;\n      }\n\n      var idxMapVal = map[key];\n      var idxMapValLen = dataIndexMapValueLength(idxMapVal);\n\n      if (idxMapValLen === 0) {\n        // Simple optimize: in most cases, one index has one key,\n        // do not need array.\n        map[key] = i;\n\n        if (cbModeMultiple) {\n          keyArr.push(key);\n        }\n      } else if (idxMapValLen === 1) {\n        map[key] = [idxMapVal, i];\n      } else {\n        idxMapVal.push(i);\n      }\n    }\n  };\n\n  return DataDiffer;\n}();\n\nexport default DataDiffer;"],"names":["dataIndexMapValueLength","valNumOrArrLengthMoreThan2","length","defaultKeyGetter","item","DataDiffer","oldArr","newArr","oldKeyGetter","newKeyGetter","context","diffMode","this","_old","_new","_oldKeyGetter","_newKeyGetter","_diffModeMultiple","prototype","add","func","_add","update","_update","updateManyToOne","_updateManyToOne","updateOneToMany","_updateOneToMany","updateManyToMany","_updateManyToMany","remove","_remove","execute","_executeOneToOne","newDataIndexMap","oldDataKeyArr","Array","newDataKeyArr","_initIndexMap","i","oldKey","newIdxMapVal","newIdxMapValLen","newIdx","shift","_performRestAdd","_executeMultiple","oldDataIndexMap","oldIdxMapVal","oldIdxMapValLen","i_1","newKey","idxMapValLen","j","arr","map","keyArr","keyGetterName","cbModeMultiple","key","idxMapVal","push"],"sourceRoot":""}